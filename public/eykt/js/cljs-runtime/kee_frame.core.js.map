{"version":3,"sources":["kee_frame/core.cljc"],"mappings":"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","names":["kee-frame.core/valid-option-key?","kee-frame.core/extra-options","options","cljs.core.filter","p__49934","vec__49935","cljs.core.nth","k","cljs.core/not","cljs.core.into","kee-frame.core/start!","kee-frame.log/init!","cljs.spec.alpha.valid_QMARK_","expound.alpha.expound","cljs.core.ex_info","cljs.spec.alpha/explain-data","extras","cljs.core/seq","kee-frame.router/start!","kee-frame.core/reg-chain","kee-frame.legacy/reg-chain","kee-frame.core/reg-chain-named","kee-frame.legacy/reg-chain-named","kee-frame.core/reg-event-fx","kee-frame.legacy/reg-event-fx","kee-frame.core/reg-event-db","kee-frame.legacy/reg-event-db","kee-frame.core/-replace-controller","controllers","controller","cljs.core.reduce","ret","existing-controller","cljs.core._EQ_","cljs.core.conj","re-frame.interop/empty-queue","kee-frame.core/reg-controller","id","cljs.core.assoc","cljs.core.swap_BANG_","kee-frame.state/controllers","ids","cljs.core.map","cljs.core/some","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","kee-frame.core/path-for","seq49939","G__49940","cljs.core/first","cljs.core/next","self__4851__auto__","handler","params","cljs.core.apply","kee-frame.router/url","kee-frame.core/case-route","seq49942","G__49943","f","pairs","kee-frame.router/case-route","kee-frame.core/switch-route","seq49944","G__49945","kee-frame.router/switch-route"],"sourcesContent":["(ns kee-frame.core\n  (:require [kee-frame.legacy :as legacy]\n            [kee-frame.state :as state]\n            [kee-frame.router :as router]\n            [re-frame.core :as rf :refer [console]]\n            [kee-frame.log :as log]\n            [kee-frame.spec :as spec]\n            [re-frame.interop :as interop]\n            [clojure.spec.alpha :as s]\n            [expound.alpha :as e]))\n\n(def valid-option-key? #{:router :hash-routing? :routes :process-route :debug? :debug-config\n                         :chain-links :app-db-spec :root-component :initial-db :log-spec-error\n                         :screen :scroll :route-change-event :not-found :log :global-interceptors})\n\n(defn extra-options\n  \"Complete listing of invalid options sent to the `start!` function.\"\n  [options]\n  (->> options\n       (filter (fn [[k]] (not (valid-option-key? k))))\n       (into {})))\n\n(defn start!\n  \"Starts your client application with the specified `options`.\n\n  This function is intentionally forgiving in certain ways:\n  - You can call it as often as you want. Figwheel should call it on each code change\n  - You can omit the `options` altogether. kee-frame chooses sensible defaults for you and leads the way.\n\n  Usage:\n  ```\n  (k/start! {:debug?         true\n             :routes         my-reitit-routes\n             :hash-routing?  true\n             :initial-db     {:some-property \\\"default value\\\"}\n             :root-component [my-reagent-root-component]\n             :app-db-spec    :spec/my-db-spec})\n  ```\"\n  [options]\n  (log/init! (:log options))\n  (when-not (s/valid? ::spec/start-options options)\n    (e/expound ::spec/start-options options)\n    (throw (ex-info \"Invalid options\" (s/explain-data ::spec/start-options options))))\n  (let [extras (extra-options options)]\n    (when (seq extras)\n      (throw (ex-info (str \"Uknown startup options. Valid keys are \" valid-option-key?) extras))))\n  (router/start! options))\n\n(def reg-chain legacy/reg-chain)\n;(def reg-chain* chain/reg-chain*)\n(def reg-chain-named legacy/reg-chain-named)\n;(def reg-chain-named* chain/reg-chain-named*)\n(def reg-event-fx legacy/reg-event-fx)\n(def reg-event-db legacy/reg-event-db)\n\n(defn -replace-controller\n  [controllers controller]\n  (reduce\n   (fn [ret existing-controller]\n     (if (= (:id controller)\n            (:id existing-controller))\n       (conj ret controller)\n       (conj ret existing-controller)))\n   interop/empty-queue\n   controllers))\n\n(defn reg-controller\n  \"Put a controller config map into the global controller registry.\n\n  Parameters:\n\n  `id`: Must be unique in controllere registry. Will appear in logs.\n\n  `controller`: A map with the following keys:\n  - `:params`: A function that receives the route data and returns the part that should be sent to the `start` function. A nil\n  return means that the controller should not run for this route.\n\n  - `:start`: A function or an event vector. Called when `params` returns a non-nil value different from the previous\n  invocation. The function receives whatever non-nil value that was returned from `params`,\n  and returns a re-frame event vector. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\n\n  - `:stop`: Optional. A function or an event vector. Called when previous invocation of `params` returned non-nil and the\n  current invocation returned nil. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\"\n  [id controller]\n  (let [controller (assoc controller :id id)]\n    (when-not (s/valid? ::spec/controller controller)\n      (e/expound ::spec/controller controller)\n      (throw (ex-info \"Invalid controller\" (s/explain-data ::spec/controller controller))))\n    (swap! state/controllers (fn [controllers]\n                               (let [ids (map :id controllers)]\n                                 (if (some #{id} ids)\n                                   ;; If the id already exists we replace it in-place to maintain the ordering of\n                                   ;; controllers esp during hot-code reloading in development.\n                                   (-replace-controller controllers controller)\n                                   (conj controllers controller)))))))\n\n(defn path-for\n  \"Make a uri from route data. Useful for avoiding hard coded links in your app.\n\n  Parameters:\n\n  `handler`: The reitit handler from route data\n\n  `params`: Reitit route params for the requested route\n\n  Usage: `[:a {:href (k/path-for [:orders :sort-by :date]} \\\"Orders sorted by date\\\"]`\"\n  [handler & params]\n  (apply router/url handler params))\n\n(defn case-route\n  \"Reagent component that renders different components for different routes.\n\n  Semantics similar to clojure.core/case\n\n  You can include a single default component at the end that serves as the default view\n\n  Parameters:\n\n  `f`: A function that receives the route data on every route change, and returns the value to dispatch on.\n\n  `pairs`: A pair consists of the dispatch value and the reagent component to dispatch to. An optional single default\n  component can be added at the end.\n\n  Returns the first component with a matching dispatch value.\n\n  Usage:\n  ```\n  [k/switch-route (fn [route] (:handler route))\n    :index [:div \\\"This is index page\\\"]\n    :about [:div \\\"This is the about page\\\"]\n    [:div \\\"Probably also the index page\\\"]]\n  ```\"\n  [f & pairs]\n  (apply router/case-route f pairs))\n\n(defn switch-route\n  \"DEPRECATED in favor of case-route\n\n  Reagent component that renders different components for different routes.\n\n  You might need to include a case for `nil`, since there are no route data before the first navigation.\n\n  Parameters:\n\n  `f`: A function that receives the route data on every route change, and returns the value to dispatch on.\n\n  `pairs`: A pair consists of the dispatch value and the reagent component to dispatch to.\n\n  Returns the first component with a matching dispatch value.\n\n  Usage:\n  ```\n  [k/switch-route (fn [route] (:handler route))\n    :index [:div \\\"This is index page\\\"]\n    :about [:div \\\"This is the about page\\\"]\n    nil    [:div \\\"Probably also the index page\\\"]]\n  ```\"\n  [f & pairs]\n  (apply router/switch-route f pairs))\n"]}