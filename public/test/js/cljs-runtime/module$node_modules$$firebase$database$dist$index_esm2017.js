shadow$provide.module$node_modules$$firebase$database$dist$index_esm2017=function(global,require,module,exports){function each(obj,fn){for(const key in obj)obj.hasOwnProperty(key)&&fn(key,obj[key])}function repoInfoNeedsQueryParam(repoInfo){return repoInfo.host!==repoInfo.internalHost||repoInfo.isCustomHost()||repoInfo.includeNamespaceInQueryParams}function repoInfoConnectionURL(repoInfo,type,params){(0,_util.assert)("string"===typeof type,"typeof type must \x3d\x3d string");(0,_util.assert)("object"===
typeof params,"typeof params must \x3d\x3d object");if("websocket"===type)type=(repoInfo.secure?"wss://":"ws://")+repoInfo.internalHost+"/.ws?";else if("long_polling"===type)type=(repoInfo.secure?"https://":"http://")+repoInfo.internalHost+"/.lp?";else throw Error("Unknown connection type: "+type);repoInfoNeedsQueryParam(repoInfo)&&(params.ns=repoInfo.namespace);const pairs=[];each(params,(key,value)=>{pairs.push(key+"\x3d"+value)});return type+pairs.join("\x26")}function statsManagerGetCollection(repoInfo){repoInfo=
repoInfo.toString();collections[repoInfo]||(collections[repoInfo]=new StatsCollection);return collections[repoInfo]}function statsManagerGetOrCreateReporter(repoInfo,creatorFunction){repoInfo=repoInfo.toString();reporters[repoInfo]||(reporters[repoInfo]=creatorFunction());return reporters[repoInfo]}function newEmptyPath(){return new Path("")}function pathGetFront(path){return path.pieceNum_>=path.pieces_.length?null:path.pieces_[path.pieceNum_]}function pathGetLength(path){return path.pieces_.length-
path.pieceNum_}function pathPopFront(path){let pieceNum=path.pieceNum_;pieceNum<path.pieces_.length&&pieceNum++;return new Path(path.pieces_,pieceNum)}function pathGetBack(path){return path.pieceNum_<path.pieces_.length?path.pieces_[path.pieces_.length-1]:null}function pathSlice(path,begin=0){return path.pieces_.slice(path.pieceNum_+begin)}function pathParent(path){if(path.pieceNum_>=path.pieces_.length)return null;const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length-1;i++)pieces.push(path.pieces_[i]);
return new Path(pieces,0)}function pathChild(path,childPathObj){const pieces=[];for(let i=path.pieceNum_;i<path.pieces_.length;i++)pieces.push(path.pieces_[i]);if(childPathObj instanceof Path)for(path=childPathObj.pieceNum_;path<childPathObj.pieces_.length;path++)pieces.push(childPathObj.pieces_[path]);else for(childPathObj=childPathObj.split("/"),path=0;path<childPathObj.length;path++)0<childPathObj[path].length&&pieces.push(childPathObj[path]);return new Path(pieces,0)}function pathIsEmpty(path){return path.pieceNum_>=
path.pieces_.length}function newRelativePath(outerPath,innerPath){const outer=pathGetFront(outerPath),inner=pathGetFront(innerPath);if(null===outer)return innerPath;if(outer===inner)return newRelativePath(pathPopFront(outerPath),pathPopFront(innerPath));throw Error("INTERNAL ERROR: innerPath ("+innerPath+") is not within outerPath ("+outerPath+")");}function pathCompare(left,right){left=pathSlice(left,0);right=pathSlice(right,0);for(let i=0;i<left.length&&i<right.length;i++){const cmp=nameCompare(left[i],
right[i]);if(0!==cmp)return cmp}return left.length===right.length?0:left.length<right.length?-1:1}function pathEquals(path,other){if(pathGetLength(path)!==pathGetLength(other))return!1;for(let i=path.pieceNum_,j=other.pieceNum_;i<=path.pieces_.length;i++,j++)if(path.pieces_[i]!==other.pieces_[j])return!1;return!0}function pathContains(path,other){let i=path.pieceNum_,j=other.pieceNum_;if(pathGetLength(path)>pathGetLength(other))return!1;for(;i<path.pieces_.length;){if(path.pieces_[i]!==other.pieces_[j])return!1;
++i;++j}return!0}function validationPathCheckValid(validationPath){if(768<validationPath.byteLength_)throw Error(validationPath.errorPrefix_+"has a key path longer than 768 bytes ("+validationPath.byteLength_+").");if(32<validationPath.parts_.length)throw Error(validationPath.errorPrefix_+"path specified exceeds the maximum depth that can be written (32) or object contains a cycle "+validationPathToErrorString(validationPath));}function validationPathToErrorString(validationPath){return 0===validationPath.parts_.length?
"":"in property '"+validationPath.parts_.join(".")+"'"}function NAME_ONLY_COMPARATOR(left,right){return nameCompare(left.name,right.name)}function NAME_COMPARATOR(left,right){return nameCompare(left,right)}function nodeFromJSON(json,priority=null){if(null===json)return ChildrenNode.EMPTY_NODE;"object"===typeof json&&".priority"in json&&(priority=json[".priority"]);(0,_util.assert)(null===priority||"string"===typeof priority||"number"===typeof priority||"object"===typeof priority&&".sv"in priority,
"Invalid priority type found: "+typeof priority);"object"===typeof json&&".value"in json&&null!==json[".value"]&&(json=json[".value"]);if("object"!==typeof json||".sv"in json)return new LeafNode(json,nodeFromJSON(priority));if(json instanceof Array){let node=ChildrenNode.EMPTY_NODE;each(json,(key,childData)=>{(0,_util.contains)(json,key)&&"."!==key.substring(0,1)&&(childData=nodeFromJSON(childData),childData.isLeafNode()||!childData.isEmpty())&&(node=node.updateImmediateChild(key,childData))});return node.updatePriority(nodeFromJSON(priority))}const children=
[];let childrenHavePriority=!1;each(json,(key,child)=>{"."!==key.substring(0,1)&&(child=nodeFromJSON(child),child.isEmpty()||(childrenHavePriority=childrenHavePriority||!child.getPriority().isEmpty(),children.push(new NamedNode(key,child))))});if(0===children.length)return ChildrenNode.EMPTY_NODE;const childSet=buildChildSet(children,NAME_ONLY_COMPARATOR,namedNode=>namedNode.name,NAME_COMPARATOR);if(childrenHavePriority){const sortedChildSet=buildChildSet(children,PRIORITY_INDEX.getCompare());return new ChildrenNode(childSet,
nodeFromJSON(priority),new IndexMap({".priority":sortedChildSet},{".priority":PRIORITY_INDEX}))}return new ChildrenNode(childSet,nodeFromJSON(priority),IndexMap.Default)}function changeChildAdded(childName,snapshotNode){return{type:"child_added",snapshotNode,childName}}function changeChildRemoved(childName,snapshotNode){return{type:"child_removed",snapshotNode,childName}}function changeChildChanged(childName,snapshotNode,oldSnap){return{type:"child_changed",snapshotNode,childName,oldSnap}}function queryParamsStartAt(queryParams,
indexValue,key){queryParams=queryParams.copy();queryParams.startSet_=!0;void 0===indexValue&&(indexValue=null);queryParams.indexStartValue_=indexValue;null!=key?(queryParams.startNameSet_=!0,queryParams.indexStartName_=key):(queryParams.startNameSet_=!1,queryParams.indexStartName_="");return queryParams}function queryParamsEndAt(queryParams,indexValue,key){queryParams=queryParams.copy();queryParams.endSet_=!0;void 0===indexValue&&(indexValue=null);queryParams.indexEndValue_=indexValue;void 0!==key?
(queryParams.endNameSet_=!0,queryParams.indexEndName_=key):(queryParams.endNameSet_=!1,queryParams.indexEndName_="");return queryParams}function queryParamsOrderBy(queryParams,index){queryParams=queryParams.copy();queryParams.index_=index;return queryParams}function queryParamsToRestQueryStringParameters(queryParams){const qs={};if(queryParams.isDefault())return qs;let orderBy;queryParams.index_===PRIORITY_INDEX?orderBy="$priority":queryParams.index_===VALUE_INDEX?orderBy="$value":queryParams.index_===
KEY_INDEX?orderBy="$key":((0,_util.assert)(queryParams.index_ instanceof PathIndex,"Unrecognized index type!"),orderBy=queryParams.index_.toString());qs.orderBy=(0,_util.stringify)(orderBy);queryParams.startSet_&&(qs.startAt=(0,_util.stringify)(queryParams.indexStartValue_),queryParams.startNameSet_&&(qs.startAt+=","+(0,_util.stringify)(queryParams.indexStartName_)));queryParams.endSet_&&(qs.endAt=(0,_util.stringify)(queryParams.indexEndValue_),queryParams.endNameSet_&&(qs.endAt+=","+(0,_util.stringify)(queryParams.indexEndName_)));
queryParams.limitSet_&&(queryParams.isViewFromLeft()?qs.limitToFirst=queryParams.limit_:qs.limitToLast=queryParams.limit_);return qs}function queryParamsGetQueryObject(queryParams){const obj={};queryParams.startSet_&&(obj.sp=queryParams.indexStartValue_,queryParams.startNameSet_&&(obj.sn=queryParams.indexStartName_));queryParams.endSet_&&(obj.ep=queryParams.indexEndValue_,queryParams.endNameSet_&&(obj.en=queryParams.indexEndName_));if(queryParams.limitSet_){obj.l=queryParams.limit_;let viewFrom=queryParams.viewFrom_;
""===viewFrom&&(viewFrom=queryParams.isViewFromLeft()?"l":"r");obj.vf=viewFrom}queryParams.index_!==PRIORITY_INDEX&&(obj.i=queryParams.index_.toString());return obj}function newSparseSnapshotTree(){return{value:null,children:new Map}}function sparseSnapshotTreeRemember(sparseSnapshotTree,path,data){if(pathIsEmpty(path))sparseSnapshotTree.value=data,sparseSnapshotTree.children.clear();else if(null!==sparseSnapshotTree.value)sparseSnapshotTree.value=sparseSnapshotTree.value.updateChild(path,data);else{const childKey=
pathGetFront(path);sparseSnapshotTree.children.has(childKey)||sparseSnapshotTree.children.set(childKey,newSparseSnapshotTree());sparseSnapshotTree=sparseSnapshotTree.children.get(childKey);path=pathPopFront(path);sparseSnapshotTreeRemember(sparseSnapshotTree,path,data)}}function sparseSnapshotTreeForget(sparseSnapshotTree,path){if(pathIsEmpty(path))return sparseSnapshotTree.value=null,sparseSnapshotTree.children.clear(),!0;if(null!==sparseSnapshotTree.value){if(sparseSnapshotTree.value.isLeafNode())return!1;
var value=sparseSnapshotTree.value;sparseSnapshotTree.value=null;value.forEachChild(PRIORITY_INDEX,(key,tree)=>{sparseSnapshotTreeRemember(sparseSnapshotTree,new Path(key),tree)});return sparseSnapshotTreeForget(sparseSnapshotTree,path)}return 0<sparseSnapshotTree.children.size?(value=pathGetFront(path),path=pathPopFront(path),sparseSnapshotTree.children.has(value)&&sparseSnapshotTreeForget(sparseSnapshotTree.children.get(value),path)&&sparseSnapshotTree.children.delete(value),0===sparseSnapshotTree.children.size):
!0}function sparseSnapshotTreeForEachTree(sparseSnapshotTree,prefixPath,func){null!==sparseSnapshotTree.value?func(prefixPath,sparseSnapshotTree.value):sparseSnapshotTreeForEachChild(sparseSnapshotTree,(key,tree)=>{key=new Path(prefixPath.toString()+"/"+key);sparseSnapshotTreeForEachTree(tree,key,func)})}function sparseSnapshotTreeForEachChild(sparseSnapshotTree,func){sparseSnapshotTree.children.forEach((tree,key)=>{func(key,tree)})}function newOperationSourceUser(){return{fromUser:!0,fromServer:!1,
queryId:null,tagged:!1}}function newOperationSourceServer(){return{fromUser:!1,fromServer:!0,queryId:null,tagged:!1}}function newOperationSourceServerTaggedQuery(queryId){return{fromUser:!1,fromServer:!0,queryId,tagged:!0}}function eventGeneratorGenerateEventsForChanges(eventGenerator,changes,eventCache,eventRegistrations){const events=[],moves=[];changes.forEach(change=>{"child_changed"===change.type&&eventGenerator.index_.indexedValueChanged(change.oldSnap,change.snapshotNode)&&moves.push({type:"child_moved",
snapshotNode:change.snapshotNode,childName:change.childName})});eventGeneratorGenerateEventsForType(eventGenerator,events,"child_removed",changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_added",changes,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_moved",moves,eventRegistrations,eventCache);eventGeneratorGenerateEventsForType(eventGenerator,events,"child_changed",changes,eventRegistrations,eventCache);
eventGeneratorGenerateEventsForType(eventGenerator,events,"value",changes,eventRegistrations,eventCache);return events}function eventGeneratorGenerateEventsForType(eventGenerator,events,eventType,changes,registrations,eventCache){changes=changes.filter(change=>change.type===eventType);changes.sort((a,b)=>{if(null==a.childName||null==b.childName)throw(0,_util.assertionError)("Should only compare child_ events.");a=new NamedNode(a.childName,a.snapshotNode);b=new NamedNode(b.childName,b.snapshotNode);
return eventGenerator.index_.compare(a,b)});changes.forEach(change=>{const materializedChange=eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache);registrations.forEach(registration=>{registration.respondsTo(change.type)&&events.push(registration.createEvent(materializedChange,eventGenerator.query_))})})}function eventGeneratorMaterializeSingleChange(eventGenerator,change,eventCache){"value"!==change.type&&"child_removed"!==change.type&&(change.prevName=eventCache.getPredecessorChildName(change.childName,
change.snapshotNode,eventGenerator.index_));return change}function newViewCache(eventCache,serverCache){return{eventCache,serverCache}}function viewCacheUpdateEventSnap(viewCache,eventSnap,complete,filtered){return newViewCache(new CacheNode(eventSnap,complete,filtered),viewCache.serverCache)}function viewCacheGetCompleteEventSnap(viewCache){return viewCache.eventCache.isFullyInitialized()?viewCache.eventCache.getNode():null}function viewCacheGetCompleteServerSnap(viewCache){return viewCache.serverCache.isFullyInitialized()?
viewCache.serverCache.getNode():null}function compoundWriteAddWrite(compoundWrite,path,node){if(pathIsEmpty(path))return new CompoundWrite(new ImmutableTree(node));var rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);if(null!=rootmost){const rootMostPath=rootmost.path;rootmost=rootmost.value;path=newRelativePath(rootMostPath,path);rootmost=rootmost.updateChild(path,node);return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath,rootmost))}node=new ImmutableTree(node);compoundWrite=
compoundWrite.writeTree_.setTree(path,node);return new CompoundWrite(compoundWrite)}function compoundWriteAddWrites(compoundWrite,path,updates){let newWrite=compoundWrite;each(updates,(childKey,node)=>{newWrite=compoundWriteAddWrite(newWrite,pathChild(path,childKey),node)});return newWrite}function compoundWriteRemoveWrite(compoundWrite,path){if(pathIsEmpty(path))return CompoundWrite.empty();compoundWrite=compoundWrite.writeTree_.setTree(path,new ImmutableTree(null));return new CompoundWrite(compoundWrite)}
function compoundWriteHasCompleteWrite(compoundWrite,path){return null!=compoundWriteGetCompleteNode(compoundWrite,path)}function compoundWriteGetCompleteNode(compoundWrite,path){const rootmost=compoundWrite.writeTree_.findRootMostValueAndPath(path);return null!=rootmost?compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path,path)):null}function compoundWriteGetCompleteChildren(compoundWrite){const children=[],node=compoundWrite.writeTree_.value;null!=node?node.isLeafNode()||
node.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{children.push(new NamedNode(childName,childNode))}):compoundWrite.writeTree_.children.inorderTraversal((childName,childTree)=>{null!=childTree.value&&children.push(new NamedNode(childName,childTree.value))});return children}function compoundWriteChildCompoundWrite(compoundWrite,path){if(pathIsEmpty(path))return compoundWrite;const shadowingNode=compoundWriteGetCompleteNode(compoundWrite,path);return null!=shadowingNode?new CompoundWrite(new ImmutableTree(shadowingNode)):
new CompoundWrite(compoundWrite.writeTree_.subtree(path))}function compoundWriteApply(compoundWrite,node){return applySubtreeWrite(newEmptyPath(),compoundWrite.writeTree_,node)}function applySubtreeWrite(relativePath,writeTree,node){if(null!=writeTree.value)return node.updateChild(relativePath,writeTree.value);let priorityWrite=null;writeTree.children.inorderTraversal((childKey,childTree)=>{".priority"===childKey?((0,_util.assert)(null!==childTree.value,"Priority writes must always be leaf nodes"),
priorityWrite=childTree.value):node=applySubtreeWrite(pathChild(relativePath,childKey),childTree,node)});node.getChild(relativePath).isEmpty()||null===priorityWrite||(node=node.updateChild(pathChild(relativePath,".priority"),priorityWrite));return node}function writeTreeGetWrite(writeTree,writeId){for(let i=0;i<writeTree.allWrites.length;i++){const record=writeTree.allWrites[i];if(record.writeId===writeId)return record}return null}function writeTreeRemoveWrite(writeTree,writeId){const idx=writeTree.allWrites.findIndex(s=>
s.writeId===writeId);(0,_util.assert)(0<=idx,"removeWrite called with nonexistent writeId.");const writeToRemove=writeTree.allWrites[idx];writeTree.allWrites.splice(idx,1);let removedWriteWasVisible=writeToRemove.visible,removedWriteOverlapsWithOtherWrites=!1,i=writeTree.allWrites.length-1;for(;removedWriteWasVisible&&0<=i;){const currentWrite=writeTree.allWrites[i];currentWrite.visible&&(i>=idx&&writeTreeRecordContainsPath_(currentWrite,writeToRemove.path)?removedWriteWasVisible=!1:pathContains(writeToRemove.path,
currentWrite.path)&&(removedWriteOverlapsWithOtherWrites=!0));i--}return removedWriteWasVisible?(removedWriteOverlapsWithOtherWrites?writeTreeResetTree_(writeTree):writeToRemove.snap?writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,writeToRemove.path):each(writeToRemove.children,childName=>{writeTree.visibleWrites=compoundWriteRemoveWrite(writeTree.visibleWrites,pathChild(writeToRemove.path,childName))}),!0):!1}function writeTreeRecordContainsPath_(writeRecord,path){if(writeRecord.snap)return pathContains(writeRecord.path,
path);for(const childName in writeRecord.children)if(writeRecord.children.hasOwnProperty(childName)&&pathContains(pathChild(writeRecord.path,childName),path))return!0;return!1}function writeTreeResetTree_(writeTree){writeTree.visibleWrites=writeTreeLayerTree_(writeTree.allWrites,writeTreeDefaultFilter_,newEmptyPath());writeTree.lastWriteId=0<writeTree.allWrites.length?writeTree.allWrites[writeTree.allWrites.length-1].writeId:-1}function writeTreeDefaultFilter_(write){return write.visible}function writeTreeLayerTree_(writes,
filter,treeRoot){let compoundWrite=CompoundWrite.empty();for(let i=0;i<writes.length;++i){var write=writes[i];if(filter(write)){var writePath=write.path;if(write.snap)pathContains(treeRoot,writePath)?(writePath=newRelativePath(treeRoot,writePath),compoundWrite=compoundWriteAddWrite(compoundWrite,writePath,write.snap)):pathContains(writePath,treeRoot)&&(writePath=newRelativePath(writePath,treeRoot),compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),write.snap.getChild(writePath)));else if(write.children)if(pathContains(treeRoot,
writePath))writePath=newRelativePath(treeRoot,writePath),compoundWrite=compoundWriteAddWrites(compoundWrite,writePath,write.children);else{if(pathContains(writePath,treeRoot))if(writePath=newRelativePath(writePath,treeRoot),pathIsEmpty(writePath))compoundWrite=compoundWriteAddWrites(compoundWrite,newEmptyPath(),write.children);else if(write=(0,_util.safeGet)(write.children,pathGetFront(writePath)))write=write.getChild(pathPopFront(writePath)),compoundWrite=compoundWriteAddWrite(compoundWrite,newEmptyPath(),
write)}else throw(0,_util.assertionError)("WriteRecord should have .snap or .children");}}return compoundWrite}function writeTreeCalcCompleteEventCache(writeTree,treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites){if(writeIdsToExclude||includeHiddenWrites){var merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);return!includeHiddenWrites&&merge.writeTree_.isEmpty()?completeServerCache:includeHiddenWrites||null!=completeServerCache||compoundWriteHasCompleteWrite(merge,
newEmptyPath())?(writeTree=writeTreeLayerTree_(writeTree.allWrites,function(write){return(write.visible||includeHiddenWrites)&&(!writeIdsToExclude||!~writeIdsToExclude.indexOf(write.writeId))&&(pathContains(write.path,treePath)||pathContains(treePath,write.path))},treePath),compoundWriteApply(writeTree,completeServerCache||ChildrenNode.EMPTY_NODE)):null}merge=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(null!=merge)return merge;writeTree=compoundWriteChildCompoundWrite(writeTree.visibleWrites,
treePath);return writeTree.writeTree_.isEmpty()?completeServerCache:null!=completeServerCache||compoundWriteHasCompleteWrite(writeTree,newEmptyPath())?compoundWriteApply(writeTree,completeServerCache||ChildrenNode.EMPTY_NODE):null}function writeTreeCalcCompleteEventChildren(writeTree,treePath,completeServerChildren){let completeChildren=ChildrenNode.EMPTY_NODE;const topLevelSet=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);if(topLevelSet)topLevelSet.isLeafNode()||topLevelSet.forEachChild(PRIORITY_INDEX,
(childName,childSnap)=>{completeChildren=completeChildren.updateImmediateChild(childName,childSnap)});else if(completeServerChildren){const merge=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);completeServerChildren.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{childNode=compoundWriteApply(compoundWriteChildCompoundWrite(merge,new Path(childName)),childNode);completeChildren=completeChildren.updateImmediateChild(childName,childNode)});compoundWriteGetCompleteChildren(merge).forEach(namedNode=>
{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node)})}else writeTree=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath),compoundWriteGetCompleteChildren(writeTree).forEach(namedNode=>{completeChildren=completeChildren.updateImmediateChild(namedNode.name,namedNode.node)});return completeChildren}function writeTreeCalcEventCacheAfterServerOverwrite(writeTree,treePath,childPath,existingEventSnap,existingServerSnap){(0,_util.assert)(existingEventSnap||
existingServerSnap,"Either existingEventSnap or existingServerSnap must exist");treePath=pathChild(treePath,childPath);if(compoundWriteHasCompleteWrite(writeTree.visibleWrites,treePath))return null;writeTree=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath);return writeTree.writeTree_.isEmpty()?existingServerSnap.getChild(childPath):compoundWriteApply(writeTree,existingServerSnap.getChild(childPath))}function writeTreeCalcCompleteChild(writeTree,treePath,childKey,existingServerSnap){treePath=
pathChild(treePath,childKey);const shadowingNode=compoundWriteGetCompleteNode(writeTree.visibleWrites,treePath);return null!=shadowingNode?shadowingNode:existingServerSnap.isCompleteForChild(childKey)?(writeTree=compoundWriteChildCompoundWrite(writeTree.visibleWrites,treePath),compoundWriteApply(writeTree,existingServerSnap.getNode().getImmediateChild(childKey))):null}function writeTreeRefCalcCompleteEventCache(writeTreeRef,completeServerCache,writeIdsToExclude,includeHiddenWrites){return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree,
writeTreeRef.treePath,completeServerCache,writeIdsToExclude,includeHiddenWrites)}function writeTreeRefShadowingWrite(writeTreeRef,path){path=pathChild(writeTreeRef.treePath,path);return compoundWriteGetCompleteNode(writeTreeRef.writeTree.visibleWrites,path)}function writeTreeRefChild(writeTreeRef,childName){return newWriteTreeRef(pathChild(writeTreeRef.treePath,childName),writeTreeRef.writeTree)}function newWriteTreeRef(path,writeTree){return{treePath:path,writeTree}}function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,
viewCache,changePath,writesCache,source,accumulator){const oldEventSnap=viewCache.eventCache;if(null!=writeTreeRefShadowingWrite(writesCache,changePath))return viewCache;let serverNode;if(pathIsEmpty(changePath))(0,_util.assert)(viewCache.serverCache.isFullyInitialized(),"If change path is empty, we must have complete server data"),viewCache.serverCache.isFiltered()?(source=viewCacheGetCompleteServerSnap(viewCache),writesCache=writeTreeCalcCompleteEventChildren(writesCache.writeTree,writesCache.treePath,
source instanceof ChildrenNode?source:ChildrenNode.EMPTY_NODE),accumulator=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),writesCache,accumulator)):(writesCache=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(viewCache)),accumulator=viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(),writesCache,accumulator));else{const childKey=pathGetFront(changePath);if(".priority"===childKey)(0,_util.assert)(1===pathGetLength(changePath),"Can't have a priority with additional path components"),
accumulator=oldEventSnap.getNode(),serverNode=viewCache.serverCache.getNode(),writesCache=writeTreeCalcEventCacheAfterServerOverwrite(writesCache.writeTree,writesCache.treePath,changePath,accumulator,serverNode),accumulator=null!=writesCache?viewProcessor.filter.updatePriority(accumulator,writesCache):oldEventSnap.getNode();else{const childChangePath=pathPopFront(changePath);if(oldEventSnap.isCompleteForChild(childKey)){serverNode=viewCache.serverCache.getNode();var existingEventSnap=oldEventSnap.getNode();
writesCache=writeTreeCalcEventCacheAfterServerOverwrite(writesCache.writeTree,writesCache.treePath,changePath,existingEventSnap,serverNode);writesCache=null!=writesCache?oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,writesCache):oldEventSnap.getNode().getImmediateChild(childKey)}else writesCache=writeTreeCalcCompleteChild(writesCache.writeTree,writesCache.treePath,childKey,viewCache.serverCache);accumulator=null!=writesCache?viewProcessor.filter.updateChild(oldEventSnap.getNode(),
childKey,writesCache,childChangePath,source,accumulator):oldEventSnap.getNode()}}return viewCacheUpdateEventSnap(viewCache,accumulator,oldEventSnap.isFullyInitialized()||pathIsEmpty(changePath),viewProcessor.filter.filtersNodes())}function viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,filterServerNode,accumulator){var oldServerSnap=oldViewCache.serverCache;filterServerNode=filterServerNode?viewProcessor.filter:viewProcessor.filter.getIndexedFilter();
if(pathIsEmpty(changePath))changedSnap=filterServerNode.updateFullNode(oldServerSnap.getNode(),changedSnap,null);else if(filterServerNode.filtersNodes()&&!oldServerSnap.isFiltered())changedSnap=oldServerSnap.getNode().updateChild(changePath,changedSnap),changedSnap=filterServerNode.updateFullNode(oldServerSnap.getNode(),changedSnap,null);else{const childKey=pathGetFront(changePath);if(!oldServerSnap.isCompleteForPath(changePath)&&1<pathGetLength(changePath))return oldViewCache;const childChangePath=
pathPopFront(changePath);changedSnap=oldServerSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath,changedSnap);changedSnap=".priority"===childKey?filterServerNode.updatePriority(oldServerSnap.getNode(),changedSnap):filterServerNode.updateChild(oldServerSnap.getNode(),childKey,changedSnap,childChangePath,NO_COMPLETE_CHILD_SOURCE,null)}oldServerSnap=oldServerSnap.isFullyInitialized()||pathIsEmpty(changePath);filterServerNode=filterServerNode.filtersNodes();oldViewCache=newViewCache(oldViewCache.eventCache,
new CacheNode(changedSnap,oldServerSnap,filterServerNode));completeCache=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeCache);return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,oldViewCache,changePath,writesCache,completeCache,accumulator)}function viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,changePath,changedSnap,writesCache,completeCache,accumulator){const oldEventSnap=oldViewCache.eventCache;writesCache=new WriteTreeCompleteChildSource(writesCache,
oldViewCache,completeCache);if(pathIsEmpty(changePath))accumulator=viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(),changedSnap,accumulator),viewProcessor=viewCacheUpdateEventSnap(oldViewCache,accumulator,!0,viewProcessor.filter.filtersNodes());else if(completeCache=pathGetFront(changePath),".priority"===completeCache)accumulator=viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(),changedSnap),viewProcessor=viewCacheUpdateEventSnap(oldViewCache,accumulator,oldEventSnap.isFullyInitialized(),
oldEventSnap.isFiltered());else{changePath=pathPopFront(changePath);const oldChild=oldEventSnap.getNode().getImmediateChild(completeCache);if(!pathIsEmpty(changePath)){const childNode=writesCache.getCompleteChild(completeCache);changedSnap=null!=childNode?".priority"===pathGetBack(changePath)&&childNode.getChild(pathParent(changePath)).isEmpty()?childNode:childNode.updateChild(changePath,changedSnap):ChildrenNode.EMPTY_NODE}oldChild.equals(changedSnap)?viewProcessor=oldViewCache:(accumulator=viewProcessor.filter.updateChild(oldEventSnap.getNode(),
completeCache,changedSnap,changePath,writesCache,accumulator),viewProcessor=viewCacheUpdateEventSnap(oldViewCache,accumulator,oldEventSnap.isFullyInitialized(),viewProcessor.filter.filtersNodes()))}return viewProcessor}function viewProcessorApplyUserMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,accumulator){let curViewCache=viewCache;changedChildren.foreach((relativePath,childNode)=>{relativePath=pathChild(path,relativePath);var childKey=pathGetFront(relativePath);viewCache.eventCache.isCompleteForChild(childKey)&&
(curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,relativePath,childNode,writesCache,serverCache,accumulator))});changedChildren.foreach((relativePath,childNode)=>{relativePath=pathChild(path,relativePath);var childKey=pathGetFront(relativePath);viewCache.eventCache.isCompleteForChild(childKey)||(curViewCache=viewProcessorApplyUserOverwrite(viewProcessor,curViewCache,relativePath,childNode,writesCache,serverCache,accumulator))});return curViewCache}function viewProcessorApplyMerge(viewProcessor,
node,merge){merge.foreach((relativePath,childNode)=>{node=node.updateChild(relativePath,childNode)});return node}function viewProcessorApplyServerMerge(viewProcessor,viewCache,path,changedChildren,writesCache,serverCache,filterServerNode,accumulator){if(viewCache.serverCache.getNode().isEmpty()&&!viewCache.serverCache.isFullyInitialized())return viewCache;let curViewCache=viewCache;path=pathIsEmpty(path)?changedChildren:(new ImmutableTree(null)).setTree(path,changedChildren);const serverNode=viewCache.serverCache.getNode();
path.children.inorderTraversal((childKey,childTree)=>{if(serverNode.hasChild(childKey)){const serverChild=viewCache.serverCache.getNode().getImmediateChild(childKey);childTree=viewProcessorApplyMerge(viewProcessor,serverChild,childTree);curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),childTree,writesCache,serverCache,filterServerNode,accumulator)}});path.children.inorderTraversal((childKey,childMergeTree)=>{var isUnknownDeepMerge=!viewCache.serverCache.isCompleteForChild(childKey)&&
void 0===childMergeTree.value;serverNode.hasChild(childKey)||isUnknownDeepMerge||(isUnknownDeepMerge=viewCache.serverCache.getNode().getImmediateChild(childKey),childMergeTree=viewProcessorApplyMerge(viewProcessor,isUnknownDeepMerge,childMergeTree),curViewCache=viewProcessorApplyServerOverwrite(viewProcessor,curViewCache,new Path(childKey),childMergeTree,writesCache,serverCache,filterServerNode,accumulator))});return curViewCache}function viewProcessorAckUserWrite(viewProcessor,viewCache,ackPath,
affectedTree,writesCache,completeCache,accumulator){if(null!=writeTreeRefShadowingWrite(writesCache,ackPath))return viewCache;const filterServerNode=viewCache.serverCache.isFiltered(),serverCache=viewCache.serverCache;if(null!=affectedTree.value){if(pathIsEmpty(ackPath)&&serverCache.isFullyInitialized()||serverCache.isCompleteForPath(ackPath))return viewProcessorApplyServerOverwrite(viewProcessor,viewCache,ackPath,serverCache.getNode().getChild(ackPath),writesCache,completeCache,filterServerNode,
accumulator);if(pathIsEmpty(ackPath)){let changedChildren=new ImmutableTree(null);serverCache.getNode().forEachChild(KEY_INDEX,(name,node)=>{changedChildren=changedChildren.set(new Path(name),node)});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren,writesCache,completeCache,filterServerNode,accumulator)}return viewCache}let changedChildren$jscomp$0=new ImmutableTree(null);affectedTree.foreach((mergePath,value)=>{value=pathChild(ackPath,mergePath);serverCache.isCompleteForPath(value)&&
(changedChildren$jscomp$0=changedChildren$jscomp$0.set(mergePath,serverCache.getNode().getChild(value)))});return viewProcessorApplyServerMerge(viewProcessor,viewCache,ackPath,changedChildren$jscomp$0,writesCache,completeCache,filterServerNode,accumulator)}function viewRemoveEventRegistration(view,eventRegistration,cancelError){const cancelEvents=[];if(cancelError){(0,_util.assert)(null==eventRegistration,"A cancel should cancel all event registrations.");const path=view.query._path;view.eventRegistrations_.forEach(registration=>
{(registration=registration.createCancelEvent(cancelError,path))&&cancelEvents.push(registration)})}if(eventRegistration){let remaining=[];for(let i=0;i<view.eventRegistrations_.length;++i){const existing=view.eventRegistrations_[i];if(!existing.matches(eventRegistration))remaining.push(existing);else if(eventRegistration.hasAnyCallback()){remaining=remaining.concat(view.eventRegistrations_.slice(i+1));break}}view.eventRegistrations_=remaining}else view.eventRegistrations_=[];return cancelEvents}
function viewApplyOperation(view,operation,writesCache,completeServerCache){operation.type===OperationType.MERGE&&null!==operation.source.queryId&&((0,_util.assert)(viewCacheGetCompleteServerSnap(view.viewCache_),"We should always have a full cache before handling merges"),(0,_util.assert)(viewCacheGetCompleteEventSnap(view.viewCache_),"Missing event cache, even though we have a server cache"));const oldViewCache=view.viewCache_;var viewProcessor=view.processor_,accumulator=new ChildChangeAccumulator;
if(operation.type===OperationType.OVERWRITE)if(operation.source.fromUser)writesCache=viewProcessorApplyUserOverwrite(viewProcessor,oldViewCache,operation.path,operation.snap,writesCache,completeServerCache,accumulator);else{(0,_util.assert)(operation.source.fromServer,"Unknown source.");var filterServerNode=operation.source.tagged||oldViewCache.serverCache.isFiltered()&&!pathIsEmpty(operation.path);writesCache=viewProcessorApplyServerOverwrite(viewProcessor,oldViewCache,operation.path,operation.snap,
writesCache,completeServerCache,filterServerNode,accumulator)}else if(operation.type===OperationType.MERGE)operation.source.fromUser?writesCache=viewProcessorApplyUserMerge(viewProcessor,oldViewCache,operation.path,operation.children,writesCache,completeServerCache,accumulator):((0,_util.assert)(operation.source.fromServer,"Unknown source."),filterServerNode=operation.source.tagged||oldViewCache.serverCache.isFiltered(),writesCache=viewProcessorApplyServerMerge(viewProcessor,oldViewCache,operation.path,
operation.children,writesCache,completeServerCache,filterServerNode,accumulator));else if(operation.type===OperationType.ACK_USER_WRITE)if(operation.revert)if(operation=operation.path,null!=writeTreeRefShadowingWrite(writesCache,operation))writesCache=oldViewCache;else{filterServerNode=new WriteTreeCompleteChildSource(writesCache,oldViewCache,completeServerCache);completeServerCache=oldViewCache.eventCache.getNode();if(pathIsEmpty(operation)||".priority"===pathGetFront(operation))oldViewCache.serverCache.isFullyInitialized()?
operation=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(oldViewCache)):(operation=oldViewCache.serverCache.getNode(),(0,_util.assert)(operation instanceof ChildrenNode,"serverChildren would be complete if leaf node"),operation=writeTreeCalcCompleteEventChildren(writesCache.writeTree,writesCache.treePath,operation)),completeServerCache=viewProcessor.filter.updateFullNode(completeServerCache,operation,accumulator);else{var childKey=pathGetFront(operation);let newChild=
writeTreeCalcCompleteChild(writesCache.writeTree,writesCache.treePath,childKey,oldViewCache.serverCache);null==newChild&&oldViewCache.serverCache.isCompleteForChild(childKey)&&(newChild=completeServerCache.getImmediateChild(childKey));completeServerCache=null!=newChild?viewProcessor.filter.updateChild(completeServerCache,childKey,newChild,pathPopFront(operation),filterServerNode,accumulator):oldViewCache.eventCache.getNode().hasChild(childKey)?viewProcessor.filter.updateChild(completeServerCache,
childKey,ChildrenNode.EMPTY_NODE,pathPopFront(operation),filterServerNode,accumulator):completeServerCache;completeServerCache.isEmpty()&&oldViewCache.serverCache.isFullyInitialized()&&(operation=writeTreeRefCalcCompleteEventCache(writesCache,viewCacheGetCompleteServerSnap(oldViewCache)),operation.isLeafNode()&&(completeServerCache=viewProcessor.filter.updateFullNode(completeServerCache,operation,accumulator)))}operation=oldViewCache.serverCache.isFullyInitialized()||null!=writeTreeRefShadowingWrite(writesCache,
newEmptyPath());writesCache=viewCacheUpdateEventSnap(oldViewCache,completeServerCache,operation,viewProcessor.filter.filtersNodes())}else writesCache=viewProcessorAckUserWrite(viewProcessor,oldViewCache,operation.path,operation.affectedTree,writesCache,completeServerCache,accumulator);else if(operation.type===OperationType.LISTEN_COMPLETE)completeServerCache=operation.path,childKey=oldViewCache.serverCache,operation=childKey.getNode(),filterServerNode=childKey.isFullyInitialized()||pathIsEmpty(completeServerCache),
childKey=childKey.isFiltered(),operation=newViewCache(oldViewCache.eventCache,new CacheNode(operation,filterServerNode,childKey)),writesCache=viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor,operation,completeServerCache,writesCache,NO_COMPLETE_CHILD_SOURCE,accumulator);else throw(0,_util.assertionError)("Unknown operation type: "+operation.type);accumulator=accumulator.getChanges();viewProcessor=writesCache;completeServerCache=viewProcessor.eventCache;completeServerCache.isFullyInitialized()&&
(operation=completeServerCache.getNode().isLeafNode()||completeServerCache.getNode().isEmpty(),filterServerNode=viewCacheGetCompleteEventSnap(oldViewCache),(0<accumulator.length||!oldViewCache.eventCache.isFullyInitialized()||operation&&!completeServerCache.getNode().equals(filterServerNode)||!completeServerCache.getNode().getPriority().equals(filterServerNode.getPriority()))&&accumulator.push({type:"value",snapshotNode:viewCacheGetCompleteEventSnap(viewProcessor)}));viewProcessor=view.processor_;
(0,_util.assert)(writesCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()),"Event snap not indexed");(0,_util.assert)(writesCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()),"Server snap not indexed");(0,_util.assert)(writesCache.serverCache.isFullyInitialized()||!oldViewCache.serverCache.isFullyInitialized(),"Once a server snap is complete, it should never go back");view.viewCache_=writesCache;return viewGenerateEventsForChanges_(view,accumulator,writesCache.eventCache.getNode(),
null)}function viewGetInitialEvents(view,registration){const eventSnap=view.viewCache_.eventCache,initialChanges=[];eventSnap.getNode().isLeafNode()||eventSnap.getNode().forEachChild(PRIORITY_INDEX,(key,childNode)=>{initialChanges.push(changeChildAdded(key,childNode))});eventSnap.isFullyInitialized()&&initialChanges.push({type:"value",snapshotNode:eventSnap.getNode()});return viewGenerateEventsForChanges_(view,initialChanges,eventSnap.getNode(),registration)}function viewGenerateEventsForChanges_(view,
changes,eventCache,eventRegistration){return eventGeneratorGenerateEventsForChanges(view.eventGenerator_,changes,eventCache,eventRegistration?[eventRegistration]:view.eventRegistrations_)}function syncPointApplyOperation(syncPoint,operation,writesCache,optCompleteServerCache){var queryId=operation.source.queryId;if(null!==queryId)return syncPoint=syncPoint.views.get(queryId),(0,_util.assert)(null!=syncPoint,"SyncTree gave us an op for an invalid query."),viewApplyOperation(syncPoint,operation,writesCache,
optCompleteServerCache);queryId=[];for(const view of syncPoint.views.values())queryId=queryId.concat(viewApplyOperation(view,operation,writesCache,optCompleteServerCache));return queryId}function syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete){syncPoint=syncPoint.views.get(query._queryIdentifier);return syncPoint?syncPoint:((syncPoint=writeTreeRefCalcCompleteEventCache(writesCache,serverCacheComplete?serverCache:null))?writesCache=!0:(syncPoint=serverCache instanceof
ChildrenNode?writeTreeCalcCompleteEventChildren(writesCache.writeTree,writesCache.treePath,serverCache):ChildrenNode.EMPTY_NODE,writesCache=!1),serverCache=newViewCache(new CacheNode(syncPoint,writesCache,!1),new CacheNode(serverCache,serverCacheComplete,!1)),new View(query,serverCache))}function syncPointAddEventRegistration(syncPoint,query,eventRegistration,writesCache,serverCache,serverCacheComplete){writesCache=syncPointGetView(syncPoint,query,writesCache,serverCache,serverCacheComplete);syncPoint.views.has(query._queryIdentifier)||
syncPoint.views.set(query._queryIdentifier,writesCache);writesCache.eventRegistrations_.push(eventRegistration);return viewGetInitialEvents(writesCache,eventRegistration)}function syncPointRemoveEventRegistration(syncPoint,query,eventRegistration,cancelError){const queryId=query._queryIdentifier,removed=[];let cancelEvents=[];const hadCompleteView=null!=syncPointGetCompleteView(syncPoint);if("default"===queryId)for(const [viewQueryId,view]of syncPoint.views.entries())cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,
eventRegistration,cancelError)),0===view.eventRegistrations_.length&&(syncPoint.views.delete(viewQueryId),view.query._queryParams.loadsAllData()||removed.push(view.query));else{const view=syncPoint.views.get(queryId);view&&(cancelEvents=cancelEvents.concat(viewRemoveEventRegistration(view,eventRegistration,cancelError)),0===view.eventRegistrations_.length&&(syncPoint.views.delete(queryId),view.query._queryParams.loadsAllData()||removed.push(view.query)))}hadCompleteView&&null==syncPointGetCompleteView(syncPoint)&&
(syncPoint=removed.push,(0,_util.assert)(referenceConstructor$1,"Reference.ts has not been loaded"),syncPoint.call(removed,new referenceConstructor$1(query._repo,query._path)));return{removed,events:cancelEvents}}function syncPointGetQueryViews(syncPoint){const result=[];for(const view of syncPoint.views.values())view.query._queryParams.loadsAllData()||result.push(view);return result}function syncPointGetCompleteServerCache(syncPoint,path){var serverCache=null;for(const view of syncPoint.views.values()){if(!(syncPoint=
serverCache)){{syncPoint=view;serverCache=path;const cache=viewCacheGetCompleteServerSnap(syncPoint.viewCache_);syncPoint=cache&&(syncPoint.query._queryParams.loadsAllData()||!pathIsEmpty(serverCache)&&!cache.getImmediateChild(pathGetFront(serverCache)).isEmpty())?cache.getChild(serverCache):null}}serverCache=syncPoint}return serverCache}function syncPointViewForQuery(syncPoint,query){return query._queryParams.loadsAllData()?syncPointGetCompleteView(syncPoint):syncPoint.views.get(query._queryIdentifier)}
function syncPointGetCompleteView(syncPoint){for(const view of syncPoint.views.values())if(view.query._queryParams.loadsAllData())return view;return null}function syncTreeApplyUserOverwrite(syncTree,path,newData,writeId,visible$jscomp$0){var writeTree=syncTree.pendingWriteTree_,visible=visible$jscomp$0;(0,_util.assert)(writeId>writeTree.lastWriteId,"Stacking an older write on top of newer ones");void 0===visible&&(visible=!0);writeTree.allWrites.push({path,snap:newData,writeId,visible});visible&&
(writeTree.visibleWrites=compoundWriteAddWrite(writeTree.visibleWrites,path,newData));writeTree.lastWriteId=writeId;return visible$jscomp$0?syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceUser(),path,newData)):[]}function syncTreeApplyUserMerge(syncTree,path,changedChildren,writeId){var writeTree=syncTree.pendingWriteTree_;(0,_util.assert)(writeId>writeTree.lastWriteId,"Stacking an older merge on top of newer ones");writeTree.allWrites.push({path,children:changedChildren,
writeId,visible:!0});writeTree.visibleWrites=compoundWriteAddWrites(writeTree.visibleWrites,path,changedChildren);writeTree.lastWriteId=writeId;changedChildren=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceUser(),path,changedChildren))}function syncTreeAckUserWrite(syncTree,writeId,revert=!1){const write=writeTreeGetWrite(syncTree.pendingWriteTree_,writeId);if(writeTreeRemoveWrite(syncTree.pendingWriteTree_,writeId)){let affectedTree=
new ImmutableTree(null);null!=write.snap?affectedTree=affectedTree.set(newEmptyPath(),!0):each(write.children,pathString=>{affectedTree=affectedTree.set(new Path(pathString),!0)});return syncTreeApplyOperationToSyncPoints_(syncTree,new AckUserWrite(write.path,affectedTree,revert))}return[]}function syncTreeApplyServerOverwrite(syncTree,path,newData){return syncTreeApplyOperationToSyncPoints_(syncTree,new Overwrite(newOperationSourceServer(),path,newData))}function syncTreeApplyServerMerge(syncTree,
path,changedChildren){changedChildren=ImmutableTree.fromObject(changedChildren);return syncTreeApplyOperationToSyncPoints_(syncTree,new Merge(newOperationSourceServer(),path,changedChildren))}function syncTreeRemoveEventRegistration(syncTree,query$jscomp$0,eventRegistration,cancelError){var path=query$jscomp$0._path,maybeSyncPoint=syncTree.syncPointTree_.get(path),cancelEvents=[];if(maybeSyncPoint&&("default"===query$jscomp$0._queryIdentifier||null!=syncPointViewForQuery(maybeSyncPoint,query$jscomp$0))){cancelEvents=
syncPointRemoveEventRegistration(maybeSyncPoint,query$jscomp$0,eventRegistration,cancelError);0===maybeSyncPoint.views.size&&(syncTree.syncPointTree_=syncTree.syncPointTree_.remove(path));maybeSyncPoint=cancelEvents.removed;cancelEvents=cancelEvents.events;eventRegistration=-1!==maybeSyncPoint.findIndex(query=>query._queryParams.loadsAllData());const covered=syncTree.syncPointTree_.findOnPath(path,(relativePath,parentSyncPoint)=>null!=syncPointGetCompleteView(parentSyncPoint));if(eventRegistration&&
!covered&&(path=syncTree.syncPointTree_.subtree(path),!path.isEmpty())){path=syncTreeCollectDistinctViewsForSubTree_(path);for(let i=0;i<path.length;++i){var view=path[i];const newQuery=view.query;view=syncTreeCreateListenerForView_(syncTree,view);syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery),syncTreeTagForQuery_(syncTree,newQuery),view.hashFn,view.onComplete)}}!covered&&0<maybeSyncPoint.length&&!cancelError&&(eventRegistration?syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query$jscomp$0),
null):maybeSyncPoint.forEach(queryToRemove=>{const tagToRemove=syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove),tagToRemove)}));syncTreeRemoveTags_(syncTree,maybeSyncPoint)}return cancelEvents}function syncTreeApplyTaggedQueryOverwrite(syncTree,path,snap,tag){tag=syncTree.tagToQueryMap.get(tag);if(null!=tag){var r=syncTreeParseQueryKey_(tag);tag=r.path;r=r.queryId;path=newRelativePath(tag,path);snap=new Overwrite(newOperationSourceServerTaggedQuery(r),
path,snap);return syncTreeApplyTaggedOperation_(syncTree,tag,snap)}return[]}function syncTreeApplyTaggedQueryMerge(syncTree,path,changedChildren,tag){if(tag=syncTree.tagToQueryMap.get(tag)){var r=syncTreeParseQueryKey_(tag);tag=r.path;r=r.queryId;path=newRelativePath(tag,path);changedChildren=ImmutableTree.fromObject(changedChildren);changedChildren=new Merge(newOperationSourceServerTaggedQuery(r),path,changedChildren);return syncTreeApplyTaggedOperation_(syncTree,tag,changedChildren)}return[]}function syncTreeAddEventRegistration(syncTree,
query,eventRegistration){const path=query._path;let serverCache=null,foundAncestorDefaultView=!1;syncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{pathToSyncPoint=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,pathToSyncPoint);foundAncestorDefaultView=foundAncestorDefaultView||null!=syncPointGetCompleteView(sp)});var syncPoint=syncTree.syncPointTree_.get(path);syncPoint?(foundAncestorDefaultView=foundAncestorDefaultView||null!=syncPointGetCompleteView(syncPoint),
serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath())):(syncPoint=new SyncPoint,syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint));let serverCacheComplete;null!=serverCache?serverCacheComplete=!0:(serverCacheComplete=!1,serverCache=ChildrenNode.EMPTY_NODE,syncTree.syncPointTree_.subtree(path).foreachChild((childName,childSyncPoint)=>{(childSyncPoint=syncPointGetCompleteServerCache(childSyncPoint,newEmptyPath()))&&(serverCache=serverCache.updateImmediateChild(childName,
childSyncPoint))}));const viewAlreadyExists=null!=syncPointViewForQuery(syncPoint,query);if(!viewAlreadyExists&&!query._queryParams.loadsAllData()){var queryKey=syncTreeMakeQueryKey_(query);(0,_util.assert)(!syncTree.queryToTagMap.has(queryKey),"View does not exist, but we have a tag");const tag=syncTreeNextQueryTag_++;syncTree.queryToTagMap.set(queryKey,tag);syncTree.tagToQueryMap.set(tag,queryKey)}queryKey=newWriteTreeRef(path,syncTree.pendingWriteTree_);eventRegistration=syncPointAddEventRegistration(syncPoint,
query,eventRegistration,queryKey,serverCache,serverCacheComplete);viewAlreadyExists||foundAncestorDefaultView||(syncPoint=syncPointViewForQuery(syncPoint,query),eventRegistration=eventRegistration.concat(syncTreeSetupListener_(syncTree,query,syncPoint)));return eventRegistration}function syncTreeCalcCompleteEventCache(syncTree,path,writeIdsToExclude){const writeTree=syncTree.pendingWriteTree_;syncTree=syncTree.syncPointTree_.findOnPath(path,(pathSoFar,syncPoint)=>{pathSoFar=newRelativePath(pathSoFar,
path);if(syncPoint=syncPointGetCompleteServerCache(syncPoint,pathSoFar))return syncPoint});return writeTreeCalcCompleteEventCache(writeTree,path,syncTree,writeIdsToExclude,!0)}function syncTreeGetServerValue(syncTree,query){const path=query._path;let serverCache=null;syncTree.syncPointTree_.foreachOnPath(path,(pathToSyncPoint,sp)=>{pathToSyncPoint=newRelativePath(pathToSyncPoint,path);serverCache=serverCache||syncPointGetCompleteServerCache(sp,pathToSyncPoint)});let syncPoint=syncTree.syncPointTree_.get(path);
syncPoint?serverCache=serverCache||syncPointGetCompleteServerCache(syncPoint,newEmptyPath()):(syncPoint=new SyncPoint,syncTree.syncPointTree_=syncTree.syncPointTree_.set(path,syncPoint));const serverCacheComplete=null!=serverCache,serverCacheNode=serverCacheComplete?new CacheNode(serverCache,!0,!1):null;syncTree=newWriteTreeRef(query._path,syncTree.pendingWriteTree_);query=syncPointGetView(syncPoint,query,syncTree,serverCacheComplete?serverCacheNode.getNode():ChildrenNode.EMPTY_NODE,serverCacheComplete);
return viewCacheGetCompleteEventSnap(query.viewCache_)}function syncTreeApplyOperationToSyncPoints_(syncTree,operation){var JSCompiler_temp_const=syncTreeApplyOperationHelper_,JSCompiler_temp_const$jscomp$0=syncTree.syncPointTree_,path=newEmptyPath();syncTree=newWriteTreeRef(path,syncTree.pendingWriteTree_);return JSCompiler_temp_const(operation,JSCompiler_temp_const$jscomp$0,null,syncTree)}function syncTreeApplyOperationHelper_(operation,syncPointTree,serverCache,writesCache){if(pathIsEmpty(operation.path))return syncTreeApplyOperationDescendantsHelper_(operation,
syncPointTree,serverCache,writesCache);const syncPoint=syncPointTree.get(newEmptyPath());null==serverCache&&null!=syncPoint&&(serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath()));let events=[];var childName=pathGetFront(operation.path);const childOperation=operation.operationForChild(childName);if((syncPointTree=syncPointTree.children.get(childName))&&childOperation){const childServerCache=serverCache?serverCache.getImmediateChild(childName):null;childName=writeTreeRefChild(writesCache,
childName);events=events.concat(syncTreeApplyOperationHelper_(childOperation,syncPointTree,childServerCache,childName))}syncPoint&&(events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache)));return events}function syncTreeApplyOperationDescendantsHelper_(operation,syncPointTree,serverCache,writesCache){const syncPoint=syncPointTree.get(newEmptyPath());null==serverCache&&null!=syncPoint&&(serverCache=syncPointGetCompleteServerCache(syncPoint,newEmptyPath()));let events=
[];syncPointTree.children.inorderTraversal((childName,childTree)=>{const childServerCache=serverCache?serverCache.getImmediateChild(childName):null,childWritesCache=writeTreeRefChild(writesCache,childName);(childName=operation.operationForChild(childName))&&(events=events.concat(syncTreeApplyOperationDescendantsHelper_(childName,childTree,childServerCache,childWritesCache)))});syncPoint&&(events=events.concat(syncPointApplyOperation(syncPoint,operation,writesCache,serverCache)));return events}function syncTreeCreateListenerForView_(syncTree,
view){const query=view.query,tag=syncTreeTagForQuery_(syncTree,query);return{hashFn:()=>(view.viewCache_.serverCache.getNode()||ChildrenNode.EMPTY_NODE).hash(),onComplete:status=>{if("ok"===status){if(tag){var path=query._path;if(status=syncTree.tagToQueryMap.get(tag)){var r=syncTreeParseQueryKey_(status);status=r.path;r=r.queryId;path=newRelativePath(status,path);path=new ListenComplete(newOperationSourceServerTaggedQuery(r),path);status=syncTreeApplyTaggedOperation_(syncTree,status,path)}else status=
[];return status}status=query._path;return syncTreeApplyOperationToSyncPoints_(syncTree,new ListenComplete(newOperationSourceServer(),status))}path="Unknown Error";"too_big"===status?path="The data requested exceeds the maximum size that can be accessed with a single request.":"permission_denied"===status?path="Client doesn't have permission to access the desired data.":"unavailable"===status&&(path="The service is unavailable");path=Error(status+" at "+query._path.toString()+": "+path);path.code=
status.toUpperCase();return syncTreeRemoveEventRegistration(syncTree,query,null,path)}}}function syncTreeTagForQuery_(syncTree,query){query=syncTreeMakeQueryKey_(query);return syncTree.queryToTagMap.get(query)}function syncTreeMakeQueryKey_(query){return query._path.toString()+"$"+query._queryIdentifier}function syncTreeParseQueryKey_(queryKey){const splitIndex=queryKey.indexOf("$");(0,_util.assert)(-1!==splitIndex&&splitIndex<queryKey.length-1,"Bad queryKey.");return{queryId:queryKey.substr(splitIndex+
1),path:new Path(queryKey.substr(0,splitIndex))}}function syncTreeApplyTaggedOperation_(syncTree,queryPath,operation){const syncPoint=syncTree.syncPointTree_.get(queryPath);(0,_util.assert)(syncPoint,"Missing sync point for query tag that we're tracking");syncTree=newWriteTreeRef(queryPath,syncTree.pendingWriteTree_);return syncPointApplyOperation(syncPoint,operation,syncTree,null)}function syncTreeCollectDistinctViewsForSubTree_(subtree){return subtree.fold((relativePath,maybeChildSyncPoint,childMap)=>
{if(maybeChildSyncPoint&&null!=syncPointGetCompleteView(maybeChildSyncPoint))return[syncPointGetCompleteView(maybeChildSyncPoint)];let views=[];maybeChildSyncPoint&&(views=syncPointGetQueryViews(maybeChildSyncPoint));each(childMap,(_key,childViews)=>{views=views.concat(childViews)});return views})}function syncTreeQueryForListening_(query){return query._queryParams.loadsAllData()&&!query._queryParams.isDefault()?((0,_util.assert)(referenceConstructor,"Reference.ts has not been loaded"),new referenceConstructor(query._repo,
query._path)):query}function syncTreeRemoveTags_(syncTree,queries){for(let j=0;j<queries.length;++j){var removedQuery=queries[j];if(!removedQuery._queryParams.loadsAllData()){removedQuery=syncTreeMakeQueryKey_(removedQuery);const removedQueryTag=syncTree.queryToTagMap.get(removedQuery);syncTree.queryToTagMap.delete(removedQuery);syncTree.tagToQueryMap.delete(removedQueryTag)}}}function syncTreeSetupListener_(syncTree,query,view$jscomp$0){var path=query._path,tag=syncTreeTagForQuery_(syncTree,query);
view$jscomp$0=syncTreeCreateListenerForView_(syncTree,view$jscomp$0);query=syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query),tag,view$jscomp$0.hashFn,view$jscomp$0.onComplete);path=syncTree.syncPointTree_.subtree(path);if(tag)(0,_util.assert)(null==syncPointGetCompleteView(path.value),"If we're adding a query, it shouldn't be shadowed");else for(tag=path.fold((relativePath,maybeChildSyncPoint,childMap)=>{if(!pathIsEmpty(relativePath)&&maybeChildSyncPoint&&null!=syncPointGetCompleteView(maybeChildSyncPoint))return[syncPointGetCompleteView(maybeChildSyncPoint).query];
let queries=[];maybeChildSyncPoint&&(queries=queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(view=>view.query)));each(childMap,(_key,childQueries)=>{queries=queries.concat(childQueries)});return queries}),path=0;path<tag.length;++path)view$jscomp$0=tag[path],syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(view$jscomp$0),syncTreeTagForQuery_(syncTree,view$jscomp$0));return query}function resolveDeferredValue(node,existingVal,serverValues){var rawPri=node.getPriority().val();
rawPri=resolveDeferredLeafValue(rawPri,existingVal.getImmediateChild(".priority"),serverValues);let newNode;if(node.isLeafNode()){const value=resolveDeferredLeafValue(node.getValue(),existingVal,serverValues);return value!==node.getValue()||rawPri!==node.getPriority().val()?new LeafNode(value,nodeFromJSON(rawPri)):node}newNode=node;rawPri!==node.getPriority().val()&&(newNode=newNode.updatePriority(new LeafNode(rawPri)));node.forEachChild(PRIORITY_INDEX,(childName,childNode)=>{const newChildNode=resolveDeferredValue(childNode,
existingVal.getImmediateChild(childName),serverValues);newChildNode!==childNode&&(newNode=newNode.updateImmediateChild(childName,newChildNode))});return newNode}function treeSubTree(tree,pathObj){pathObj=pathObj instanceof Path?pathObj:new Path(pathObj);let next=pathGetFront(pathObj);for(;null!==next;){const childNode=(0,_util.safeGet)(tree.node.children,next)||{children:{},childCount:0};tree=new Tree(next,tree,childNode);pathObj=pathPopFront(pathObj);next=pathGetFront(pathObj)}return tree}function treeSetValue(tree,
value){tree.node.value=value;treeUpdateParents(tree)}function treeForEachChild(tree,action){each(tree.node.children,(child,childTree)=>{action(new Tree(child,tree,childTree))})}function treeForEachDescendant(tree,action,includeSelf,childrenFirst){includeSelf&&!childrenFirst&&action(tree);treeForEachChild(tree,child=>{treeForEachDescendant(child,action,!0,childrenFirst)});includeSelf&&childrenFirst&&action(tree)}function treeForEachAncestor(tree,action,includeSelf){for(tree=includeSelf?tree:tree.parent;null!==
tree;){if(action(tree))return!0;tree=tree.parent}return!1}function treeGetPath(tree){return new Path(null===tree.parent?tree.name:treeGetPath(tree.parent)+"/"+tree.name)}function treeUpdateParents(tree$jscomp$0){if(null!==tree$jscomp$0.parent){var tree=tree$jscomp$0.parent,childName=tree$jscomp$0.name;var JSCompiler_inline_result=void 0===tree$jscomp$0.node.value&&!(0<tree$jscomp$0.node.childCount);const childExists=(0,_util.contains)(tree.node.children,childName);JSCompiler_inline_result&&childExists?
(delete tree.node.children[childName],tree.node.childCount--,treeUpdateParents(tree)):JSCompiler_inline_result||childExists||(tree.node.children[childName]=tree$jscomp$0.node,tree.node.childCount++,treeUpdateParents(tree))}}function eventQueueQueueEvents(eventQueue,eventDataList){let currList=null;for(let i=0;i<eventDataList.length;i++){const data=eventDataList[i],path=data.getPath();null===currList||pathEquals(path,currList.path)||(eventQueue.eventLists_.push(currList),currList=null);null===currList&&
(currList={events:[],path});currList.events.push(data)}currList&&eventQueue.eventLists_.push(currList)}function eventQueueRaiseEventsAtPath(eventQueue,path,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,eventPath=>pathEquals(eventPath,path))}function eventQueueRaiseEventsForChangedPath(eventQueue,changedPath,eventDataList){eventQueueQueueEvents(eventQueue,eventDataList);eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,
eventPath=>pathContains(eventPath,changedPath)||pathContains(changedPath,eventPath))}function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue,predicate){eventQueue.recursionDepth_++;let sentAll=!0;for(let i$jscomp$0=0;i$jscomp$0<eventQueue.eventLists_.length;i$jscomp$0++){var eventList=eventQueue.eventLists_[i$jscomp$0];if(eventList)if(predicate(eventList.path)){eventList=eventQueue.eventLists_[i$jscomp$0];for(let i=0;i<eventList.events.length;i++){const eventData=eventList.events[i];if(null!==
eventData){eventList.events[i]=null;const eventFn=eventData.getEventRunner();logger$jscomp$0&&log("event: "+eventData.toString());exceptionGuard(eventFn)}}eventQueue.eventLists_[i$jscomp$0]=null}else sentAll=!1}sentAll&&(eventQueue.eventLists_=[]);eventQueue.recursionDepth_--}function repoStart(repo,appId,authOverride){repo.stats_=statsManagerGetCollection(repo.repoInfo_);if(repo.forceRestClient_||0<=("object"===typeof window&&window.navigator&&window.navigator.userAgent||"").search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i))repo.server_=
new ReadonlyRestClient(repo.repoInfo_,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag)},repo.authTokenProvider_,repo.appCheckProvider_),setTimeout(()=>{repoUpdateInfo(repo,"connected",!0)},0);else{if("undefined"!==typeof authOverride&&null!==authOverride){if("object"!==typeof authOverride)throw Error("Only objects are supported for option databaseAuthVariableOverride");try{(0,_util.stringify)(authOverride)}catch(e){throw Error("Invalid authOverride provided: "+e);
}}repo.persistentConnection_=new PersistentConnection(repo.repoInfo_,appId,(pathString,data,isMerge,tag)=>{repoOnDataUpdate(repo,pathString,data,isMerge,tag)},connectStatus=>{repoUpdateInfo(repo,"connected",connectStatus);!1===connectStatus&&repoRunOnDisconnectEvents(repo)},updates=>{repoOnServerInfoUpdate(repo,updates)},repo.authTokenProvider_,repo.appCheckProvider_,authOverride);repo.server_=repo.persistentConnection_}repo.authTokenProvider_.addTokenChangeListener(token=>{repo.server_.refreshAuthToken(token)});
repo.appCheckProvider_.addTokenChangeListener(result=>{repo.server_.refreshAppCheckToken(result.token)});repo.statsReporter_=statsManagerGetOrCreateReporter(repo.repoInfo_,()=>new StatsReporter(repo.stats_,repo.server_));repo.infoData_=new SnapshotHolder;repo.infoSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{tag=[];currentHashFn=repo.infoData_.getNode(query._path);currentHashFn.isEmpty()||(tag=syncTreeApplyServerOverwrite(repo.infoSyncTree_,query._path,currentHashFn),
setTimeout(()=>{onComplete("ok")},0));return tag},stopListening:()=>{}});repoUpdateInfo(repo,"connected",!1);repo.serverSyncTree_=new SyncTree({startListening:(query,tag,currentHashFn,onComplete)=>{repo.server_.listen(query,currentHashFn,tag,(status,data)=>{status=onComplete(status,data);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,query._path,status)});return[]},stopListening:(query,tag)=>{repo.server_.unlisten(query,tag)}})}function repoServerTime(repo){repo=repo.infoData_.getNode(new Path(".info/serverTimeOffset")).val()||
0;return(new Date).getTime()+repo}function repoGenerateServerValues(repo){repo=repo={timestamp:repoServerTime(repo)};repo.timestamp=repo.timestamp||(new Date).getTime();return repo}function repoOnDataUpdate(repo,pathString,data,isMerge,tag){repo.dataUpdateCount++;const path=new Path(pathString);data=repo.interceptServerDataCallback_?repo.interceptServerDataCallback_(pathString,data):data;pathString=[];tag?isMerge?(data=(0,_util.map)(data,raw=>nodeFromJSON(raw)),pathString=syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_,
path,data,tag)):(data=nodeFromJSON(data),pathString=syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_,path,data,tag)):isMerge?(tag=(0,_util.map)(data,raw=>nodeFromJSON(raw)),pathString=syncTreeApplyServerMerge(repo.serverSyncTree_,path,tag)):(tag=nodeFromJSON(data),pathString=syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,tag));tag=path;0<pathString.length&&(tag=repoRerunTransactions(repo,path));eventQueueRaiseEventsForChangedPath(repo.eventQueue_,tag,pathString)}function repoOnServerInfoUpdate(repo,
updates){each(updates,(key,value)=>{repoUpdateInfo(repo,key,value)})}function repoUpdateInfo(repo,pathString,value){pathString=new Path("/.info/"+pathString);value=nodeFromJSON(value);repo.infoData_.updateSnapshot(pathString,value);value=syncTreeApplyServerOverwrite(repo.infoSyncTree_,pathString,value);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,pathString,value)}function repoGetValue(repo,query){const cached=syncTreeGetServerValue(repo.serverSyncTree_,query);return null!=cached?Promise.resolve(cached):
repo.server_.get(query).then(payload=>{payload=nodeFromJSON(payload).withIndex(query._queryParams.getIndex());const events=syncTreeApplyServerOverwrite(repo.serverSyncTree_,query._path,payload);eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,events);return Promise.resolve(payload)},err=>{repoLog(repo,"get for query "+(0,_util.stringify)(query)+" failed: "+err);return Promise.reject(Error(err))})}function repoSetWithPriority(repo,path,newVal,newPriority,onComplete){repoLog(repo,"set",{path:path.toString(),
value:newVal,priority:newPriority});var serverValues=repoGenerateServerValues(repo);newVal=nodeFromJSON(newVal,newPriority);newPriority=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path);serverValues=resolveDeferredValueSnapshot(newVal,newPriority,serverValues);const writeId=repo.nextWriteId_++;serverValues=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,serverValues,writeId,!0);eventQueueQueueEvents(repo.eventQueue_,serverValues);repo.server_.put(path.toString(),newVal.val(!0),(status,
errorReason)=>{var success="ok"===status;success||warn("set at "+path+" failed: "+status);success=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,success);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)});serverValues=repoAbortTransactions(repo,path);repoRerunTransactions(repo,serverValues);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,serverValues,[])}function repoUpdate(repo,path,childrenToMerge,onComplete){repoLog(repo,
"update",{path:path.toString(),value:childrenToMerge});let empty=!0;const serverValues=repoGenerateServerValues(repo),changedChildren={};each(childrenToMerge,(changedKey,changedValue)=>{empty=!1;var JSCompiler_inline_result=pathChild(path,changedKey);changedValue=nodeFromJSON(changedValue);JSCompiler_inline_result=resolveDeferredValue(changedValue,new DeferredValueProvider(repo.serverSyncTree_,JSCompiler_inline_result),serverValues);changedChildren[changedKey]=JSCompiler_inline_result});if(empty)log("update() called with empty data.  Don't do anything."),
repoCallOnCompleteCallback(repo,onComplete,"ok",void 0);else{const writeId=repo.nextWriteId_++,events=syncTreeApplyUserMerge(repo.serverSyncTree_,path,changedChildren,writeId);eventQueueQueueEvents(repo.eventQueue_,events);repo.server_.merge(path.toString(),childrenToMerge,(status,errorReason)=>{var success="ok"===status;success||warn("update at "+path+" failed: "+status);success=syncTreeAckUserWrite(repo.serverSyncTree_,writeId,!success);const affectedPath=0<success.length?repoRerunTransactions(repo,
path):path;eventQueueRaiseEventsForChangedPath(repo.eventQueue_,affectedPath,success);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)});each(childrenToMerge,changedPath=>{changedPath=repoAbortTransactions(repo,pathChild(path,changedPath));repoRerunTransactions(repo,changedPath)});eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,[])}}function repoRunOnDisconnectEvents(repo){repoLog(repo,"onDisconnectEvents");const serverValues=repoGenerateServerValues(repo),resolvedOnDisconnectTree=
newSparseSnapshotTree();sparseSnapshotTreeForEachTree(repo.onDisconnect_,newEmptyPath(),(path,node)=>{node=resolveDeferredValue(node,new DeferredValueProvider(repo.serverSyncTree_,path),serverValues);sparseSnapshotTreeRemember(resolvedOnDisconnectTree,path,node)});let events=[];sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree,newEmptyPath(),(path,snap)=>{events=events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_,path,snap));path=repoAbortTransactions(repo,path);repoRerunTransactions(repo,
path)});repo.onDisconnect_=newSparseSnapshotTree();eventQueueRaiseEventsForChangedPath(repo.eventQueue_,newEmptyPath(),events)}function repoOnDisconnectCancel(repo,path,onComplete){repo.server_.onDisconnectCancel(path.toString(),(status,errorReason)=>{"ok"===status&&sparseSnapshotTreeForget(repo.onDisconnect_,path);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)})}function repoOnDisconnectSet(repo,path,value,onComplete){const newNode=nodeFromJSON(value);repo.server_.onDisconnectPut(path.toString(),
newNode.val(!0),(status,errorReason)=>{"ok"===status&&sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);repoCallOnCompleteCallback(repo,onComplete,status,errorReason)})}function repoOnDisconnectSetWithPriority(repo,path,value,priority,onComplete){const newNode=nodeFromJSON(value,priority);repo.server_.onDisconnectPut(path.toString(),newNode.val(!0),(status,errorReason)=>{"ok"===status&&sparseSnapshotTreeRemember(repo.onDisconnect_,path,newNode);repoCallOnCompleteCallback(repo,onComplete,
status,errorReason)})}function repoOnDisconnectUpdate(repo,path,childrenToMerge,onComplete){if((0,_util.isEmpty)(childrenToMerge))log("onDisconnect().update() called with empty data.  Don't do anything."),repoCallOnCompleteCallback(repo,onComplete,"ok",void 0);else repo.server_.onDisconnectMerge(path.toString(),childrenToMerge,(status,errorReason)=>{"ok"===status&&each(childrenToMerge,(childName,childNode)=>{childNode=nodeFromJSON(childNode);sparseSnapshotTreeRemember(repo.onDisconnect_,pathChild(path,
childName),childNode)});repoCallOnCompleteCallback(repo,onComplete,status,errorReason)})}function repoAddEventCallbackForQuery(repo,query,eventRegistration){eventRegistration=".info"===pathGetFront(query._path)?syncTreeAddEventRegistration(repo.infoSyncTree_,query,eventRegistration):syncTreeAddEventRegistration(repo.serverSyncTree_,query,eventRegistration);eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,eventRegistration)}function repoRemoveEventCallbackForQuery(repo,query,eventRegistration){eventRegistration=
".info"===pathGetFront(query._path)?syncTreeRemoveEventRegistration(repo.infoSyncTree_,query,eventRegistration):syncTreeRemoveEventRegistration(repo.serverSyncTree_,query,eventRegistration);eventQueueRaiseEventsAtPath(repo.eventQueue_,query._path,eventRegistration)}function repoInterrupt(repo){repo.persistentConnection_&&repo.persistentConnection_.interrupt("repo_interrupt")}function repoLog(repo,...varArgs){let prefix="";repo.persistentConnection_&&(prefix=repo.persistentConnection_.id+":");log(prefix,
...varArgs)}function repoCallOnCompleteCallback(repo,callback,status,errorReason){callback&&exceptionGuard(()=>{if("ok"===status)callback(null);else{const code=(status||"error").toUpperCase();var message=code;errorReason&&(message+=": "+errorReason);message=Error(message);message.code=code;callback(message)}})}function repoStartTransaction(repo,path,transactionUpdate,onComplete,unwatcher,applyLocally){repoLog(repo,"transaction on "+path);transactionUpdate={path,update:transactionUpdate,onComplete,
status:null,order:LUIDGenerator(),applyLocally,retryCount:0,unwatcher,abortReason:null,currentWriteId:null,currentInputSnapshot:null,currentOutputSnapshotRaw:null,currentOutputSnapshotResolved:null};onComplete=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path,void 0)||ChildrenNode.EMPTY_NODE;transactionUpdate.currentInputSnapshot=onComplete;unwatcher=transactionUpdate.update(onComplete.val());if(void 0===unwatcher){if(transactionUpdate.unwatcher(),transactionUpdate.currentOutputSnapshotRaw=
null,transactionUpdate.currentOutputSnapshotResolved=null,transactionUpdate.onComplete)transactionUpdate.onComplete(null,!1,transactionUpdate.currentInputSnapshot)}else{validateFirebaseData("transaction failed: Data returned ",unwatcher,transactionUpdate.path);transactionUpdate.status=0;applyLocally=treeSubTree(repo.transactionQueueTree_,path);var nodeQueue=applyLocally.node.value||[];nodeQueue.push(transactionUpdate);treeSetValue(applyLocally,nodeQueue);"object"===typeof unwatcher&&null!==unwatcher&&
(0,_util.contains)(unwatcher,".priority")?(nodeQueue=(0,_util.safeGet)(unwatcher,".priority"),(0,_util.assert)(isValidPriority(nodeQueue),"Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.")):nodeQueue=(syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path)||ChildrenNode.EMPTY_NODE).getPriority().val();applyLocally=repoGenerateServerValues(repo);unwatcher=nodeFromJSON(unwatcher,nodeQueue);onComplete=resolveDeferredValueSnapshot(unwatcher,
onComplete,applyLocally);transactionUpdate.currentOutputSnapshotRaw=unwatcher;transactionUpdate.currentOutputSnapshotResolved=onComplete;transactionUpdate.currentWriteId=repo.nextWriteId_++;transactionUpdate=syncTreeApplyUserOverwrite(repo.serverSyncTree_,path,onComplete,transactionUpdate.currentWriteId,transactionUpdate.applyLocally);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,transactionUpdate);repoSendReadyTransactions(repo,repo.transactionQueueTree_)}}function repoSendReadyTransactions(repo,
node=repo.transactionQueueTree_){node||repoPruneCompletedTransactionsBelowNode(repo,node);if(node.node.value){const queue=repoBuildTransactionQueue(repo,node);(0,_util.assert)(0<queue.length,"Sending zero length transaction queue");queue.every(transaction=>0===transaction.status)&&repoSendTransactionQueue(repo,treeGetPath(node),queue)}else 0<node.node.childCount&&treeForEachChild(node,childNode=>{repoSendReadyTransactions(repo,childNode)})}function repoSendTransactionQueue(repo,path,queue){var setsToIgnore=
queue.map(txn=>txn.currentWriteId),latestState=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,path,setsToIgnore)||ChildrenNode.EMPTY_NODE;setsToIgnore=latestState;latestState=latestState.hash();for(let i=0;i<queue.length;i++){const txn=queue[i];(0,_util.assert)(0===txn.status,"tryToSendTransactionQueue_: items in queue should all be run.");txn.status=1;txn.retryCount++;const relativePath=newRelativePath(path,txn.path);setsToIgnore=setsToIgnore.updateChild(relativePath,txn.currentOutputSnapshotRaw)}setsToIgnore=
setsToIgnore.val(!0);repo.server_.put(path.toString(),setsToIgnore,status=>{repoLog(repo,"transaction put response",{path:path.toString(),status});var events=[];if("ok"===status){status=[];for(let i=0;i<queue.length;i++)queue[i].status=2,events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId)),queue[i].onComplete&&status.push(()=>queue[i].onComplete(null,!0,queue[i].currentOutputSnapshotResolved)),queue[i].unwatcher();repoPruneCompletedTransactionsBelowNode(repo,treeSubTree(repo.transactionQueueTree_,
path));repoSendReadyTransactions(repo,repo.transactionQueueTree_);eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);for(events=0;events<status.length;events++)exceptionGuard(status[events])}else{if("datastale"===status)for(status=0;status<queue.length;status++)queue[status].status=3===queue[status].status?4:0;else for(warn("transaction at "+path.toString()+" failed: "+status),events=0;events<queue.length;events++)queue[events].status=4,queue[events].abortReason=status;repoRerunTransactions(repo,
path)}},latestState)}function repoRerunTransactions(repo,changedPath){var rootMostTransactionNode=repoGetAncestorTransactionNode(repo,changedPath);changedPath=treeGetPath(rootMostTransactionNode);rootMostTransactionNode=repoBuildTransactionQueue(repo,rootMostTransactionNode);repoRerunTransactionQueue(repo,rootMostTransactionNode,changedPath);return changedPath}function repoRerunTransactionQueue(repo,queue,path){if(0!==queue.length){var callbacks=[],events=[],setsToIgnore=queue.filter(q=>0===q.status).map(q=>
q.currentWriteId);for(let i=0;i<queue.length;i++){const transaction=queue[i];var relativePath=newRelativePath(path,transaction.path);let abortTransaction=!1,abortReason;(0,_util.assert)(null!==relativePath,"rerunTransactionsUnderNode_: relativePath should not be null.");if(4===transaction.status)abortTransaction=!0,abortReason=transaction.abortReason,events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,!0));else if(0===transaction.status)if(25<=transaction.retryCount)abortTransaction=
!0,abortReason="maxretry",events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,!0));else{var currentNode=syncTreeCalcCompleteEventCache(repo.serverSyncTree_,transaction.path,setsToIgnore)||ChildrenNode.EMPTY_NODE;transaction.currentInputSnapshot=currentNode;var newData=queue[i].update(currentNode.val());if(void 0!==newData){validateFirebaseData("transaction failed: Data returned ",newData,transaction.path);relativePath=nodeFromJSON(newData);"object"===typeof newData&&
null!=newData&&(0,_util.contains)(newData,".priority")||(relativePath=relativePath.updatePriority(currentNode.getPriority()));newData=transaction.currentWriteId;const serverValues=repoGenerateServerValues(repo);currentNode=resolveDeferredValueSnapshot(relativePath,currentNode,serverValues);transaction.currentOutputSnapshotRaw=relativePath;transaction.currentOutputSnapshotResolved=currentNode;transaction.currentWriteId=repo.nextWriteId_++;setsToIgnore.splice(setsToIgnore.indexOf(newData),1);events=
events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_,transaction.path,currentNode,transaction.currentWriteId,transaction.applyLocally));events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,newData,!0))}else abortTransaction=!0,abortReason="nodata",events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,transaction.currentWriteId,!0))}eventQueueRaiseEventsForChangedPath(repo.eventQueue_,path,events);events=[];abortTransaction&&(queue[i].status=2,setTimeout(queue[i].unwatcher,
0),queue[i].onComplete&&("nodata"===abortReason?callbacks.push(()=>queue[i].onComplete(null,!1,queue[i].currentInputSnapshot)):callbacks.push(()=>queue[i].onComplete(Error(abortReason),!1,null))))}repoPruneCompletedTransactionsBelowNode(repo,repo.transactionQueueTree_);for(path=0;path<callbacks.length;path++)exceptionGuard(callbacks[path]);repoSendReadyTransactions(repo,repo.transactionQueueTree_)}}function repoGetAncestorTransactionNode(repo,path){let transactionNode=repo.transactionQueueTree_;for(repo=
pathGetFront(path);null!==repo&&void 0===transactionNode.node.value;)transactionNode=treeSubTree(transactionNode,repo),path=pathPopFront(path),repo=pathGetFront(path);return transactionNode}function repoBuildTransactionQueue(repo,transactionNode){const transactionQueue=[];repoAggregateTransactionQueuesForNode(repo,transactionNode,transactionQueue);transactionQueue.sort((a,b)=>a.order-b.order);return transactionQueue}function repoAggregateTransactionQueuesForNode(repo,node,queue){const nodeQueue=node.node.value;
if(nodeQueue)for(let i=0;i<nodeQueue.length;i++)queue.push(nodeQueue[i]);treeForEachChild(node,child=>{repoAggregateTransactionQueuesForNode(repo,child,queue)})}function repoPruneCompletedTransactionsBelowNode(repo,node){const queue=node.node.value;if(queue){let to=0;for(let from=0;from<queue.length;from++)2!==queue[from].status&&(queue[to]=queue[from],to++);queue.length=to;treeSetValue(node,0<queue.length?queue:void 0)}treeForEachChild(node,childNode=>{repoPruneCompletedTransactionsBelowNode(repo,
childNode)})}function repoAbortTransactions(repo,path){const affectedPath=treeGetPath(repoGetAncestorTransactionNode(repo,path));path=treeSubTree(repo.transactionQueueTree_,path);treeForEachAncestor(path,node=>{repoAbortTransactionsOnNode(repo,node)});repoAbortTransactionsOnNode(repo,path);treeForEachDescendant(path,node=>{repoAbortTransactionsOnNode(repo,node)});return affectedPath}function repoAbortTransactionsOnNode(repo,node){const queue=node.node.value;if(queue){const callbacks=[];let events=
[],lastSent=-1;for(let i=0;i<queue.length;i++)3!==queue[i].status&&(1===queue[i].status?((0,_util.assert)(lastSent===i-1,"All SENT items should be at beginning of queue."),lastSent=i,queue[i].status=3,queue[i].abortReason="set"):((0,_util.assert)(0===queue[i].status,"Unexpected transaction status in abort"),queue[i].unwatcher(),events=events.concat(syncTreeAckUserWrite(repo.serverSyncTree_,queue[i].currentWriteId,!0)),queue[i].onComplete&&callbacks.push(queue[i].onComplete.bind(null,Error("set"),
!1,null))));-1===lastSent?treeSetValue(node,void 0):queue.length=lastSent+1;eventQueueRaiseEventsForChangedPath(repo.eventQueue_,treeGetPath(node),events);for(repo=0;repo<callbacks.length;repo++)exceptionGuard(callbacks[repo])}}function validateNoPreviousOrderByCall(query,fnName){if(!0===query._orderByCalled)throw Error(fnName+": You can't combine multiple orderBy calls.");}function validateQueryEndpoints(params){let startNode=null,endNode=null;params.hasStart()&&(startNode=params.getIndexStartValue());
params.hasEnd()&&(endNode=params.getIndexEndValue());if(params.getIndex()===KEY_INDEX){if(params.hasStart()){if("[MIN_NAME]"!==params.getIndexStartName())throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");if("string"!==typeof startNode)throw Error("Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.");}if(params.hasEnd()){if("[MAX_NAME]"!==params.getIndexEndName())throw Error("Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().");
if("string"!==typeof endNode)throw Error("Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.");}}else if(params.getIndex()===PRIORITY_INDEX){if(null!=startNode&&!isValidPriority(startNode)||null!=endNode&&!isValidPriority(endNode))throw Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
}else if((0,_util.assert)(params.getIndex()instanceof PathIndex||params.getIndex()===VALUE_INDEX,"unknown index type."),null!=startNode&&"object"===typeof startNode||null!=endNode&&"object"===typeof endNode)throw Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");}function validateLimit(params){if(params.hasStart()&&params.hasEnd()&&params.hasLimit()&&!params.hasAnchoredLimit())throw Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
}function ref$jscomp$0(db,path){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("ref");return void 0!==path?child$jscomp$0(db._root,path):db._root}function child$jscomp$0(parent,path){parent=(0,_util.getModularInstance)(parent);if(null===pathGetFront(parent._path)){var pathString=path;pathString&&(pathString=pathString.replace(/^\/*\.info(\/|$)/,"/"));validatePathString("child","path",pathString,!1)}else validatePathString("child","path",path,!1);return new ReferenceImpl(parent._repo,pathChild(parent._path,
path))}function set(ref,value){ref=(0,_util.getModularInstance)(ref);validateWritablePath("set",ref._path);validateFirebaseDataArg("set",value,ref._path,!1);const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,ref._path,value,null,deferred.wrapCallback(()=>{}));return deferred.promise}function addEventListener(query,eventType,callback,cancelCallbackOrListenOptions,options){let cancelCallback;"object"===typeof cancelCallbackOrListenOptions&&(cancelCallback=void 0,options=cancelCallbackOrListenOptions);
"function"===typeof cancelCallbackOrListenOptions&&(cancelCallback=cancelCallbackOrListenOptions);if(options&&options.onlyOnce){const userCallback=callback;cancelCallbackOrListenOptions=(dataSnapshot,previousChildName)=>{repoRemoveEventCallbackForQuery(query._repo,query,container);userCallback(dataSnapshot,previousChildName)};cancelCallbackOrListenOptions.userCallback=callback.userCallback;cancelCallbackOrListenOptions.context=callback.context;callback=cancelCallbackOrListenOptions}callback=new CallbackContext(callback,
cancelCallback||void 0);const container="value"===eventType?new ValueEventRegistration(callback):new ChildEventRegistration(eventType,callback);repoAddEventCallbackForQuery(query._repo,query,container);return()=>repoRemoveEventCallbackForQuery(query._repo,query,container)}function onValue(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"value",callback,cancelCallbackOrListenOptions,options)}function repoManagerDatabaseFromApp(app,authProvider,appCheckProvider,url,
nodeAdmin){url=url||app.options.databaseURL;void 0===url&&(app.options.projectId||fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp()."),log("Using default host for project ",app.options.projectId),url=`${app.options.projectId}-default-rtdb.firebaseio.com`);url=parseRepoInfo(url,nodeAdmin);var repoInfo=url.repoInfo;let isEmulator,dbEmulatorHost=void 0;"undefined"!==typeof process&&process.env&&(dbEmulatorHost=process.env.FIREBASE_DATABASE_EMULATOR_HOST);
dbEmulatorHost?(isEmulator=!0,url=`http://${dbEmulatorHost}?ns=${repoInfo.namespace}`,url=parseRepoInfo(url,nodeAdmin),repoInfo=url.repoInfo):isEmulator=!url.repoInfo.secure;authProvider=nodeAdmin&&isEmulator?new EmulatorTokenProvider(EmulatorTokenProvider.OWNER):new FirebaseAuthTokenProvider(app.name,app.options,authProvider);validateUrl("Invalid Firebase Database URL",url);pathIsEmpty(url.path)||fatal("Database URL must point to the root of a Firebase Database (not including a child path).");nodeAdmin=
repoInfo;appCheckProvider=new AppCheckTokenProvider(app.name,appCheckProvider);url=repos[app.name];url||(url={},repos[app.name]=url);(repoInfo=url[nodeAdmin.toURLString()])&&fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");repoInfo=new Repo(nodeAdmin,useRestClient,authProvider,appCheckProvider);url[nodeAdmin.toURLString()]=repoInfo;return new Database(repoInfo,app)}var process=require("module$node_modules$process$browser");
"use strict";Object.defineProperty(exports,"__esModule",{value:!0});exports._repoManagerDatabaseFromApp=repoManagerDatabaseFromApp;exports._setSDKVersion=function(version){SDK_VERSION=version};exports.child=child$jscomp$0;exports.connectDatabaseEmulator=function(db,host,port,options={}){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("useEmulator");db._instanceStarted&&fatal("Cannot call useEmulator() after instance has already been initialized.");const repo=db._repoInternal;let tokenProvider=
void 0;repo.repoInfo_.nodeAdmin?(options.mockUserToken&&fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".'),tokenProvider=new EmulatorTokenProvider(EmulatorTokenProvider.OWNER)):options.mockUserToken&&(db="string"===typeof options.mockUserToken?options.mockUserToken:(0,_util.createMockUserToken)(options.mockUserToken,db.app.options.projectId),tokenProvider=new EmulatorTokenProvider(db));db=tokenProvider;
repo.repoInfo_=new RepoInfo(`${host}:${port}`,!1,repo.repoInfo_.namespace,repo.repoInfo_.webSocketOnly,repo.repoInfo_.nodeAdmin,repo.repoInfo_.persistenceKey,repo.repoInfo_.includeNamespaceInQueryParams);db&&(repo.authTokenProvider_=db)};exports.enableLogging=function(logger,persistent){enableLogging$1(logger,persistent)};exports.endAt=function(value,key){validateKey("endAt","key",key,!0);return new QueryEndAtConstraint(value,key)};exports.endBefore=function(value,key){validateKey("endBefore","key",
key,!0);return new QueryEndBeforeConstraint(value,key)};exports.equalTo=function(value,key){validateKey("equalTo","key",key,!0);return new QueryEqualToValueConstraint(value,key)};exports.get=function(query){query=(0,_util.getModularInstance)(query);return repoGetValue(query._repo,query).then(node=>new DataSnapshot(node,new ReferenceImpl(query._repo,query._path),query._queryParams.getIndex()))};exports.getDatabase=function(app=(0,_app.getApp)(),url){return(0,_app._getProvider)(app,"database").getImmediate({identifier:url})};
exports.goOffline=function(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("goOffline");repoInterrupt(db._repo)};exports.goOnline=function(db){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("goOnline");db=db._repo;db.persistentConnection_&&db.persistentConnection_.resume("repo_interrupt")};exports.increment=function(delta){return{".sv":{increment:delta}}};exports.limitToFirst=function(limit){if("number"!==typeof limit||Math.floor(limit)!==limit||0>=limit)throw Error("limitToFirst: First argument must be a positive integer.");
return new QueryLimitToFirstConstraint(limit)};exports.limitToLast=function(limit){if("number"!==typeof limit||Math.floor(limit)!==limit||0>=limit)throw Error("limitToLast: First argument must be a positive integer.");return new QueryLimitToLastConstraint(limit)};exports.off=function(query,eventType,callback){let container=null;callback=callback?new CallbackContext(callback):null;"value"===eventType?container=new ValueEventRegistration(callback):eventType&&(container=new ChildEventRegistration(eventType,
callback));repoRemoveEventCallbackForQuery(query._repo,query,container)};exports.onChildAdded=function(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_added",callback,cancelCallbackOrListenOptions,options)};exports.onChildChanged=function(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_changed",callback,cancelCallbackOrListenOptions,options)};exports.onChildMoved=function(query,callback,cancelCallbackOrListenOptions,
options){return addEventListener(query,"child_moved",callback,cancelCallbackOrListenOptions,options)};exports.onChildRemoved=function(query,callback,cancelCallbackOrListenOptions,options){return addEventListener(query,"child_removed",callback,cancelCallbackOrListenOptions,options)};exports.onDisconnect=function(ref){ref=(0,_util.getModularInstance)(ref);return new OnDisconnect(ref._repo,ref._path)};exports.onValue=onValue;exports.orderByChild=function(path){if("$key"===path)throw Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
if("$priority"===path)throw Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');if("$value"===path)throw Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');validatePathString("orderByChild","path",path,!1);return new QueryOrderByChildConstraint(path)};exports.orderByKey=function(){return new QueryOrderByKeyConstraint};exports.orderByPriority=function(){return new QueryOrderByPriorityConstraint};exports.orderByValue=function(){return new QueryOrderByValueConstraint};
exports.push=function(parent,value){parent=(0,_util.getModularInstance)(parent);validateWritablePath("push",parent._path);validateFirebaseDataArg("push",value,parent._path,!0);var now=repoServerTime(parent._repo);const name=nextPushId(now);now=child$jscomp$0(parent,name);const pushRef=child$jscomp$0(parent,name);parent=null!=value?set(pushRef,value).then(()=>pushRef):Promise.resolve(pushRef);now.then=parent.then.bind(parent);now.catch=parent.then.bind(parent,void 0);return now};exports.query=function(query,
...queryConstraints){query=(0,_util.getModularInstance)(query);for(const constraint of queryConstraints)query=constraint._apply(query);return query};exports.ref=ref$jscomp$0;exports.refFromURL=function(db,url){db=(0,_util.getModularInstance)(db);db._checkNotDeleted("refFromURL");url=parseRepoInfo(url,db._repo.repoInfo_.nodeAdmin);validateUrl("refFromURL",url);const repoInfo=url.repoInfo;db._repo.repoInfo_.isCustomHost()||repoInfo.host===db._repo.repoInfo_.host||fatal("refFromURL: Host name does not match the current database: (found "+
repoInfo.host+" but expected "+db._repo.repoInfo_.host+")");return ref$jscomp$0(db,url.path.toString())};exports.remove=function(ref){validateWritablePath("remove",ref._path);return set(ref,null)};exports.runTransaction=function(ref,transactionUpdate,options){var _a;ref=(0,_util.getModularInstance)(ref);validateWritablePath("Reference.transaction",ref._path);if(".length"===ref.key||".keys"===ref.key)throw"Reference.transaction failed: "+ref.key+" is a read-only object.";options=null!==(_a=null===
options||void 0===options?void 0:options.applyLocally)&&void 0!==_a?_a:!0;const deferred=new _util.Deferred;_a=onValue(ref,()=>{});repoStartTransaction(ref._repo,ref._path,transactionUpdate,(error,committed,node)=>{error?deferred.reject(error):(error=new DataSnapshot(node,new ReferenceImpl(ref._repo,ref._path),PRIORITY_INDEX),deferred.resolve(new TransactionResult(committed,error)))},_a,options);return deferred.promise};exports.serverTimestamp=function(){return SERVER_TIMESTAMP};exports.set=set;exports.setPriority=
function(ref,priority){ref=(0,_util.getModularInstance)(ref);validateWritablePath("setPriority",ref._path);validatePriority("setPriority",priority,!1);const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,pathChild(ref._path,".priority"),priority,null,deferred.wrapCallback(()=>{}));return deferred.promise};exports.setWithPriority=function(ref,value,priority){validateWritablePath("setWithPriority",ref._path);validateFirebaseDataArg("setWithPriority",value,ref._path,!1);validatePriority("setWithPriority",
priority,!1);if(".length"===ref.key||".keys"===ref.key)throw"setWithPriority failed: "+ref.key+" is a read-only object.";const deferred=new _util.Deferred;repoSetWithPriority(ref._repo,ref._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise};exports.startAfter=function(value,key){validateKey("startAfter","key",key,!0);return new QueryStartAfterConstraint(value,key)};exports.startAt=function(value=null,key){validateKey("startAt","key",key,!0);return new QueryStartAtConstraint(value,
key)};exports.update=function(ref,values){validateFirebaseMergeDataArg("update",values,ref._path,!1);const deferred=new _util.Deferred;repoUpdate(ref._repo,ref._path,values,deferred.wrapCallback(()=>{}));return deferred.promise};exports._validateWritablePath=exports._validatePathString=exports._TEST_ACCESS_hijackHash=exports._TEST_ACCESS_forceRestClient=exports._ReferenceImpl=exports._QueryParams=exports._QueryImpl=exports.TransactionResult=exports.QueryConstraint=exports.OnDisconnect=exports.Database=
exports.DataSnapshot=void 0;var _app=require("module$node_modules$$firebase$app$dist$esm$index_esm2017"),_component=require("module$node_modules$$firebase$component$dist$esm$index_esm2017"),_util=require("module$node_modules$$firebase$util$dist$index_esm2017"),_logger=require("module$node_modules$$firebase$logger$dist$index_cjs");let SDK_VERSION="";class DOMStorageWrapper{constructor(domStorage_){this.domStorage_=domStorage_;this.prefix_="firebase:"}set(key,value){null==value?this.domStorage_.removeItem(this.prefixedName_(key)):
this.domStorage_.setItem(this.prefixedName_(key),(0,_util.stringify)(value))}get(key){key=this.domStorage_.getItem(this.prefixedName_(key));return null==key?null:(0,_util.jsonEval)(key)}remove(key){this.domStorage_.removeItem(this.prefixedName_(key))}prefixedName_(name){return this.prefix_+name}toString(){return this.domStorage_.toString()}}class MemoryStorage{constructor(){this.cache_={};this.isInMemoryStorage=!0}set(key,value){null==value?delete this.cache_[key]:this.cache_[key]=value}get(key){return(0,_util.contains)(this.cache_,
key)?this.cache_[key]:null}remove(key){delete this.cache_[key]}}const createStoragefor=function(domStorageName){try{if("undefined"!==typeof window&&"undefined"!==typeof window[domStorageName]){const domStorage=window[domStorageName];domStorage.setItem("firebase:sentinel","cache");domStorage.removeItem("firebase:sentinel");return new DOMStorageWrapper(domStorage)}}catch(e){}return new MemoryStorage},PersistentStorage=createStoragefor("localStorage"),SessionStorage=createStoragefor("sessionStorage"),
logClient=new _logger.Logger("@firebase/database"),LUIDGenerator=function(){let id=1;return function(){return id++}}(),sha1=function(str){str=(0,_util.stringToByteArray)(str);const sha1=new _util.Sha1;sha1.update(str);str=sha1.digest();return _util.base64.encodeByteArray(str)},buildLogMessage_=function(...varArgs){let message="";for(let i=0;i<varArgs.length;i++){const arg=varArgs[i];message=Array.isArray(arg)||arg&&"object"===typeof arg&&"number"===typeof arg.length?message+buildLogMessage_.apply(null,
arg):"object"===typeof arg?message+(0,_util.stringify)(arg):message+arg;message+=" "}return message};let logger$jscomp$0=null,firstLog_=!0;const enableLogging$1=function(logger_,persistent){(0,_util.assert)(!persistent||!0===logger_||!1===logger_,"Can't turn on custom loggers persistently.");!0===logger_?(logClient.logLevel=_logger.LogLevel.VERBOSE,logger$jscomp$0=logClient.log.bind(logClient),persistent&&SessionStorage.set("logging_enabled",!0)):"function"===typeof logger_?logger$jscomp$0=logger_:
(logger$jscomp$0=null,SessionStorage.remove("logging_enabled"))},log=function(...varArgs){!0===firstLog_&&(firstLog_=!1,null===logger$jscomp$0&&!0===SessionStorage.get("logging_enabled")&&enableLogging$1(!0));logger$jscomp$0&&(varArgs=buildLogMessage_.apply(null,varArgs),logger$jscomp$0(varArgs))},logWrapper=function(prefix){return function(...varArgs){log(prefix,...varArgs)}},error$jscomp$0=function(...varArgs){varArgs="FIREBASE INTERNAL ERROR: "+buildLogMessage_(...varArgs);logClient.error(varArgs)},
fatal=function(...varArgs){varArgs=`FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;logClient.error(varArgs);throw Error(varArgs);},warn=function(...varArgs){varArgs="FIREBASE WARNING: "+buildLogMessage_(...varArgs);logClient.warn(varArgs)},isInvalidJSONNumber=function(data){return"number"===typeof data&&(data!==data||data===Number.POSITIVE_INFINITY||data===Number.NEGATIVE_INFINITY)},executeWhenDOMReady=function(fn){if((0,_util.isNodeSdk)()||"complete"===document.readyState)fn();else{let called=
!1;const wrappedFn=function(){document.body?called||(called=!0,fn()):setTimeout(wrappedFn,10)};document.addEventListener?(document.addEventListener("DOMContentLoaded",wrappedFn,!1),window.addEventListener("load",wrappedFn,!1)):document.attachEvent&&(document.attachEvent("onreadystatechange",()=>{"complete"===document.readyState&&wrappedFn()}),window.attachEvent("onload",wrappedFn))}},nameCompare=function(a,b){if(a===b)return 0;if("[MIN_NAME]"===a||"[MAX_NAME]"===b)return-1;if("[MIN_NAME]"===b||"[MAX_NAME]"===
a)return 1;const aAsInt=tryParseInt(a),bAsInt=tryParseInt(b);return null!==aAsInt?null!==bAsInt?0===aAsInt-bAsInt?a.length-b.length:aAsInt-bAsInt:-1:null!==bAsInt?1:a<b?-1:1},stringCompare=function(a,b){return a===b?0:a<b?-1:1},requireKey=function(key,obj){if(obj&&key in obj)return obj[key];throw Error("Missing required key ("+key+") in object: "+(0,_util.stringify)(obj));},ObjectToUniqueKey=function(obj){if("object"!==typeof obj||null===obj)return(0,_util.stringify)(obj);const keys=[];for(var k in obj)keys.push(k);
keys.sort();k="{";for(let i=0;i<keys.length;i++)0!==i&&(k+=","),k+=(0,_util.stringify)(keys[i]),k+=":",k+=ObjectToUniqueKey(obj[keys[i]]);return k+"}"},splitStringBySize=function(str,segsize){const len=str.length;if(len<=segsize)return[str];const dataSegs=[];for(let c=0;c<len;c+=segsize)c+segsize>len?dataSegs.push(str.substring(c,len)):dataSegs.push(str.substring(c,c+segsize));return dataSegs},doubleToIEEE754String=function(v){(0,_util.assert)(!isInvalidJSONNumber(v),"Invalid JSON number");var e;
if(0===v){var f=e=0;var s=-Infinity===1/v?1:0}else s=0>v,v=Math.abs(v),v>=Math.pow(2,-1022)?(f=Math.min(Math.floor(Math.log(v)/Math.LN2),1023),e=f+1023,f=Math.round(v*Math.pow(2,52-f)-Math.pow(2,52))):(e=0,f=Math.round(v/Math.pow(2,-1074)));const bits=[];for(v=52;v;--v)bits.push(f%2?1:0),f=Math.floor(f/2);for(v=11;v;--v)bits.push(e%2?1:0),e=Math.floor(e/2);bits.push(s?1:0);bits.reverse();s=bits.join("");e="";for(v=0;64>v;v+=8)f=parseInt(s.substr(v,8),2).toString(16),1===f.length&&(f="0"+f),e+=f;return e.toLowerCase()},
INTEGER_REGEXP_=RegExp("^-?(0*)\\d{1,10}$"),tryParseInt=function(str){return INTEGER_REGEXP_.test(str)&&(str=Number(str),-2147483648<=str&&2147483647>=str)?str:null},exceptionGuard=function(fn){try{fn()}catch(e){setTimeout(()=>{warn("Exception was thrown by user callback.",e.stack||"");throw e;},0)}},setTimeoutNonBlocking=function(fn,time){fn=setTimeout(fn,time);"object"===typeof fn&&fn.unref&&fn.unref();return fn};class AppCheckTokenProvider{constructor(appName_,appCheckProvider){this.appName_=appName_;
this.appCheckProvider=appCheckProvider;(this.appCheck=null===appCheckProvider||void 0===appCheckProvider?void 0:appCheckProvider.getImmediate({optional:!0}))||(null===appCheckProvider||void 0===appCheckProvider?void 0:appCheckProvider.get().then(appCheck=>this.appCheck=appCheck))}getToken(forceRefresh){return this.appCheck?this.appCheck.getToken(forceRefresh):new Promise((resolve,reject)=>{setTimeout(()=>{this.appCheck?this.getToken(forceRefresh).then(resolve,reject):resolve(null)},0)})}addTokenChangeListener(listener){var _a;
null===(_a=this.appCheckProvider)||void 0===_a?void 0:_a.get().then(appCheck=>appCheck.addTokenListener(listener))}notifyForInvalidToken(){warn(`Provided AppCheck credentials for the app named "${this.appName_}" `+"are invalid. This usually indicates your app was not initialized correctly.")}}class FirebaseAuthTokenProvider{constructor(appName_,firebaseOptions_,authProvider_){this.appName_=appName_;this.firebaseOptions_=firebaseOptions_;this.authProvider_=authProvider_;this.auth_=null;this.auth_=
authProvider_.getImmediate({optional:!0});if(!this.auth_)authProvider_.onInit(auth=>this.auth_=auth)}getToken(forceRefresh){return this.auth_?this.auth_.getToken(forceRefresh).catch(error=>error&&"auth/token-not-initialized"===error.code?(log("Got auth/token-not-initialized error.  Treating as null token."),null):Promise.reject(error)):new Promise((resolve,reject)=>{setTimeout(()=>{this.auth_?this.getToken(forceRefresh).then(resolve,reject):resolve(null)},0)})}addTokenChangeListener(listener){this.auth_?
this.auth_.addAuthTokenListener(listener):this.authProvider_.get().then(auth=>auth.addAuthTokenListener(listener))}removeTokenChangeListener(listener){this.authProvider_.get().then(auth=>auth.removeAuthTokenListener(listener))}notifyForInvalidToken(){let errorMessage='Provided authentication credentials for the app named "'+this.appName_+'" are invalid. This usually indicates your app was not initialized correctly. ';errorMessage="credential"in this.firebaseOptions_?errorMessage+'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':
"serviceAccount"in this.firebaseOptions_?errorMessage+'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.':errorMessage+'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';warn(errorMessage)}}class EmulatorTokenProvider{constructor(accessToken){this.accessToken=accessToken}getToken(forceRefresh){return Promise.resolve({accessToken:this.accessToken})}addTokenChangeListener(listener){listener(this.accessToken)}removeTokenChangeListener(listener){}notifyForInvalidToken(){}}
EmulatorTokenProvider.OWNER="owner";const FORGE_DOMAIN_RE=/(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;class RepoInfo{constructor(host,secure,namespace,webSocketOnly,nodeAdmin=!1,persistenceKey="",includeNamespaceInQueryParams=!1){this.secure=secure;this.namespace=namespace;this.webSocketOnly=webSocketOnly;this.nodeAdmin=nodeAdmin;this.persistenceKey=persistenceKey;this.includeNamespaceInQueryParams=includeNamespaceInQueryParams;this._host=host.toLowerCase();this._domain=
this._host.substr(this._host.indexOf(".")+1);this.internalHost=PersistentStorage.get("host:"+host)||this._host}isCacheableHost(){return"s-"===this.internalHost.substr(0,2)}isCustomHost(){return"firebaseio.com"!==this._domain&&"firebaseio-demo.com"!==this._domain}get host(){return this._host}set host(newHost){newHost!==this.internalHost&&(this.internalHost=newHost,this.isCacheableHost()&&PersistentStorage.set("host:"+this._host,this.internalHost))}toString(){let str=this.toURLString();this.persistenceKey&&
(str+="\x3c"+this.persistenceKey+"\x3e");return str}toURLString(){return`${this.secure?"https://":"http://"}${this.host}/${this.includeNamespaceInQueryParams?`?ns=${this.namespace}`:""}`}}class StatsCollection{constructor(){this.counters_={}}incrementCounter(name,amount=1){(0,_util.contains)(this.counters_,name)||(this.counters_[name]=0);this.counters_[name]+=amount}get(){return(0,_util.deepCopy)(this.counters_)}}const collections={},reporters={};class PacketReceiver{constructor(onMessage_){this.onMessage_=
onMessage_;this.pendingResponses=[];this.currentResponseNum=0;this.closeAfterResponse=-1;this.onClose=null}closeAfter(responseNum,callback){this.closeAfterResponse=responseNum;this.onClose=callback;this.closeAfterResponse<this.currentResponseNum&&(this.onClose(),this.onClose=null)}handleResponse(requestNum,data){for(this.pendingResponses[requestNum]=data;this.pendingResponses[this.currentResponseNum];){const toProcess=this.pendingResponses[this.currentResponseNum];delete this.pendingResponses[this.currentResponseNum];
for(let i=0;i<toProcess.length;++i)toProcess[i]&&exceptionGuard(()=>{this.onMessage_(toProcess[i])});if(this.currentResponseNum===this.closeAfterResponse){this.onClose&&(this.onClose(),this.onClose=null);break}this.currentResponseNum++}}}class BrowserPollConnection{constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.repoInfo=repoInfo;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.transportSessionId=
transportSessionId;this.lastSessionId=lastSessionId;this.bytesReceived=this.bytesSent=0;this.everConnected_=!1;this.log_=logWrapper(connId);this.stats_=statsManagerGetCollection(repoInfo);this.urlFn=params=>{this.appCheckToken&&(params.ac=this.appCheckToken);return repoInfoConnectionURL(repoInfo,"long_polling",params)}}open(onMessage,onDisconnect){this.curSegmentNum=0;this.onDisconnect_=onDisconnect;this.myPacketOrderer=new PacketReceiver(onMessage);this.isClosed_=!1;this.connectTimeoutTimer_=setTimeout(()=>
{this.log_("Timed out trying to connect.");this.onClosed_();this.connectTimeoutTimer_=null},3E4);executeWhenDOMReady(()=>{if(!this.isClosed_){this.scriptTagHolder=new FirebaseIFrameScriptHolder((...args)=>{const [command,arg1,arg2]=args;this.incrementIncomingBytes_(args);if(this.scriptTagHolder)if(this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null),this.everConnected_=!0,"start"===command)this.id=arg1,this.password=arg2;else if("close"===command)if(arg1)this.scriptTagHolder.sendNewPolls=
!1,this.myPacketOrderer.closeAfter(arg1,()=>{this.onClosed_()});else this.onClosed_();else throw Error("Unrecognized command received: "+command);},(...args)=>{const [pN,data]=args;this.incrementIncomingBytes_(args);this.myPacketOrderer.handleResponse(pN,data)},()=>{this.onClosed_()},this.urlFn);var urlParams={start:"t"};urlParams.ser=Math.floor(1E8*Math.random());this.scriptTagHolder.uniqueCallbackIdentifier&&(urlParams.cb=this.scriptTagHolder.uniqueCallbackIdentifier);urlParams.v="5";this.transportSessionId&&
(urlParams.s=this.transportSessionId);this.lastSessionId&&(urlParams.ls=this.lastSessionId);this.applicationId&&(urlParams.p=this.applicationId);this.appCheckToken&&(urlParams.ac=this.appCheckToken);"undefined"!==typeof location&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)&&(urlParams.r="f");urlParams=this.urlFn(urlParams);this.log_("Connecting via long-poll to "+urlParams);this.scriptTagHolder.addTag(urlParams,()=>{})}})}start(){this.scriptTagHolder.startLongPoll(this.id,this.password);
this.addDisconnectPingFrame(this.id,this.password)}static forceAllow(){BrowserPollConnection.forceAllow_=!0}static forceDisallow(){BrowserPollConnection.forceDisallow_=!0}static isAvailable(){return(0,_util.isNodeSdk)()?!1:BrowserPollConnection.forceAllow_?!0:!BrowserPollConnection.forceDisallow_&&"undefined"!==typeof document&&null!=document.createElement&&!("object"===typeof window&&window.chrome&&window.chrome.extension&&!/^chrome/.test(window.location.href))&&!("object"===typeof Windows&&"object"===
typeof Windows.UI)}markConnectionHealthy(){}shutdown_(){this.isClosed_=!0;this.scriptTagHolder&&(this.scriptTagHolder.close(),this.scriptTagHolder=null);this.myDisconnFrame&&(document.body.removeChild(this.myDisconnFrame),this.myDisconnFrame=null);this.connectTimeoutTimer_&&(clearTimeout(this.connectTimeoutTimer_),this.connectTimeoutTimer_=null)}onClosed_(){this.isClosed_||(this.log_("Longpoll is closing itself"),this.shutdown_(),this.onDisconnect_&&(this.onDisconnect_(this.everConnected_),this.onDisconnect_=
null))}close(){this.isClosed_||(this.log_("Longpoll is being closed."),this.shutdown_())}send(data){data=(0,_util.stringify)(data);this.bytesSent+=data.length;this.stats_.incrementCounter("bytes_sent",data.length);data=(0,_util.base64Encode)(data);data=splitStringBySize(data,1840);for(let i=0;i<data.length;i++)this.scriptTagHolder.enqueueSegment(this.curSegmentNum,data.length,data[i]),this.curSegmentNum++}addDisconnectPingFrame(id,pw){if(!(0,_util.isNodeSdk)()){this.myDisconnFrame=document.createElement("iframe");
var urlParams={dframe:"t"};urlParams.id=id;urlParams.pw=pw;this.myDisconnFrame.src=this.urlFn(urlParams);this.myDisconnFrame.style.display="none";document.body.appendChild(this.myDisconnFrame)}}incrementIncomingBytes_(args){args=(0,_util.stringify)(args).length;this.bytesReceived+=args;this.stats_.incrementCounter("bytes_received",args)}}class FirebaseIFrameScriptHolder{constructor(commandCB,onMessageCB,onDisconnect,urlFn){this.onDisconnect=onDisconnect;this.urlFn=urlFn;this.outstandingRequests=new Set;
this.pendingSegs=[];this.currentSerial=Math.floor(1E8*Math.random());this.sendNewPolls=!0;if((0,_util.isNodeSdk)())this.commandCB=commandCB,this.onMessageCB=onMessageCB;else{this.uniqueCallbackIdentifier=LUIDGenerator();window["pLPCommand"+this.uniqueCallbackIdentifier]=commandCB;window["pRTLPCB"+this.uniqueCallbackIdentifier]=onMessageCB;this.myIFrame=FirebaseIFrameScriptHolder.createIFrame_();commandCB="";this.myIFrame.src&&"javascript:"===this.myIFrame.src.substr(0,11)&&(commandCB='\x3cscript\x3edocument.domain\x3d"'+
document.domain+'";\x3c/script\x3e');commandCB="\x3chtml\x3e\x3cbody\x3e"+commandCB+"\x3c/body\x3e\x3c/html\x3e";try{this.myIFrame.doc.open(),this.myIFrame.doc.write(commandCB),this.myIFrame.doc.close()}catch(e){log("frame writing exception"),e.stack&&log(e.stack),log(e)}}}static createIFrame_(){const iframe=document.createElement("iframe");iframe.style.display="none";if(document.body){document.body.appendChild(iframe);try{iframe.contentWindow.document||log("No IE domain setting required")}catch(e){iframe.src=
"javascript:void((function(){document.open();document.domain\x3d'"+document.domain+"';document.close();})())"}}else throw"Document body has not initialized. Wait to initialize Firebase until after the document is ready.";iframe.contentDocument?iframe.doc=iframe.contentDocument:iframe.contentWindow?iframe.doc=iframe.contentWindow.document:iframe.document&&(iframe.doc=iframe.document);return iframe}close(){this.alive=!1;this.myIFrame&&(this.myIFrame.doc.body.innerHTML="",setTimeout(()=>{null!==this.myIFrame&&
(document.body.removeChild(this.myIFrame),this.myIFrame=null)},0));const onDisconnect=this.onDisconnect;onDisconnect&&(this.onDisconnect=null,onDisconnect())}startLongPoll(id,pw){this.myID=id;this.myPW=pw;for(this.alive=!0;this.newRequest_(););}newRequest_(){if(this.alive&&this.sendNewPolls&&this.outstandingRequests.size<(0<this.pendingSegs.length?2:1)){this.currentSerial++;var urlParams={};urlParams.id=this.myID;urlParams.pw=this.myPW;urlParams.ser=this.currentSerial;urlParams=this.urlFn(urlParams);
let curDataString="",i=0;for(;0<this.pendingSegs.length;)if(1870>=this.pendingSegs[0].d.length+30+curDataString.length){const theSeg=this.pendingSegs.shift();curDataString=curDataString+"\x26seg"+i+"\x3d"+theSeg.seg+"\x26ts"+i+"\x3d"+theSeg.ts+"\x26d"+i+"\x3d"+theSeg.d;i++}else break;this.addLongPollTag_(urlParams+curDataString,this.currentSerial);return!0}return!1}enqueueSegment(segnum,totalsegs,data){this.pendingSegs.push({seg:segnum,ts:totalsegs,d:data});this.alive&&this.newRequest_()}addLongPollTag_(url,
serial){this.outstandingRequests.add(serial);const doNewRequest=()=>{this.outstandingRequests.delete(serial);this.newRequest_()},keepaliveTimeout=setTimeout(doNewRequest,25E3);this.addTag(url,()=>{clearTimeout(keepaliveTimeout);doNewRequest()})}addTag(url,loadCB){(0,_util.isNodeSdk)()?this.doNodeLongPoll(url,loadCB):setTimeout(()=>{try{if(this.sendNewPolls){var newScript=this.myIFrame.doc.createElement("script");newScript.type="text/javascript";newScript.async=!0;newScript.src=url;newScript.onload=
newScript.onreadystatechange=function(){const rstate=newScript.readyState;rstate&&"loaded"!==rstate&&"complete"!==rstate||(newScript.onload=newScript.onreadystatechange=null,newScript.parentNode&&newScript.parentNode.removeChild(newScript),loadCB())};newScript.onerror=()=>{log("Long-poll script failed to load: "+url);this.sendNewPolls=!1;this.close()};this.myIFrame.doc.body.appendChild(newScript)}}catch(e){}},1)}}let WebSocketImpl=null;"undefined"!==typeof MozWebSocket?WebSocketImpl=MozWebSocket:
"undefined"!==typeof WebSocket&&(WebSocketImpl=WebSocket);class WebSocketConnection{constructor(connId,repoInfo,applicationId,appCheckToken,authToken,transportSessionId,lastSessionId){this.connId=connId;this.applicationId=applicationId;this.appCheckToken=appCheckToken;this.authToken=authToken;this.frames=this.keepaliveTimer=null;this.bytesReceived=this.bytesSent=this.totalFrames=0;this.log_=logWrapper(this.connId);this.stats_=statsManagerGetCollection(repoInfo);this.connURL=WebSocketConnection.connectionURL_(repoInfo,
transportSessionId,lastSessionId,appCheckToken);this.nodeAdmin=repoInfo.nodeAdmin}static connectionURL_(repoInfo,transportSessionId,lastSessionId,appCheckToken){const urlParams={v:"5"};!(0,_util.isNodeSdk)()&&"undefined"!==typeof location&&location.hostname&&FORGE_DOMAIN_RE.test(location.hostname)&&(urlParams.r="f");transportSessionId&&(urlParams.s=transportSessionId);lastSessionId&&(urlParams.ls=lastSessionId);appCheckToken&&(urlParams.ac=appCheckToken);return repoInfoConnectionURL(repoInfo,"websocket",
urlParams)}open(onMessage,onDisconnect){this.onDisconnect=onDisconnect;this.onMessage=onMessage;this.log_("Websocket connecting to "+this.connURL);this.everConnected_=!1;PersistentStorage.set("previous_websocket_failure",!0);try{if((0,_util.isNodeSdk)()){const options={headers:{"User-Agent":`Firebase/${"5"}/${SDK_VERSION}/${process.platform}/${this.nodeAdmin?"AdminNode":"Node"}`,"X-Firebase-GMPID":this.applicationId||""}};this.authToken&&(options.headers.Authorization=`Bearer ${this.authToken}`);
this.appCheckToken&&(options.headers["X-Firebase-AppCheck"]=this.appCheckToken);const env=process.env,proxy=0===this.connURL.indexOf("wss://")?env.HTTPS_PROXY||env.https_proxy:env.HTTP_PROXY||env.http_proxy;proxy&&(options.proxy={origin:proxy});this.mySock=new WebSocketImpl(this.connURL,[],options)}else this.mySock=new WebSocketImpl(this.connURL,[],{headers:{"X-Firebase-GMPID":this.applicationId||"","X-Firebase-AppCheck":this.appCheckToken||""}})}catch(e){this.log_("Error instantiating WebSocket.");
(onMessage=e.message||e.data)&&this.log_(onMessage);this.onClosed_();return}this.mySock.onopen=()=>{this.log_("Websocket connected.");this.everConnected_=!0};this.mySock.onclose=()=>{this.log_("Websocket connection was disconnected.");this.mySock=null;this.onClosed_()};this.mySock.onmessage=m=>{this.handleIncomingFrame(m)};this.mySock.onerror=e=>{this.log_("WebSocket error.  Closing connection.");(e=e.message||e.data)&&this.log_(e);this.onClosed_()}}start(){}static forceDisallow(){WebSocketConnection.forceDisallow_=
!0}static isAvailable(){let isOldAndroid=!1;if("undefined"!==typeof navigator&&navigator.userAgent){const oldAndroidMatch=navigator.userAgent.match(/Android ([0-9]{0,}\.[0-9]{0,})/);oldAndroidMatch&&1<oldAndroidMatch.length&&4.4>parseFloat(oldAndroidMatch[1])&&(isOldAndroid=!0)}return!isOldAndroid&&null!==WebSocketImpl&&!WebSocketConnection.forceDisallow_}static previouslyFailed(){return PersistentStorage.isInMemoryStorage||!0===PersistentStorage.get("previous_websocket_failure")}markConnectionHealthy(){PersistentStorage.remove("previous_websocket_failure")}appendFrame_(data){this.frames.push(data);
this.frames.length===this.totalFrames&&(data=this.frames.join(""),this.frames=null,data=(0,_util.jsonEval)(data),this.onMessage(data))}handleNewFrameCount_(frameCount){this.totalFrames=frameCount;this.frames=[]}extractFrameCount_(data){(0,_util.assert)(null===this.frames,"We already have a frame buffer");if(6>=data.length){const frameCount=Number(data);if(!isNaN(frameCount))return this.handleNewFrameCount_(frameCount),null}this.handleNewFrameCount_(1);return data}handleIncomingFrame(mess){null!==
this.mySock&&(mess=mess.data,this.bytesReceived+=mess.length,this.stats_.incrementCounter("bytes_received",mess.length),this.resetKeepAlive(),null!==this.frames?this.appendFrame_(mess):(mess=this.extractFrameCount_(mess),null!==mess&&this.appendFrame_(mess)))}send(data){this.resetKeepAlive();data=(0,_util.stringify)(data);this.bytesSent+=data.length;this.stats_.incrementCounter("bytes_sent",data.length);data=splitStringBySize(data,16384);1<data.length&&this.sendString_(String(data.length));for(let i=
0;i<data.length;i++)this.sendString_(data[i])}shutdown_(){this.isClosed_=!0;this.keepaliveTimer&&(clearInterval(this.keepaliveTimer),this.keepaliveTimer=null);this.mySock&&(this.mySock.close(),this.mySock=null)}onClosed_(){this.isClosed_||(this.log_("WebSocket is closing itself"),this.shutdown_(),this.onDisconnect&&(this.onDisconnect(this.everConnected_),this.onDisconnect=null))}close(){this.isClosed_||(this.log_("WebSocket is being closed"),this.shutdown_())}resetKeepAlive(){clearInterval(this.keepaliveTimer);
this.keepaliveTimer=setInterval(()=>{this.mySock&&this.sendString_("0");this.resetKeepAlive()},45E3)}sendString_(str){try{this.mySock.send(str)}catch(e){this.log_("Exception thrown from WebSocket.send():",e.message||e.data,"Closing connection."),setTimeout(this.onClosed_.bind(this),0)}}}WebSocketConnection.responsesRequiredToBeHealthy=2;WebSocketConnection.healthyTimeout=3E4;class TransportManager{constructor(repoInfo){this.initTransports_(repoInfo)}static get ALL_TRANSPORTS(){return[BrowserPollConnection,
WebSocketConnection]}initTransports_(repoInfo){const isWebSocketsAvailable=WebSocketConnection&&WebSocketConnection.isAvailable();let isSkipPollConnection=isWebSocketsAvailable&&!WebSocketConnection.previouslyFailed();repoInfo.webSocketOnly&&(isWebSocketsAvailable||warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway."),isSkipPollConnection=!0);if(isSkipPollConnection)this.transports_=[WebSocketConnection];else{repoInfo=this.transports_=[];for(const transport of TransportManager.ALL_TRANSPORTS)transport&&
transport.isAvailable()&&repoInfo.push(transport)}}initialTransport(){if(0<this.transports_.length)return this.transports_[0];throw Error("No transports available");}upgradeTransport(){return 1<this.transports_.length?this.transports_[1]:null}}class Connection{constructor(id,repoInfo_,applicationId_,appCheckToken_,authToken_,onMessage_,onReady_,onDisconnect_,onKill_,lastSessionId){this.id=id;this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.appCheckToken_=appCheckToken_;this.authToken_=
authToken_;this.onMessage_=onMessage_;this.onReady_=onReady_;this.onDisconnect_=onDisconnect_;this.onKill_=onKill_;this.lastSessionId=lastSessionId;this.connectionCount=0;this.pendingDataMessages=[];this.state_=0;this.log_=logWrapper("c:"+this.id+":");this.transportManager_=new TransportManager(repoInfo_);this.log_("Connection created");this.start_()}start_(){var conn=this.transportManager_.initialTransport();this.conn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,
this.authToken_,null,this.lastSessionId);this.primaryResponsesRequired_=conn.responsesRequiredToBeHealthy||0;const onMessageReceived=this.connReceiver_(this.conn_),onConnectionLost=this.disconnReceiver_(this.conn_);this.rx_=this.tx_=this.conn_;this.secondaryConn_=null;this.isHealthy_=!1;setTimeout(()=>{this.conn_&&this.conn_.open(onMessageReceived,onConnectionLost)},0);conn=conn.healthyTimeout||0;0<conn&&(this.healthyTimeout_=setTimeoutNonBlocking(()=>{this.healthyTimeout_=null;this.isHealthy_||(this.conn_&&
102400<this.conn_.bytesReceived?(this.log_("Connection exceeded healthy timeout but has received "+this.conn_.bytesReceived+" bytes.  Marking connection healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()):this.conn_&&10240<this.conn_.bytesSent?this.log_("Connection exceeded healthy timeout but has sent "+this.conn_.bytesSent+" bytes.  Leaving connection alive."):(this.log_("Closing unhealthy connection after timeout."),this.close()))},Math.floor(conn)))}nextTransportId_(){return"c:"+
this.id+":"+this.connectionCount++}disconnReceiver_(conn){return everConnected=>{if(conn===this.conn_)this.onConnectionLost_(everConnected);else conn===this.secondaryConn_?(this.log_("Secondary connection lost."),this.onSecondaryConnectionLost_()):this.log_("closing an old connection")}}connReceiver_(conn){return message=>{if(2!==this.state_)if(conn===this.rx_)this.onPrimaryMessageReceived_(message);else if(conn===this.secondaryConn_)this.onSecondaryMessageReceived_(message);else this.log_("message on old connection")}}sendRequest(dataMsg){this.sendData_({t:"d",
d:dataMsg})}tryCleanupConnection(){this.tx_===this.secondaryConn_&&this.rx_===this.secondaryConn_&&(this.log_("cleaning up and promoting a connection: "+this.secondaryConn_.connId),this.conn_=this.secondaryConn_,this.secondaryConn_=null)}onSecondaryControl_(controlData){"t"in controlData&&(controlData=controlData.t,"a"===controlData?this.upgradeIfSecondaryHealthy_():"r"===controlData?(this.log_("Got a reset on secondary, closing it"),this.secondaryConn_.close(),this.tx_!==this.secondaryConn_&&this.rx_!==
this.secondaryConn_||this.close()):"o"===controlData&&(this.log_("got pong on secondary."),this.secondaryResponsesRequired_--,this.upgradeIfSecondaryHealthy_()))}onSecondaryMessageReceived_(parsedData){const layer=requireKey("t",parsedData);parsedData=requireKey("d",parsedData);if("c"===layer)this.onSecondaryControl_(parsedData);else if("d"===layer)this.pendingDataMessages.push(parsedData);else throw Error("Unknown protocol layer: "+layer);}upgradeIfSecondaryHealthy_(){0>=this.secondaryResponsesRequired_?
(this.log_("Secondary connection is healthy."),this.isHealthy_=!0,this.secondaryConn_.markConnectionHealthy(),this.proceedWithUpgrade_()):(this.log_("sending ping on secondary."),this.secondaryConn_.send({t:"c",d:{t:"p",d:{}}}))}proceedWithUpgrade_(){this.secondaryConn_.start();this.log_("sending client ack on secondary");this.secondaryConn_.send({t:"c",d:{t:"a",d:{}}});this.log_("Ending transmission on primary");this.conn_.send({t:"c",d:{t:"n",d:{}}});this.tx_=this.secondaryConn_;this.tryCleanupConnection()}onPrimaryMessageReceived_(parsedData){const layer=
requireKey("t",parsedData);parsedData=requireKey("d",parsedData);if("c"===layer)this.onControl_(parsedData);else if("d"===layer)this.onDataMessage_(parsedData)}onDataMessage_(message){this.onPrimaryResponse_();this.onMessage_(message)}onPrimaryResponse_(){this.isHealthy_||(this.primaryResponsesRequired_--,0>=this.primaryResponsesRequired_&&(this.log_("Primary connection is healthy."),this.isHealthy_=!0,this.conn_.markConnectionHealthy()))}onControl_(controlData){var cmd=requireKey("t",controlData);
if("d"in controlData)if(controlData=controlData.d,"h"===cmd)this.onHandshake_(controlData);else if("n"===cmd){this.log_("recvd end transmission on primary");this.rx_=this.secondaryConn_;for(cmd=0;cmd<this.pendingDataMessages.length;++cmd)this.onDataMessage_(this.pendingDataMessages[cmd]);this.pendingDataMessages=[];this.tryCleanupConnection()}else if("s"===cmd)this.onConnectionShutdown_(controlData);else if("r"===cmd)this.onReset_(controlData);else"e"===cmd?error$jscomp$0("Server Error: "+controlData):
"o"===cmd?(this.log_("got pong on primary."),this.onPrimaryResponse_(),this.sendPingOnPrimaryIfNecessary_()):error$jscomp$0("Unknown control packet command: "+cmd)}onHandshake_(handshake){const timestamp=handshake.ts,version=handshake.v,host=handshake.h;this.sessionId=handshake.s;this.repoInfo_.host=host;0===this.state_&&(this.conn_.start(),this.onConnectionEstablished_(this.conn_,timestamp),"5"!==version&&warn("Protocol version mismatch detected"),this.tryStartUpgrade_())}tryStartUpgrade_(){const conn=
this.transportManager_.upgradeTransport();conn&&this.startUpgrade_(conn)}startUpgrade_(conn){this.secondaryConn_=new conn(this.nextTransportId_(),this.repoInfo_,this.applicationId_,this.appCheckToken_,this.authToken_,this.sessionId);this.secondaryResponsesRequired_=conn.responsesRequiredToBeHealthy||0;conn=this.connReceiver_(this.secondaryConn_);const onDisconnect=this.disconnReceiver_(this.secondaryConn_);this.secondaryConn_.open(conn,onDisconnect);setTimeoutNonBlocking(()=>{this.secondaryConn_&&
(this.log_("Timed out trying to upgrade."),this.secondaryConn_.close())},6E4)}onReset_(host){this.log_("Reset packet received.  New host: "+host);this.repoInfo_.host=host;1===this.state_?this.close():(this.closeConnections_(),this.start_())}onConnectionEstablished_(conn,timestamp){this.log_("Realtime connection established.");this.conn_=conn;this.state_=1;this.onReady_&&(this.onReady_(timestamp,this.sessionId),this.onReady_=null);0===this.primaryResponsesRequired_?(this.log_("Primary connection is healthy."),
this.isHealthy_=!0):setTimeoutNonBlocking(()=>{this.sendPingOnPrimaryIfNecessary_()},5E3)}sendPingOnPrimaryIfNecessary_(){this.isHealthy_||1!==this.state_||(this.log_("sending ping on primary."),this.sendData_({t:"c",d:{t:"p",d:{}}}))}onSecondaryConnectionLost_(){const conn=this.secondaryConn_;this.secondaryConn_=null;this.tx_!==conn&&this.rx_!==conn||this.close()}onConnectionLost_(everConnected){this.conn_=null;everConnected||0!==this.state_?1===this.state_&&this.log_("Realtime connection lost."):
(this.log_("Realtime connection failed."),this.repoInfo_.isCacheableHost()&&(PersistentStorage.remove("host:"+this.repoInfo_.host),this.repoInfo_.internalHost=this.repoInfo_.host));this.close()}onConnectionShutdown_(reason){this.log_("Connection shutdown command received. Shutting down...");this.onKill_&&(this.onKill_(reason),this.onKill_=null);this.onDisconnect_=null;this.close()}sendData_(data){if(1!==this.state_)throw"Connection is not connected";this.tx_.send(data)}close(){2!==this.state_&&(this.log_("Closing realtime connection."),
this.state_=2,this.closeConnections_(),this.onDisconnect_&&(this.onDisconnect_(),this.onDisconnect_=null))}closeConnections_(){this.log_("Shutting down all connections");this.conn_&&(this.conn_.close(),this.conn_=null);this.secondaryConn_&&(this.secondaryConn_.close(),this.secondaryConn_=null);this.healthyTimeout_&&(clearTimeout(this.healthyTimeout_),this.healthyTimeout_=null)}}class ServerActions{put(pathString,data,onComplete,hash){}merge(pathString,data,onComplete,hash){}refreshAuthToken(token){}refreshAppCheckToken(token){}onDisconnectPut(pathString,
data,onComplete){}onDisconnectMerge(pathString,data,onComplete){}onDisconnectCancel(pathString,onComplete){}reportStats(stats){}}class EventEmitter{constructor(allowedEvents_){this.allowedEvents_=allowedEvents_;this.listeners_={};(0,_util.assert)(Array.isArray(allowedEvents_)&&0<allowedEvents_.length,"Requires a non-empty array")}trigger(eventType,...varArgs){if(Array.isArray(this.listeners_[eventType])){eventType=[...this.listeners_[eventType]];for(let i=0;i<eventType.length;i++)eventType[i].callback.apply(eventType[i].context,
varArgs)}}on(eventType,callback,context){this.validateEventType_(eventType);this.listeners_[eventType]=this.listeners_[eventType]||[];this.listeners_[eventType].push({callback,context});(eventType=this.getInitialEvent(eventType))&&callback.apply(context,eventType)}off(eventType,callback,context){this.validateEventType_(eventType);eventType=this.listeners_[eventType]||[];for(let i=0;i<eventType.length;i++)if(eventType[i].callback===callback&&(!context||context===eventType[i].context)){eventType.splice(i,
1);break}}validateEventType_(eventType){(0,_util.assert)(this.allowedEvents_.find(et=>et===eventType),"Unknown event: "+eventType)}}class OnlineMonitor extends EventEmitter{constructor(){super(["online"]);this.online_=!0;"undefined"===typeof window||"undefined"===typeof window.addEventListener||(0,_util.isMobileCordova)()||(window.addEventListener("online",()=>{this.online_||(this.online_=!0,this.trigger("online",!0))},!1),window.addEventListener("offline",()=>{this.online_&&(this.online_=!1,this.trigger("online",
!1))},!1))}static getInstance(){return new OnlineMonitor}getInitialEvent(eventType){(0,_util.assert)("online"===eventType,"Unknown event type: "+eventType);return[this.online_]}currentlyOnline(){return this.online_}}class Path{constructor(pathOrString,pieceNum){if(void 0===pieceNum){this.pieces_=pathOrString.split("/");pathOrString=0;for(pieceNum=0;pieceNum<this.pieces_.length;pieceNum++)0<this.pieces_[pieceNum].length&&(this.pieces_[pathOrString]=this.pieces_[pieceNum],pathOrString++);this.pieces_.length=
pathOrString;this.pieceNum_=0}else this.pieces_=pathOrString,this.pieceNum_=pieceNum}toString(){let pathString="";for(let i=this.pieceNum_;i<this.pieces_.length;i++)""!==this.pieces_[i]&&(pathString+="/"+this.pieces_[i]);return pathString||"/"}}class ValidationPath{constructor(path,errorPrefix_){this.errorPrefix_=errorPrefix_;this.parts_=pathSlice(path,0);this.byteLength_=Math.max(1,this.parts_.length);for(path=0;path<this.parts_.length;path++)this.byteLength_+=(0,_util.stringLength)(this.parts_[path]);
validationPathCheckValid(this)}}class VisibilityMonitor extends EventEmitter{constructor(){super(["visible"]);let hidden,visibilityChange;"undefined"!==typeof document&&"undefined"!==typeof document.addEventListener&&("undefined"!==typeof document.hidden?(visibilityChange="visibilitychange",hidden="hidden"):"undefined"!==typeof document.mozHidden?(visibilityChange="mozvisibilitychange",hidden="mozHidden"):"undefined"!==typeof document.msHidden?(visibilityChange="msvisibilitychange",hidden="msHidden"):
"undefined"!==typeof document.webkitHidden&&(visibilityChange="webkitvisibilitychange",hidden="webkitHidden"));this.visible_=!0;visibilityChange&&document.addEventListener(visibilityChange,()=>{const visible=!document[hidden];visible!==this.visible_&&(this.visible_=visible,this.trigger("visible",visible))},!1)}static getInstance(){return new VisibilityMonitor}getInitialEvent(eventType){(0,_util.assert)("visible"===eventType,"Unknown event type: "+eventType);return[this.visible_]}}class PersistentConnection extends ServerActions{constructor(repoInfo_,
applicationId_,onDataUpdate_,onConnectStatus_,onServerInfoUpdate_,authTokenProvider_,appCheckTokenProvider_,authOverride_){super();this.repoInfo_=repoInfo_;this.applicationId_=applicationId_;this.onDataUpdate_=onDataUpdate_;this.onConnectStatus_=onConnectStatus_;this.onServerInfoUpdate_=onServerInfoUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.authOverride_=authOverride_;this.id=PersistentConnection.nextPersistentConnectionId_++;this.log_=
logWrapper("p:"+this.id+":");this.interruptReasons_={};this.listens=new Map;this.outstandingPuts_=[];this.outstandingGets_=[];this.outstandingGetCount_=this.outstandingPutCount_=0;this.onDisconnectRequestQueue_=[];this.connected_=!1;this.reconnectDelay_=1E3;this.maxReconnectDelay_=3E5;this.establishConnectionTimer_=this.lastSessionId=this.securityDebugCallback_=null;this.visible_=!1;this.requestCBHash_={};this.requestNumber_=0;this.appCheckToken_=this.authToken_=this.realtime_=null;this.forceTokenRefresh_=
!1;this.invalidAppCheckTokenCount_=this.invalidAuthTokenCount_=0;this.firstConnection_=!0;this.lastConnectionEstablishedTime_=this.lastConnectionAttemptTime_=null;if(authOverride_&&!(0,_util.isNodeSdk)())throw Error("Auth override specified in options, but not supported on non Node.js platforms");VisibilityMonitor.getInstance().on("visible",this.onVisible_,this);if(-1===repoInfo_.host.indexOf("fblocal"))OnlineMonitor.getInstance().on("online",this.onOnline_,this)}sendRequest(action,body,onResponse){const curReqNum=
++this.requestNumber_;action={r:curReqNum,a:action,b:body};this.log_((0,_util.stringify)(action));(0,_util.assert)(this.connected_,"sendRequest call when we're not connected not allowed.");this.realtime_.sendRequest(action);onResponse&&(this.requestCBHash_[curReqNum]=onResponse)}get(query){this.initConnection_();const deferred=new _util.Deferred,request={p:query._path.toString(),q:query._queryObject},outstandingGet={action:"g",request,onComplete:message=>{const payload=message.d;"ok"===message.s?
(this.onDataUpdate_(request.p,payload,!1,null),deferred.resolve(payload)):deferred.reject(payload)}};this.outstandingGets_.push(outstandingGet);this.outstandingGetCount_++;const index=this.outstandingGets_.length-1;this.connected_||setTimeout(()=>{const get=this.outstandingGets_[index];void 0!==get&&outstandingGet===get&&(delete this.outstandingGets_[index],this.outstandingGetCount_--,0===this.outstandingGetCount_&&(this.outstandingGets_=[]),this.log_("get "+index+" timed out on connection"),deferred.reject(Error("Client is offline.")))},
3E3);this.connected_&&this.sendGet_(index);return deferred.promise}listen(query,currentHashFn,tag,onComplete){this.initConnection_();const queryId=query._queryIdentifier,pathString=query._path.toString();this.log_("Listen called for "+pathString+" "+queryId);this.listens.has(pathString)||this.listens.set(pathString,new Map);(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),"listen() called for non-default but complete query");(0,_util.assert)(!this.listens.get(pathString).has(queryId),
"listen() called twice for same path/queryId.");query={onComplete,hashFn:currentHashFn,query,tag};this.listens.get(pathString).set(queryId,query);this.connected_&&this.sendListen_(query)}sendGet_(index){const get=this.outstandingGets_[index];this.sendRequest("g",get.request,message=>{delete this.outstandingGets_[index];this.outstandingGetCount_--;0===this.outstandingGetCount_&&(this.outstandingGets_=[]);if(get.onComplete)get.onComplete(message)})}sendListen_(listenSpec){const query=listenSpec.query,
pathString=query._path.toString(),queryId=query._queryIdentifier;this.log_("Listen on "+pathString+" for "+queryId);const req={p:pathString};listenSpec.tag&&(req.q=query._queryObject,req.t=listenSpec.tag);req.h=listenSpec.hashFn();this.sendRequest("q",req,message=>{const payload=message.d,status=message.s;PersistentConnection.warnOnListenWarnings_(payload,query);if((this.listens.get(pathString)&&this.listens.get(pathString).get(queryId))===listenSpec&&(this.log_("listen response",message),"ok"!==
status&&this.removeListen_(pathString,queryId),listenSpec.onComplete))listenSpec.onComplete(status,payload)})}static warnOnListenWarnings_(payload,query){payload&&"object"===typeof payload&&(0,_util.contains)(payload,"w")&&(payload=(0,_util.safeGet)(payload,"w"),Array.isArray(payload)&&~payload.indexOf("no_index")&&(payload='".indexOn": "'+query._queryParams.getIndex().toString()+'"',warn("Using an unspecified index. Your data will be downloaded and "+`filtered on the client. Consider adding ${payload} at `+
`${query._path.toString()} to your security rules for better performance.`)))}refreshAuthToken(token){this.authToken_=token;this.log_("Auth token refreshed");this.authToken_?this.tryAuth():this.connected_&&this.sendRequest("unauth",{},()=>{});this.reduceReconnectDelayIfAdminCredential_(token)}reduceReconnectDelayIfAdminCredential_(credential){if(credential&&40===credential.length||(0,_util.isAdmin)(credential))this.log_("Admin auth credential detected.  Reducing max reconnect time."),this.maxReconnectDelay_=
3E4}refreshAppCheckToken(token){this.appCheckToken_=token;this.log_("App check token refreshed");this.appCheckToken_?this.tryAppCheck():this.connected_&&this.sendRequest("unappeck",{},()=>{})}tryAuth(){if(this.connected_&&this.authToken_){const token=this.authToken_,authMethod=(0,_util.isValidFormat)(token)?"auth":"gauth",requestData={cred:token};null===this.authOverride_?requestData.noauth=!0:"object"===typeof this.authOverride_&&(requestData.authvar=this.authOverride_);this.sendRequest(authMethod,
requestData,res=>{const status=res.s;res=res.d||"error";if(this.authToken_===token)if("ok"===status)this.invalidAuthTokenCount_=0;else this.onAuthRevoked_(status,res)})}}tryAppCheck(){this.connected_&&this.appCheckToken_&&this.sendRequest("appcheck",{token:this.appCheckToken_},res=>{const status=res.s;res=res.d||"error";if("ok"===status)this.invalidAppCheckTokenCount_=0;else this.onAppCheckRevoked_(status,res)})}unlisten(query,tag){const pathString=query._path.toString(),queryId=query._queryIdentifier;
this.log_("Unlisten called for "+pathString+" "+queryId);(0,_util.assert)(query._queryParams.isDefault()||!query._queryParams.loadsAllData(),"unlisten() called for non-default but complete query");this.removeListen_(pathString,queryId)&&this.connected_&&this.sendUnlisten_(pathString,queryId,query._queryObject,tag)}sendUnlisten_(pathString,queryId,queryObj,tag){this.log_("Unlisten on "+pathString+" for "+queryId);pathString={p:pathString};tag&&(pathString.q=queryObj,pathString.t=tag);this.sendRequest("n",
pathString)}onDisconnectPut(pathString,data,onComplete){this.initConnection_();this.connected_?this.sendOnDisconnect_("o",pathString,data,onComplete):this.onDisconnectRequestQueue_.push({pathString,action:"o",data,onComplete})}onDisconnectMerge(pathString,data,onComplete){this.initConnection_();this.connected_?this.sendOnDisconnect_("om",pathString,data,onComplete):this.onDisconnectRequestQueue_.push({pathString,action:"om",data,onComplete})}onDisconnectCancel(pathString,onComplete){this.initConnection_();
this.connected_?this.sendOnDisconnect_("oc",pathString,null,onComplete):this.onDisconnectRequestQueue_.push({pathString,action:"oc",data:null,onComplete})}sendOnDisconnect_(action,pathString,data,onComplete){pathString={p:pathString,d:data};this.log_("onDisconnect "+action,pathString);this.sendRequest(action,pathString,response=>{onComplete&&setTimeout(()=>{onComplete(response.s,response.d)},0)})}put(pathString,data,onComplete,hash){this.putInternal("p",pathString,data,onComplete,hash)}merge(pathString,
data,onComplete,hash){this.putInternal("m",pathString,data,onComplete,hash)}putInternal(action,pathString,data,onComplete,hash){this.initConnection_();data={p:pathString,d:data};void 0!==hash&&(data.h=hash);this.outstandingPuts_.push({action,request:data,onComplete});this.outstandingPutCount_++;action=this.outstandingPuts_.length-1;this.connected_?this.sendPut_(action):this.log_("Buffering put: "+pathString)}sendPut_(index){const action=this.outstandingPuts_[index].action,request=this.outstandingPuts_[index].request,
onComplete=this.outstandingPuts_[index].onComplete;this.outstandingPuts_[index].queued=this.connected_;this.sendRequest(action,request,message=>{this.log_(action+" response",message);delete this.outstandingPuts_[index];this.outstandingPutCount_--;0===this.outstandingPutCount_&&(this.outstandingPuts_=[]);onComplete&&onComplete(message.s,message.d)})}reportStats(stats){this.connected_&&(stats={c:stats},this.log_("reportStats",stats),this.sendRequest("s",stats,result=>{"ok"!==result.s&&this.log_("reportStats",
"Error sending stats: "+result.d)}))}onDataMessage_(message){if("r"in message){this.log_("from server: "+(0,_util.stringify)(message));const reqNum=message.r,onResponse=this.requestCBHash_[reqNum];onResponse&&(delete this.requestCBHash_[reqNum],onResponse(message.b))}else{if("error"in message)throw"A server-side error has occurred: "+message.error;if("a"in message)this.onDataPush_(message.a,message.b)}}onDataPush_(action,body){this.log_("handleServerMessage",action,body);if("d"===action)this.onDataUpdate_(body.p,
body.d,!1,body.t);else if("m"===action)this.onDataUpdate_(body.p,body.d,!0,body.t);else if("c"===action)this.onListenRevoked_(body.p,body.q);else if("ac"===action)this.onAuthRevoked_(body.s,body.d);else if("apc"===action)this.onAppCheckRevoked_(body.s,body.d);else if("sd"===action)this.onSecurityDebugPacket_(body);else error$jscomp$0("Unrecognized action received from server: "+(0,_util.stringify)(action)+"\nAre you using the latest client?")}onReady_(timestamp,sessionId){this.log_("connection ready");
this.connected_=!0;this.lastConnectionEstablishedTime_=(new Date).getTime();this.handleTimestamp_(timestamp);this.lastSessionId=sessionId;this.firstConnection_&&this.sendConnectStats_();this.restoreState_();this.firstConnection_=!1;this.onConnectStatus_(!0)}scheduleConnect_(timeout){(0,_util.assert)(!this.realtime_,"Scheduling a connect when we're already connected/ing?");this.establishConnectionTimer_&&clearTimeout(this.establishConnectionTimer_);this.establishConnectionTimer_=setTimeout(()=>{this.establishConnectionTimer_=
null;this.establishConnection_()},Math.floor(timeout))}initConnection_(){!this.realtime_&&this.firstConnection_&&this.scheduleConnect_(0)}onVisible_(visible){visible&&!this.visible_&&this.reconnectDelay_===this.maxReconnectDelay_&&(this.log_("Window became visible.  Reducing delay."),this.reconnectDelay_=1E3,this.realtime_||this.scheduleConnect_(0));this.visible_=visible}onOnline_(online){online?(this.log_("Browser went online."),this.reconnectDelay_=1E3,this.realtime_||this.scheduleConnect_(0)):
(this.log_("Browser went offline.  Killing connection."),this.realtime_&&this.realtime_.close())}onRealtimeDisconnect_(){this.log_("data client disconnected");this.connected_=!1;this.realtime_=null;this.cancelSentTransactions_();this.requestCBHash_={};if(this.shouldReconnect_()){this.visible_?this.lastConnectionEstablishedTime_&&(3E4<(new Date).getTime()-this.lastConnectionEstablishedTime_&&(this.reconnectDelay_=1E3),this.lastConnectionEstablishedTime_=null):(this.log_("Window isn't visible.  Delaying reconnect."),
this.reconnectDelay_=this.maxReconnectDelay_,this.lastConnectionAttemptTime_=(new Date).getTime());var timeSinceLastConnectAttempt=(new Date).getTime()-this.lastConnectionAttemptTime_;timeSinceLastConnectAttempt=Math.max(0,this.reconnectDelay_-timeSinceLastConnectAttempt);timeSinceLastConnectAttempt*=Math.random();this.log_("Trying to reconnect in "+timeSinceLastConnectAttempt+"ms");this.scheduleConnect_(timeSinceLastConnectAttempt);this.reconnectDelay_=Math.min(this.maxReconnectDelay_,1.3*this.reconnectDelay_)}this.onConnectStatus_(!1)}establishConnection_(){const $jscomp$async$this=
this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if($jscomp$async$this.shouldReconnect_()){$jscomp$async$this.log_("Making a connection attempt");$jscomp$async$this.lastConnectionAttemptTime_=(new Date).getTime();$jscomp$async$this.lastConnectionEstablishedTime_=null;const onDataMessage=$jscomp$async$this.onDataMessage_.bind($jscomp$async$this),onReady=$jscomp$async$this.onReady_.bind($jscomp$async$this),onDisconnect=$jscomp$async$this.onRealtimeDisconnect_.bind($jscomp$async$this),
connId=$jscomp$async$this.id+":"+PersistentConnection.nextConnectionId_++,lastSessionId=$jscomp$async$this.lastSessionId;let canceled=!1,connection=null;const closeFn=function(){connection?connection.close():(canceled=!0,onDisconnect())};$jscomp$async$this.realtime_={close:closeFn,sendRequest:function(msg){(0,_util.assert)(connection,"sendRequest call when we're not connected not allowed.");connection.sendRequest(msg)}};const forceRefresh=$jscomp$async$this.forceTokenRefresh_;$jscomp$async$this.forceTokenRefresh_=
!1;try{const [authToken,appCheckToken]=yield Promise.all([$jscomp$async$this.authTokenProvider_.getToken(forceRefresh),$jscomp$async$this.appCheckTokenProvider_.getToken(forceRefresh)]);canceled?log("getToken() completed but was canceled"):(log("getToken() completed. Creating connection."),$jscomp$async$this.authToken_=authToken&&authToken.accessToken,$jscomp$async$this.appCheckToken_=appCheckToken&&appCheckToken.token,connection=new Connection(connId,$jscomp$async$this.repoInfo_,$jscomp$async$this.applicationId_,
$jscomp$async$this.appCheckToken_,$jscomp$async$this.authToken_,onDataMessage,onReady,onDisconnect,reason=>{warn(reason+" ("+$jscomp$async$this.repoInfo_.toString()+")");$jscomp$async$this.interrupt("server_kill")},lastSessionId))}catch(error){$jscomp$async$this.log_("Failed to get token: "+error),canceled||($jscomp$async$this.repoInfo_.nodeAdmin&&warn(error),closeFn())}}})}interrupt(reason){log("Interrupting connection for reason: "+reason);this.interruptReasons_[reason]=!0;if(this.realtime_)this.realtime_.close();
else if(this.establishConnectionTimer_&&(clearTimeout(this.establishConnectionTimer_),this.establishConnectionTimer_=null),this.connected_)this.onRealtimeDisconnect_()}resume(reason){log("Resuming connection for reason: "+reason);delete this.interruptReasons_[reason];(0,_util.isEmpty)(this.interruptReasons_)&&(this.reconnectDelay_=1E3,this.realtime_||this.scheduleConnect_(0))}handleTimestamp_(timestamp){timestamp-=(new Date).getTime();this.onServerInfoUpdate_({serverTimeOffset:timestamp})}cancelSentTransactions_(){for(let i=
0;i<this.outstandingPuts_.length;i++){const put=this.outstandingPuts_[i];if(put&&"h"in put.request&&put.queued){if(put.onComplete)put.onComplete("disconnect");delete this.outstandingPuts_[i];this.outstandingPutCount_--}}0===this.outstandingPutCount_&&(this.outstandingPuts_=[])}onListenRevoked_(pathString,query){query=query?query.map(q=>ObjectToUniqueKey(q)).join("$"):"default";if((pathString=this.removeListen_(pathString,query))&&pathString.onComplete)pathString.onComplete("permission_denied")}removeListen_(pathString,
queryId){pathString=(new Path(pathString)).toString();let listen;if(this.listens.has(pathString)){const map=this.listens.get(pathString);listen=map.get(queryId);map.delete(queryId);0===map.size&&this.listens.delete(pathString)}else listen=void 0;return listen}onAuthRevoked_(statusCode,explanation){log("Auth token revoked: "+statusCode+"/"+explanation);this.authToken_=null;this.forceTokenRefresh_=!0;this.realtime_.close();if("invalid_token"===statusCode||"permission_denied"===statusCode)this.invalidAuthTokenCount_++,
3<=this.invalidAuthTokenCount_&&(this.reconnectDelay_=3E4,this.authTokenProvider_.notifyForInvalidToken())}onAppCheckRevoked_(statusCode,explanation){log("App check token revoked: "+statusCode+"/"+explanation);this.appCheckToken_=null;this.forceTokenRefresh_=!0;if("invalid_token"===statusCode||"permission_denied"===statusCode)this.invalidAppCheckTokenCount_++,3<=this.invalidAppCheckTokenCount_&&this.appCheckTokenProvider_.notifyForInvalidToken()}onSecurityDebugPacket_(body){this.securityDebugCallback_?
this.securityDebugCallback_(body):"msg"in body&&console.log("FIREBASE: "+body.msg.replace("\n","\nFIREBASE: "))}restoreState_(){this.tryAuth();this.tryAppCheck();for(var queries of this.listens.values())for(const listenSpec of queries.values())this.sendListen_(listenSpec);for(queries=0;queries<this.outstandingPuts_.length;queries++)this.outstandingPuts_[queries]&&this.sendPut_(queries);for(;this.onDisconnectRequestQueue_.length;)queries=this.onDisconnectRequestQueue_.shift(),this.sendOnDisconnect_(queries.action,
queries.pathString,queries.data,queries.onComplete);for(queries=0;queries<this.outstandingGets_.length;queries++)this.outstandingGets_[queries]&&this.sendGet_(queries)}sendConnectStats_(){const stats={};let clientName="js";(0,_util.isNodeSdk)()&&(clientName=this.repoInfo_.nodeAdmin?"admin_node":"node");stats["sdk."+clientName+"."+SDK_VERSION.replace(/\./g,"-")]=1;(0,_util.isMobileCordova)()?stats["framework.cordova"]=1:(0,_util.isReactNative)()&&(stats["framework.reactnative"]=1);this.reportStats(stats)}shouldReconnect_(){const online=
OnlineMonitor.getInstance().currentlyOnline();return(0,_util.isEmpty)(this.interruptReasons_)&&online}}PersistentConnection.nextPersistentConnectionId_=0;PersistentConnection.nextConnectionId_=0;class NamedNode{constructor(name,node){this.name=name;this.node=node}static Wrap(name,node){return new NamedNode(name,node)}}class Index{getCompare(){return this.compare.bind(this)}indexedValueChanged(oldNode,newNode){oldNode=new NamedNode("[MIN_NAME]",oldNode);newNode=new NamedNode("[MIN_NAME]",newNode);
return 0!==this.compare(oldNode,newNode)}minPost(){return NamedNode.MIN}}let __EMPTY_NODE;class KeyIndex extends Index{static get __EMPTY_NODE(){return __EMPTY_NODE}static set __EMPTY_NODE(val){__EMPTY_NODE=val}compare(a,b){return nameCompare(a.name,b.name)}isDefinedOn(node){throw(0,_util.assertionError)("KeyIndex.isDefinedOn not expected to be called.");}indexedValueChanged(oldNode,newNode){return!1}minPost(){return NamedNode.MIN}maxPost(){return new NamedNode("[MAX_NAME]",__EMPTY_NODE)}makePost(indexValue,
name){(0,_util.assert)("string"===typeof indexValue,"KeyIndex indexValue must always be a string.");return new NamedNode(indexValue,__EMPTY_NODE)}toString(){return".key"}}const KEY_INDEX=new KeyIndex;class SortedMapIterator{constructor(node,startKey,comparator,isReverse_,resultGenerator_=null){this.isReverse_=isReverse_;this.resultGenerator_=resultGenerator_;for(this.nodeStack_=[];!node.isEmpty();)if(resultGenerator_=startKey?comparator(node.key,startKey):1,isReverse_&&(resultGenerator_*=-1),0>resultGenerator_)node=
this.isReverse_?node.left:node.right;else if(0===resultGenerator_){this.nodeStack_.push(node);break}else this.nodeStack_.push(node),node=this.isReverse_?node.right:node.left}getNext(){if(0===this.nodeStack_.length)return null;let node=this.nodeStack_.pop(),result;result=this.resultGenerator_?this.resultGenerator_(node.key,node.value):{key:node.key,value:node.value};if(this.isReverse_)for(node=node.left;!node.isEmpty();)this.nodeStack_.push(node),node=node.right;else for(node=node.right;!node.isEmpty();)this.nodeStack_.push(node),
node=node.left;return result}hasNext(){return 0<this.nodeStack_.length}peek(){if(0===this.nodeStack_.length)return null;const node=this.nodeStack_[this.nodeStack_.length-1];return this.resultGenerator_?this.resultGenerator_(node.key,node.value):{key:node.key,value:node.value}}}class LLRBNode{constructor(key,value,color,left,right){this.key=key;this.value=value;this.color=null!=color?color:LLRBNode.RED;this.left=null!=left?left:SortedMap.EMPTY_NODE;this.right=null!=right?right:SortedMap.EMPTY_NODE}copy(key,
value,color,left,right){return new LLRBNode(null!=key?key:this.key,null!=value?value:this.value,null!=color?color:this.color,null!=left?left:this.left,null!=right?right:this.right)}count(){return this.left.count()+1+this.right.count()}isEmpty(){return!1}inorderTraversal(action){return this.left.inorderTraversal(action)||!!action(this.key,this.value)||this.right.inorderTraversal(action)}reverseTraversal(action){return this.right.reverseTraversal(action)||action(this.key,this.value)||this.left.reverseTraversal(action)}min_(){return this.left.isEmpty()?
this:this.left.min_()}minKey(){return this.min_().key}maxKey(){return this.right.isEmpty()?this.key:this.right.maxKey()}insert(key,value,comparator){let n=this;const cmp=comparator(key,n.key);n=0>cmp?n.copy(null,null,null,n.left.insert(key,value,comparator),null):0===cmp?n.copy(null,value,null,null,null):n.copy(null,null,null,null,n.right.insert(key,value,comparator));return n.fixUp_()}removeMin_(){if(this.left.isEmpty())return SortedMap.EMPTY_NODE;let n=this;n.left.isRed_()||n.left.left.isRed_()||
(n=n.moveRedLeft_());n=n.copy(null,null,null,n.left.removeMin_(),null);return n.fixUp_()}remove(key,comparator){let n,smallest;n=this;if(0>comparator(key,n.key))n.left.isEmpty()||n.left.isRed_()||n.left.left.isRed_()||(n=n.moveRedLeft_()),n=n.copy(null,null,null,n.left.remove(key,comparator),null);else{n.left.isRed_()&&(n=n.rotateRight_());n.right.isEmpty()||n.right.isRed_()||n.right.left.isRed_()||(n=n.moveRedRight_());if(0===comparator(key,n.key)){if(n.right.isEmpty())return SortedMap.EMPTY_NODE;
smallest=n.right.min_();n=n.copy(smallest.key,smallest.value,null,null,n.right.removeMin_())}n=n.copy(null,null,null,null,n.right.remove(key,comparator))}return n.fixUp_()}isRed_(){return this.color}fixUp_(){let n=this;n.right.isRed_()&&!n.left.isRed_()&&(n=n.rotateLeft_());n.left.isRed_()&&n.left.left.isRed_()&&(n=n.rotateRight_());n.left.isRed_()&&n.right.isRed_()&&(n=n.colorFlip_());return n}moveRedLeft_(){let n=this.colorFlip_();n.right.left.isRed_()&&(n=n.copy(null,null,null,null,n.right.rotateRight_()),
n=n.rotateLeft_(),n=n.colorFlip_());return n}moveRedRight_(){let n=this.colorFlip_();n.left.left.isRed_()&&(n=n.rotateRight_(),n=n.colorFlip_());return n}rotateLeft_(){const nl=this.copy(null,null,LLRBNode.RED,null,this.right.left);return this.right.copy(null,null,this.color,nl,null)}rotateRight_(){const nr=this.copy(null,null,LLRBNode.RED,this.left.right,null);return this.left.copy(null,null,this.color,null,nr)}colorFlip_(){const left=this.left.copy(null,null,!this.left.color,null,null),right=this.right.copy(null,
null,!this.right.color,null,null);return this.copy(null,null,!this.color,left,right)}checkMaxDepth_(){const blackDepth=this.check_();return Math.pow(2,blackDepth)<=this.count()+1}check_(){if(this.isRed_()&&this.left.isRed_())throw Error("Red node has red child("+this.key+","+this.value+")");if(this.right.isRed_())throw Error("Right child of ("+this.key+","+this.value+") is red");const blackDepth=this.left.check_();if(blackDepth!==this.right.check_())throw Error("Black depths differ");return blackDepth+
(this.isRed_()?0:1)}}LLRBNode.RED=!0;LLRBNode.BLACK=!1;class LLRBEmptyNode{copy(key,value,color,left,right){return this}insert(key,value,comparator){return new LLRBNode(key,value,null)}remove(key,comparator){return this}count(){return 0}isEmpty(){return!0}inorderTraversal(action){return!1}reverseTraversal(action){return!1}minKey(){return null}maxKey(){return null}check_(){return 0}isRed_(){return!1}}class SortedMap{constructor(comparator_,root_=SortedMap.EMPTY_NODE){this.comparator_=comparator_;this.root_=
root_}insert(key,value){return new SortedMap(this.comparator_,this.root_.insert(key,value,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null))}remove(key){return new SortedMap(this.comparator_,this.root_.remove(key,this.comparator_).copy(null,null,LLRBNode.BLACK,null,null))}get(key){let cmp,node=this.root_;for(;!node.isEmpty();){cmp=this.comparator_(key,node.key);if(0===cmp)return node.value;0>cmp?node=node.left:0<cmp&&(node=node.right)}return null}getPredecessorKey(key){let cmp,node=this.root_,
rightParent=null;for(;!node.isEmpty();){cmp=this.comparator_(key,node.key);if(0===cmp){if(node.left.isEmpty())return rightParent?rightParent.key:null;for(node=node.left;!node.right.isEmpty();)node=node.right;return node.key}0>cmp?node=node.left:0<cmp&&(rightParent=node,node=node.right)}throw Error("Attempted to find predecessor key for a nonexistent key.  What gives?");}isEmpty(){return this.root_.isEmpty()}count(){return this.root_.count()}minKey(){return this.root_.minKey()}maxKey(){return this.root_.maxKey()}inorderTraversal(action){return this.root_.inorderTraversal(action)}reverseTraversal(action){return this.root_.reverseTraversal(action)}getIterator(resultGenerator){return new SortedMapIterator(this.root_,
null,this.comparator_,!1,resultGenerator)}getIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,!1,resultGenerator)}getReverseIteratorFrom(key,resultGenerator){return new SortedMapIterator(this.root_,key,this.comparator_,!0,resultGenerator)}getReverseIterator(resultGenerator){return new SortedMapIterator(this.root_,null,this.comparator_,!0,resultGenerator)}}SortedMap.EMPTY_NODE=new LLRBEmptyNode;let MAX_NODE$2;const priorityHashText=function(priority){return"number"===
typeof priority?"number:"+doubleToIEEE754String(priority):"string:"+priority},validatePriorityNode=function(priorityNode){if(priorityNode.isLeafNode()){const val=priorityNode.val();(0,_util.assert)("string"===typeof val||"number"===typeof val||"object"===typeof val&&(0,_util.contains)(val,".sv"),"Priority must be a string or number.")}else(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.isEmpty(),"priority of unexpected type.");(0,_util.assert)(priorityNode===MAX_NODE$2||priorityNode.getPriority().isEmpty(),
"Priority nodes can't have a priority of their own.")};let __childrenNodeConstructor;class LeafNode{constructor(value_,priorityNode_=LeafNode.__childrenNodeConstructor.EMPTY_NODE){this.value_=value_;this.priorityNode_=priorityNode_;this.lazyHash_=null;(0,_util.assert)(void 0!==this.value_&&null!==this.value_,"LeafNode shouldn't be created with null/undefined value.");validatePriorityNode(this.priorityNode_)}static set __childrenNodeConstructor(val){__childrenNodeConstructor=val}static get __childrenNodeConstructor(){return __childrenNodeConstructor}isLeafNode(){return!0}getPriority(){return this.priorityNode_}updatePriority(newPriorityNode){return new LeafNode(this.value_,
newPriorityNode)}getImmediateChild(childName){return".priority"===childName?this.priorityNode_:LeafNode.__childrenNodeConstructor.EMPTY_NODE}getChild(path){return pathIsEmpty(path)?this:".priority"===pathGetFront(path)?this.priorityNode_:LeafNode.__childrenNodeConstructor.EMPTY_NODE}hasChild(){return!1}getPredecessorChildName(childName,childNode){return null}updateImmediateChild(childName,newChildNode){return".priority"===childName?this.updatePriority(newChildNode):newChildNode.isEmpty()&&".priority"!==
childName?this:LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName,newChildNode).updatePriority(this.priorityNode_)}updateChild(path,newChildNode){const front=pathGetFront(path);if(null===front)return newChildNode;if(newChildNode.isEmpty()&&".priority"!==front)return this;(0,_util.assert)(".priority"!==front||1===pathGetLength(path),".priority must be the last token in a path");return this.updateImmediateChild(front,LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path),
newChildNode))}isEmpty(){return!1}numChildren(){return 0}forEachChild(index,action){return!1}val(exportFormat){return exportFormat&&!this.getPriority().isEmpty()?{".value":this.getValue(),".priority":this.getPriority().val()}:this.getValue()}hash(){if(null===this.lazyHash_){let toHash="";this.priorityNode_.isEmpty()||(toHash+="priority:"+priorityHashText(this.priorityNode_.val())+":");const type=typeof this.value_;toHash+=type+":";toHash="number"===type?toHash+doubleToIEEE754String(this.value_):toHash+
this.value_;this.lazyHash_=sha1(toHash)}return this.lazyHash_}getValue(){return this.value_}compareTo(other){if(other===LeafNode.__childrenNodeConstructor.EMPTY_NODE)return 1;if(other instanceof LeafNode.__childrenNodeConstructor)return-1;(0,_util.assert)(other.isLeafNode(),"Unknown node type");return this.compareToLeafNode_(other)}compareToLeafNode_(otherLeaf){const otherLeafType=typeof otherLeaf.value_,thisLeafType=typeof this.value_,otherIndex=LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType),thisIndex=
LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);(0,_util.assert)(0<=otherIndex,"Unknown leaf type: "+otherLeafType);(0,_util.assert)(0<=thisIndex,"Unknown leaf type: "+thisLeafType);return otherIndex===thisIndex?"object"===thisLeafType?0:this.value_<otherLeaf.value_?-1:this.value_===otherLeaf.value_?0:1:thisIndex-otherIndex}withIndex(){return this}isIndexed(){return!0}equals(other){return other===this?!0:other.isLeafNode()?this.value_===other.value_&&this.priorityNode_.equals(other.priorityNode_):
!1}}LeafNode.VALUE_TYPE_ORDER=["object","boolean","number","string"];let nodeFromJSON$1,MAX_NODE$1;class PriorityIndex extends Index{compare(a,b){var aPriority=a.node.getPriority();const bPriority=b.node.getPriority();aPriority=aPriority.compareTo(bPriority);return 0===aPriority?nameCompare(a.name,b.name):aPriority}isDefinedOn(node){return!node.getPriority().isEmpty()}indexedValueChanged(oldNode,newNode){return!oldNode.getPriority().equals(newNode.getPriority())}minPost(){return NamedNode.MIN}maxPost(){return new NamedNode("[MAX_NAME]",
new LeafNode("[PRIORITY-POST]",MAX_NODE$1))}makePost(indexValue,name){indexValue=nodeFromJSON$1(indexValue);return new NamedNode(name,new LeafNode("[PRIORITY-POST]",indexValue))}toString(){return".priority"}}const PRIORITY_INDEX=new PriorityIndex,LOG_2=Math.log(2);class Base12Num{constructor(length){this.count=parseInt(Math.log(length+1)/LOG_2,10);this.current_=this.count-1;const mask=parseInt(Array(this.count+1).join("1"),2);this.bits_=length+1&mask}nextBitIsOne(){const result=!(this.bits_&1<<this.current_);
this.current_--;return result}}const buildChildSet=function(childList,cmp,keyFn,mapSortFn){childList.sort(cmp);const buildBalancedTree=function(low,high){var length=high-low;let key;if(0===length)return null;if(1===length)return length=childList[low],key=keyFn?keyFn(length):length,new LLRBNode(key,length.node,LLRBNode.BLACK,null,null);length=parseInt(length/2,10)+low;low=buildBalancedTree(low,length);high=buildBalancedTree(length+1,high);length=childList[length];key=keyFn?keyFn(length):length;return new LLRBNode(key,
length.node,LLRBNode.BLACK,low,high)},root$jscomp$0=function(base12){let node=null,root=null,index=childList.length;const buildPennant=function(chunkSize,color){var low=index-chunkSize,high=index;index-=chunkSize;chunkSize=buildBalancedTree(low+1,high);low=childList[low];high=keyFn?keyFn(low):low;color=new LLRBNode(high,low.node,color,null,chunkSize);node?node.left=color:root=color;node=color};for(let i=0;i<base12.count;++i){const isOne=base12.nextBitIsOne(),chunkSize=Math.pow(2,base12.count-(i+1));
isOne?buildPennant(chunkSize,LLRBNode.BLACK):(buildPennant(chunkSize,LLRBNode.BLACK),buildPennant(chunkSize,LLRBNode.RED))}return root}(new Base12Num(childList.length));return new SortedMap(mapSortFn||cmp,root$jscomp$0)};let _defaultIndexMap;const fallbackObject={};class IndexMap{constructor(indexes_,indexSet_){this.indexes_=indexes_;this.indexSet_=indexSet_}static get Default(){(0,_util.assert)(fallbackObject&&PRIORITY_INDEX,"ChildrenNode.ts has not been loaded");return _defaultIndexMap=_defaultIndexMap||
new IndexMap({".priority":fallbackObject},{".priority":PRIORITY_INDEX})}get(indexKey){const sortedMap=(0,_util.safeGet)(this.indexes_,indexKey);if(!sortedMap)throw Error("No index defined for "+indexKey);return sortedMap instanceof SortedMap?sortedMap:null}hasIndex(indexDefinition){return(0,_util.contains)(this.indexSet_,indexDefinition.toString())}addIndex(indexDefinition,existingChildren){(0,_util.assert)(indexDefinition!==KEY_INDEX,"KeyIndex always exists and isn't meant to be added to the IndexMap.");
var childList=[],sawIndexedValue=!1;existingChildren=existingChildren.getIterator(NamedNode.Wrap);let next=existingChildren.getNext();for(;next;)sawIndexedValue=sawIndexedValue||indexDefinition.isDefinedOn(next.node),childList.push(next),next=existingChildren.getNext();childList=sawIndexedValue?buildChildSet(childList,indexDefinition.getCompare()):fallbackObject;sawIndexedValue=indexDefinition.toString();existingChildren=Object.assign({},this.indexSet_);existingChildren[sawIndexedValue]=indexDefinition;
indexDefinition=Object.assign({},this.indexes_);indexDefinition[sawIndexedValue]=childList;return new IndexMap(indexDefinition,existingChildren)}addToIndexes(namedNode,existingChildren){const newIndexes=(0,_util.map)(this.indexes_,(indexedChildren,indexName)=>{var index=(0,_util.safeGet)(this.indexSet_,indexName);(0,_util.assert)(index,"Missing index implementation for "+indexName);if(indexedChildren===fallbackObject){if(index.isDefinedOn(namedNode.node)){indexedChildren=[];indexName=existingChildren.getIterator(NamedNode.Wrap);
let next=indexName.getNext();for(;next;)next.name!==namedNode.name&&indexedChildren.push(next),next=indexName.getNext();indexedChildren.push(namedNode);return buildChildSet(indexedChildren,index.getCompare())}return fallbackObject}(index=existingChildren.get(namedNode.name))&&(indexedChildren=indexedChildren.remove(new NamedNode(namedNode.name,index)));return indexedChildren.insert(namedNode,namedNode.node)});return new IndexMap(newIndexes,this.indexSet_)}removeFromIndexes(namedNode,existingChildren){const newIndexes=
(0,_util.map)(this.indexes_,indexedChildren=>{if(indexedChildren===fallbackObject)return indexedChildren;const existingSnap=existingChildren.get(namedNode.name);return existingSnap?indexedChildren.remove(new NamedNode(namedNode.name,existingSnap)):indexedChildren});return new IndexMap(newIndexes,this.indexSet_)}}let EMPTY_NODE;class ChildrenNode{constructor(children_,priorityNode_,indexMap_){this.children_=children_;this.priorityNode_=priorityNode_;this.indexMap_=indexMap_;this.lazyHash_=null;this.priorityNode_&&
validatePriorityNode(this.priorityNode_);this.children_.isEmpty()&&(0,_util.assert)(!this.priorityNode_||this.priorityNode_.isEmpty(),"An empty node cannot have a priority")}static get EMPTY_NODE(){return EMPTY_NODE||(EMPTY_NODE=new ChildrenNode(new SortedMap(NAME_COMPARATOR),null,IndexMap.Default))}isLeafNode(){return!1}getPriority(){return this.priorityNode_||EMPTY_NODE}updatePriority(newPriorityNode){return this.children_.isEmpty()?this:new ChildrenNode(this.children_,newPriorityNode,this.indexMap_)}getImmediateChild(childName){if(".priority"===
childName)return this.getPriority();childName=this.children_.get(childName);return null===childName?EMPTY_NODE:childName}getChild(path){const front=pathGetFront(path);return null===front?this:this.getImmediateChild(front).getChild(pathPopFront(path))}hasChild(childName){return null!==this.children_.get(childName)}updateImmediateChild(childName,newChildNode){(0,_util.assert)(newChildNode,"We should always be passing snapshot nodes");if(".priority"===childName)return this.updatePriority(newChildNode);
var namedNode=new NamedNode(childName,newChildNode);newChildNode.isEmpty()?(childName=this.children_.remove(childName),namedNode=this.indexMap_.removeFromIndexes(namedNode,this.children_)):(childName=this.children_.insert(childName,newChildNode),namedNode=this.indexMap_.addToIndexes(namedNode,this.children_));newChildNode=childName.isEmpty()?EMPTY_NODE:this.priorityNode_;return new ChildrenNode(childName,newChildNode,namedNode)}updateChild(path,newChildNode){const front=pathGetFront(path);if(null===
front)return newChildNode;(0,_util.assert)(".priority"!==pathGetFront(path)||1===pathGetLength(path),".priority must be the last token in a path");path=this.getImmediateChild(front).updateChild(pathPopFront(path),newChildNode);return this.updateImmediateChild(front,path)}isEmpty(){return this.children_.isEmpty()}numChildren(){return this.children_.count()}val(exportFormat){if(this.isEmpty())return null;const obj={};let numKeys=0,maxKey=0,allIntegerKeys=!0;this.forEachChild(PRIORITY_INDEX,(key,childNode)=>
{obj[key]=childNode.val(exportFormat);numKeys++;allIntegerKeys&&ChildrenNode.INTEGER_REGEXP_.test(key)?maxKey=Math.max(maxKey,Number(key)):allIntegerKeys=!1});if(!exportFormat&&allIntegerKeys&&maxKey<2*numKeys){const array=[];for(const key in obj)array[key]=obj[key];return array}exportFormat&&!this.getPriority().isEmpty()&&(obj[".priority"]=this.getPriority().val());return obj}hash(){if(null===this.lazyHash_){let toHash="";this.getPriority().isEmpty()||(toHash+="priority:"+priorityHashText(this.getPriority().val())+
":");this.forEachChild(PRIORITY_INDEX,(key,childNode)=>{childNode=childNode.hash();""!==childNode&&(toHash+=":"+key+":"+childNode)});this.lazyHash_=""===toHash?"":sha1(toHash)}return this.lazyHash_}getPredecessorChildName(childName,childNode,index){return(index=this.resolveIndex_(index))?(childName=index.getPredecessorKey(new NamedNode(childName,childNode)))?childName.name:null:this.children_.getPredecessorKey(childName)}getFirstChildName(indexDefinition){return(indexDefinition=this.resolveIndex_(indexDefinition))?
(indexDefinition=indexDefinition.minKey())&&indexDefinition.name:this.children_.minKey()}getFirstChild(indexDefinition){return(indexDefinition=this.getFirstChildName(indexDefinition))?new NamedNode(indexDefinition,this.children_.get(indexDefinition)):null}getLastChildName(indexDefinition){return(indexDefinition=this.resolveIndex_(indexDefinition))?(indexDefinition=indexDefinition.maxKey())&&indexDefinition.name:this.children_.maxKey()}getLastChild(indexDefinition){return(indexDefinition=this.getLastChildName(indexDefinition))?
new NamedNode(indexDefinition,this.children_.get(indexDefinition)):null}forEachChild(index,action){return(index=this.resolveIndex_(index))?index.inorderTraversal(wrappedNode=>action(wrappedNode.name,wrappedNode.node)):this.children_.inorderTraversal(action)}getIterator(indexDefinition){return this.getIteratorFrom(indexDefinition.minPost(),indexDefinition)}getIteratorFrom(startPost,indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx)return idx.getIteratorFrom(startPost,key=>key);idx=
this.children_.getIteratorFrom(startPost.name,NamedNode.Wrap);let next=idx.peek();for(;null!=next&&0>indexDefinition.compare(next,startPost);)idx.getNext(),next=idx.peek();return idx}getReverseIterator(indexDefinition){return this.getReverseIteratorFrom(indexDefinition.maxPost(),indexDefinition)}getReverseIteratorFrom(endPost,indexDefinition){var idx=this.resolveIndex_(indexDefinition);if(idx)return idx.getReverseIteratorFrom(endPost,key=>key);idx=this.children_.getReverseIteratorFrom(endPost.name,
NamedNode.Wrap);let next=idx.peek();for(;null!=next&&0<indexDefinition.compare(next,endPost);)idx.getNext(),next=idx.peek();return idx}compareTo(other){return this.isEmpty()?other.isEmpty()?0:-1:other.isLeafNode()||other.isEmpty()?1:other===MAX_NODE?-1:0}withIndex(indexDefinition){if(indexDefinition===KEY_INDEX||this.indexMap_.hasIndex(indexDefinition))return this;indexDefinition=this.indexMap_.addIndex(indexDefinition,this.children_);return new ChildrenNode(this.children_,this.priorityNode_,indexDefinition)}isIndexed(index){return index===
KEY_INDEX||this.indexMap_.hasIndex(index)}equals(other){if(other===this)return!0;if(other.isLeafNode())return!1;if(this.getPriority().equals(other.getPriority())&&this.children_.count()===other.children_.count()){const thisIter=this.getIterator(PRIORITY_INDEX);other=other.getIterator(PRIORITY_INDEX);let thisCurrent=thisIter.getNext(),otherCurrent=other.getNext();for(;thisCurrent&&otherCurrent;){if(thisCurrent.name!==otherCurrent.name||!thisCurrent.node.equals(otherCurrent.node))return!1;thisCurrent=
thisIter.getNext();otherCurrent=other.getNext()}return null===thisCurrent&&null===otherCurrent}return!1}resolveIndex_(indexDefinition){return indexDefinition===KEY_INDEX?null:this.indexMap_.get(indexDefinition.toString())}}ChildrenNode.INTEGER_REGEXP_=/^(0|[1-9]\d*)$/;class MaxNode extends ChildrenNode{constructor(){super(new SortedMap(NAME_COMPARATOR),ChildrenNode.EMPTY_NODE,IndexMap.Default)}compareTo(other){return other===this?0:1}equals(other){return other===this}getPriority(){return this}getImmediateChild(childName){return ChildrenNode.EMPTY_NODE}isEmpty(){return!1}}
const MAX_NODE=new MaxNode;Object.defineProperties(NamedNode,{MIN:{value:new NamedNode("[MIN_NAME]",ChildrenNode.EMPTY_NODE)},MAX:{value:new NamedNode("[MAX_NAME]",MAX_NODE)}});KeyIndex.__EMPTY_NODE=ChildrenNode.EMPTY_NODE;LeafNode.__childrenNodeConstructor=ChildrenNode;MAX_NODE$1=MAX_NODE$2=MAX_NODE;nodeFromJSON$1=nodeFromJSON;class PathIndex extends Index{constructor(indexPath_){super();this.indexPath_=indexPath_;(0,_util.assert)(!pathIsEmpty(indexPath_)&&".priority"!==pathGetFront(indexPath_),
"Can't create PathIndex with empty path or .priority key")}extractChild(snap){return snap.getChild(this.indexPath_)}isDefinedOn(node){return!node.getChild(this.indexPath_).isEmpty()}compare(a,b){var aChild=this.extractChild(a.node);const bChild=this.extractChild(b.node);aChild=aChild.compareTo(bChild);return 0===aChild?nameCompare(a.name,b.name):aChild}makePost(indexValue,name){indexValue=nodeFromJSON(indexValue);indexValue=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,indexValue);return new NamedNode(name,
indexValue)}maxPost(){const node=ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_,MAX_NODE);return new NamedNode("[MAX_NAME]",node)}toString(){return pathSlice(this.indexPath_,0).join("/")}}class ValueIndex extends Index{compare(a,b){const indexCmp=a.node.compareTo(b.node);return 0===indexCmp?nameCompare(a.name,b.name):indexCmp}isDefinedOn(node){return!0}indexedValueChanged(oldNode,newNode){return!oldNode.equals(newNode)}minPost(){return NamedNode.MIN}maxPost(){return NamedNode.MAX}makePost(indexValue,
name){indexValue=nodeFromJSON(indexValue);return new NamedNode(name,indexValue)}toString(){return".value"}}const VALUE_INDEX=new ValueIndex,nextPushId=function(){let lastPushTime=0;const lastRandChars=[];return function(now){const duplicateTime=now===lastPushTime;lastPushTime=now;let i;const timeStampChars=Array(8);for(i=7;0<=i;i--)timeStampChars[i]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(now%64),now=Math.floor(now/64);(0,_util.assert)(0===now,"Cannot push at time \x3d\x3d 0");
now=timeStampChars.join("");if(duplicateTime){for(i=11;0<=i&&63===lastRandChars[i];i--)lastRandChars[i]=0;lastRandChars[i]++}else for(i=0;12>i;i++)lastRandChars[i]=Math.floor(64*Math.random());for(i=0;12>i;i++)now+="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt(lastRandChars[i]);(0,_util.assert)(20===now.length,"nextPushId: Length should be 20.");return now}}(),successor=function(key){if("2147483647"===key)return"-";var keyAsInt=tryParseInt(key);if(null!=keyAsInt)return""+
(keyAsInt+1);keyAsInt=Array(key.length);for(var i=0;i<keyAsInt.length;i++)keyAsInt[i]=key.charAt(i);if(786>keyAsInt.length)return keyAsInt.push("-"),keyAsInt.join("");for(key=keyAsInt.length-1;0<=key&&"z"===keyAsInt[key];)key--;if(-1===key)return"[MAX_NAME]";i="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".indexOf(keyAsInt[key])+1);keyAsInt[key]=i;return keyAsInt.slice(0,key+1).join("")},predecessor=function(key){if("-2147483648"===
key)return"[MIN_NAME]";var keyAsInt=tryParseInt(key);if(null!=keyAsInt)return""+(keyAsInt-1);keyAsInt=Array(key.length);for(let i=0;i<keyAsInt.length;i++)keyAsInt[i]=key.charAt(i);if("-"===keyAsInt[keyAsInt.length-1]){if(1===keyAsInt.length)return"2147483647";delete keyAsInt[keyAsInt.length-1];return keyAsInt.join("")}keyAsInt[keyAsInt.length-1]="-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt("-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".indexOf(keyAsInt[keyAsInt.length-
1])-1);return keyAsInt.join("")+"z".repeat(786-keyAsInt.length)};class IndexedFilter{constructor(index_){this.index_=index_}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){(0,_util.assert)(snap.isIndexed(this.index_),"A node must be indexed if only a child is updated");source=snap.getImmediateChild(key);if(source.getChild(affectedPath).equals(newChild.getChild(affectedPath))&&source.isEmpty()===newChild.isEmpty())return snap;null!=optChangeAccumulator&&(newChild.isEmpty()?
snap.hasChild(key)?optChangeAccumulator.trackChildChange(changeChildRemoved(key,source)):(0,_util.assert)(snap.isLeafNode(),"A child remove without an old child only makes sense on a leaf node"):source.isEmpty()?optChangeAccumulator.trackChildChange(changeChildAdded(key,newChild)):optChangeAccumulator.trackChildChange(changeChildChanged(key,newChild,source)));return snap.isLeafNode()&&newChild.isEmpty()?snap:snap.updateImmediateChild(key,newChild).withIndex(this.index_)}updateFullNode(oldSnap,newSnap,
optChangeAccumulator){null!=optChangeAccumulator&&(oldSnap.isLeafNode()||oldSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{newSnap.hasChild(key)||optChangeAccumulator.trackChildChange(changeChildRemoved(key,childNode))}),newSnap.isLeafNode()||newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{if(oldSnap.hasChild(key)){const oldChild=oldSnap.getImmediateChild(key);oldChild.equals(childNode)||optChangeAccumulator.trackChildChange(changeChildChanged(key,childNode,oldChild))}else optChangeAccumulator.trackChildChange(changeChildAdded(key,
childNode))}));return newSnap.withIndex(this.index_)}updatePriority(oldSnap,newPriority){return oldSnap.isEmpty()?ChildrenNode.EMPTY_NODE:oldSnap.updatePriority(newPriority)}filtersNodes(){return!1}getIndexedFilter(){return this}getIndex(){return this.index_}}class RangedFilter{constructor(params){this.indexedFilter_=new IndexedFilter(params.getIndex());this.index_=params.getIndex();this.startPost_=RangedFilter.getStartPost_(params);this.endPost_=RangedFilter.getEndPost_(params)}getStartPost(){return this.startPost_}getEndPost(){return this.endPost_}matches(node){return 0>=
this.index_.compare(this.getStartPost(),node)&&0>=this.index_.compare(node,this.getEndPost())}updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator){this.matches(new NamedNode(key,newChild))||(newChild=ChildrenNode.EMPTY_NODE);return this.indexedFilter_.updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator)}updateFullNode(oldSnap,newSnap,optChangeAccumulator){newSnap.isLeafNode()&&(newSnap=ChildrenNode.EMPTY_NODE);let filtered=newSnap.withIndex(this.index_);filtered=
filtered.updatePriority(ChildrenNode.EMPTY_NODE);const self=this;newSnap.forEachChild(PRIORITY_INDEX,(key,childNode)=>{self.matches(new NamedNode(key,childNode))||(filtered=filtered.updateImmediateChild(key,ChildrenNode.EMPTY_NODE))});return this.indexedFilter_.updateFullNode(oldSnap,filtered,optChangeAccumulator)}updatePriority(oldSnap,newPriority){return oldSnap}filtersNodes(){return!0}getIndexedFilter(){return this.indexedFilter_}getIndex(){return this.index_}static getStartPost_(params){if(params.hasStart()){const startName=
params.getIndexStartName();return params.getIndex().makePost(params.getIndexStartValue(),startName)}return params.getIndex().minPost()}static getEndPost_(params){if(params.hasEnd()){const endName=params.getIndexEndName();return params.getIndex().makePost(params.getIndexEndValue(),endName)}return params.getIndex().maxPost()}}class LimitedFilter{constructor(params){this.rangedFilter_=new RangedFilter(params);this.index_=params.getIndex();this.limit_=params.getLimit();this.reverse_=!params.isViewFromLeft()}updateChild(snap,
key,newChild,affectedPath,source,optChangeAccumulator){this.rangedFilter_.matches(new NamedNode(key,newChild))||(newChild=ChildrenNode.EMPTY_NODE);return snap.getImmediateChild(key).equals(newChild)?snap:snap.numChildren()<this.limit_?this.rangedFilter_.getIndexedFilter().updateChild(snap,key,newChild,affectedPath,source,optChangeAccumulator):this.fullLimitUpdateChild_(snap,key,newChild,source,optChangeAccumulator)}updateFullNode(oldSnap,newSnap,optChangeAccumulator){let filtered;if(newSnap.isLeafNode()||
newSnap.isEmpty())filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);else if(2*this.limit_<newSnap.numChildren()&&newSnap.isIndexed(this.index_)){filtered=ChildrenNode.EMPTY_NODE.withIndex(this.index_);newSnap=this.reverse_?newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(),this.index_):newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(),this.index_);for(var count$jscomp$0=0;newSnap.hasNext()&&count$jscomp$0<this.limit_;){var next$jscomp$0=newSnap.getNext();if(this.reverse_?
0>=this.index_.compare(this.rangedFilter_.getStartPost(),next$jscomp$0):0>=this.index_.compare(next$jscomp$0,this.rangedFilter_.getEndPost()))filtered=filtered.updateImmediateChild(next$jscomp$0.name,next$jscomp$0.node),count$jscomp$0++;else break}}else{filtered=newSnap.withIndex(this.index_);filtered=filtered.updatePriority(ChildrenNode.EMPTY_NODE);let iterator;if(this.reverse_){iterator=filtered.getReverseIterator(this.index_);newSnap=this.rangedFilter_.getEndPost();count$jscomp$0=this.rangedFilter_.getStartPost();
const indexCompare=this.index_.getCompare();next$jscomp$0=(a,b)=>indexCompare(b,a)}else iterator=filtered.getIterator(this.index_),newSnap=this.rangedFilter_.getStartPost(),count$jscomp$0=this.rangedFilter_.getEndPost(),next$jscomp$0=this.index_.getCompare();let count=0,foundStartPost=!1;for(;iterator.hasNext();){const next=iterator.getNext();!foundStartPost&&0>=next$jscomp$0(newSnap,next)&&(foundStartPost=!0);foundStartPost&&count<this.limit_&&0>=next$jscomp$0(next,count$jscomp$0)?count++:filtered=
filtered.updateImmediateChild(next.name,ChildrenNode.EMPTY_NODE)}}return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap,filtered,optChangeAccumulator)}updatePriority(oldSnap,newPriority){return oldSnap}filtersNodes(){return!0}getIndexedFilter(){return this.rangedFilter_.getIndexedFilter()}getIndex(){return this.index_}fullLimitUpdateChild_(snap,childKey,childSnap,source,changeAccumulator){let cmp;if(this.reverse_){const indexCmp=this.index_.getCompare();cmp=(a,b)=>indexCmp(b,a)}else cmp=
this.index_.getCompare();(0,_util.assert)(snap.numChildren()===this.limit_,"");const newChildNamedNode=new NamedNode(childKey,childSnap);var windowBoundary=this.reverse_?snap.getFirstChild(this.index_):snap.getLastChild(this.index_);const inRange=this.rangedFilter_.matches(newChildNamedNode);if(snap.hasChild(childKey)){const oldChildSnap=snap.getImmediateChild(childKey);for(windowBoundary=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);null!=windowBoundary&&(windowBoundary.name===
childKey||snap.hasChild(windowBoundary.name));)windowBoundary=source.getChildAfterChild(this.index_,windowBoundary,this.reverse_);source=null==windowBoundary?1:cmp(windowBoundary,newChildNamedNode);if(inRange&&!childSnap.isEmpty()&&0<=source)return null!=changeAccumulator&&changeAccumulator.trackChildChange(changeChildChanged(childKey,childSnap,oldChildSnap)),snap.updateImmediateChild(childKey,childSnap);null!=changeAccumulator&&changeAccumulator.trackChildChange(changeChildRemoved(childKey,oldChildSnap));
snap=snap.updateImmediateChild(childKey,ChildrenNode.EMPTY_NODE);return null!=windowBoundary&&this.rangedFilter_.matches(windowBoundary)?(null!=changeAccumulator&&changeAccumulator.trackChildChange(changeChildAdded(windowBoundary.name,windowBoundary.node)),snap.updateImmediateChild(windowBoundary.name,windowBoundary.node)):snap}return childSnap.isEmpty()?snap:inRange&&0<=cmp(windowBoundary,newChildNamedNode)?(null!=changeAccumulator&&(changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name,
windowBoundary.node)),changeAccumulator.trackChildChange(changeChildAdded(childKey,childSnap))),snap.updateImmediateChild(childKey,childSnap).updateImmediateChild(windowBoundary.name,ChildrenNode.EMPTY_NODE)):snap}}class QueryParams{constructor(){this.endBeforeSet_=this.endNameSet_=this.endSet_=this.startAfterSet_=this.startNameSet_=this.startSet_=this.limitSet_=!1;this.limit_=0;this.viewFrom_="";this.indexStartValue_=null;this.indexStartName_="";this.indexEndValue_=null;this.indexEndName_="";this.index_=
PRIORITY_INDEX}hasStart(){return this.startSet_}hasStartAfter(){return this.startAfterSet_}hasEndBefore(){return this.endBeforeSet_}isViewFromLeft(){return""===this.viewFrom_?this.startSet_:"l"===this.viewFrom_}getIndexStartValue(){(0,_util.assert)(this.startSet_,"Only valid if start has been set");return this.indexStartValue_}getIndexStartName(){(0,_util.assert)(this.startSet_,"Only valid if start has been set");return this.startNameSet_?this.indexStartName_:"[MIN_NAME]"}hasEnd(){return this.endSet_}getIndexEndValue(){(0,_util.assert)(this.endSet_,
"Only valid if end has been set");return this.indexEndValue_}getIndexEndName(){(0,_util.assert)(this.endSet_,"Only valid if end has been set");return this.endNameSet_?this.indexEndName_:"[MAX_NAME]"}hasLimit(){return this.limitSet_}hasAnchoredLimit(){return this.limitSet_&&""!==this.viewFrom_}getLimit(){(0,_util.assert)(this.limitSet_,"Only valid if limit has been set");return this.limit_}getIndex(){return this.index_}loadsAllData(){return!(this.startSet_||this.endSet_||this.limitSet_)}isDefault(){return this.loadsAllData()&&
this.index_===PRIORITY_INDEX}copy(){const copy=new QueryParams;copy.limitSet_=this.limitSet_;copy.limit_=this.limit_;copy.startSet_=this.startSet_;copy.indexStartValue_=this.indexStartValue_;copy.startNameSet_=this.startNameSet_;copy.indexStartName_=this.indexStartName_;copy.endSet_=this.endSet_;copy.indexEndValue_=this.indexEndValue_;copy.endNameSet_=this.endNameSet_;copy.indexEndName_=this.indexEndName_;copy.index_=this.index_;copy.viewFrom_=this.viewFrom_;return copy}}exports._QueryParams=QueryParams;
class ReadonlyRestClient extends ServerActions{constructor(repoInfo_,onDataUpdate_,authTokenProvider_,appCheckTokenProvider_){super();this.repoInfo_=repoInfo_;this.onDataUpdate_=onDataUpdate_;this.authTokenProvider_=authTokenProvider_;this.appCheckTokenProvider_=appCheckTokenProvider_;this.log_=logWrapper("p:rest:");this.listens_={}}reportStats(stats){throw Error("Method not implemented.");}static getListenId_(query,tag){if(void 0!==tag)return"tag$"+tag;(0,_util.assert)(query._queryParams.isDefault(),
"should have a tag if it's not a default query.");return query._path.toString()}listen(query,currentHashFn,tag,onComplete){const pathString=query._path.toString();this.log_("Listen called for "+pathString+" "+query._queryIdentifier);const listenId=ReadonlyRestClient.getListenId_(query,tag),thisListen={};this.listens_[listenId]=thisListen;query=queryParamsToRestQueryStringParameters(query._queryParams);this.restRequest_(pathString+".json",query,(error,result)=>{404===error&&(error=result=null);if(null===
error)this.onDataUpdate_(pathString,result,!1,tag);(0,_util.safeGet)(this.listens_,listenId)===thisListen&&onComplete(error?401===error?"permission_denied":"rest_error:"+error:"ok",null)})}unlisten(query,tag){query=ReadonlyRestClient.getListenId_(query,tag);delete this.listens_[query]}get(query){const queryStringParameters=queryParamsToRestQueryStringParameters(query._queryParams),pathString=query._path.toString(),deferred=new _util.Deferred;this.restRequest_(pathString+".json",queryStringParameters,
(error,result)=>{404===error&&(error=result=null);null===error?(this.onDataUpdate_(pathString,result,!1,null),deferred.resolve(result)):deferred.reject(Error(result))});return deferred.promise}refreshAuthToken(token){}restRequest_(pathString,queryStringParameters={},callback){queryStringParameters.format="export";return Promise.all([this.authTokenProvider_.getToken(!1),this.appCheckTokenProvider_.getToken(!1)]).then(([authToken,appCheckToken])=>{authToken&&authToken.accessToken&&(queryStringParameters.auth=
authToken.accessToken);appCheckToken&&appCheckToken.token&&(queryStringParameters.ac=appCheckToken.token);const url=(this.repoInfo_.secure?"https://":"http://")+this.repoInfo_.host+pathString+"?ns\x3d"+this.repoInfo_.namespace+(0,_util.querystring)(queryStringParameters);this.log_("Sending REST request for "+url);const xhr=new XMLHttpRequest;xhr.onreadystatechange=()=>{if(callback&&4===xhr.readyState){this.log_("REST Response for "+url+" received. status:",xhr.status,"response:",xhr.responseText);
let res=null;if(200<=xhr.status&&300>xhr.status){try{res=(0,_util.jsonEval)(xhr.responseText)}catch(e){warn("Failed to parse JSON response for "+url+": "+xhr.responseText)}callback(null,res)}else 401!==xhr.status&&404!==xhr.status&&warn("Got unsuccessful REST response for "+url+" Status: "+xhr.status),callback(xhr.status);callback=null}};xhr.open("GET",url,!0);xhr.send()})}}class SnapshotHolder{constructor(){this.rootNode_=ChildrenNode.EMPTY_NODE}getNode(path){return this.rootNode_.getChild(path)}updateSnapshot(path,
newSnapshotNode){this.rootNode_=this.rootNode_.updateChild(path,newSnapshotNode)}}class StatsListener{constructor(collection_){this.collection_=collection_;this.last_=null}get(){const newStats=this.collection_.get(),delta=Object.assign({},newStats);this.last_&&each(this.last_,(stat,value)=>{delta[stat]-=value});this.last_=newStats;return delta}}class StatsReporter{constructor(collection,server_){this.server_=server_;this.statsToReport_={};this.statsListener_=new StatsListener(collection);collection=
1E4+2E4*Math.random();setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(collection))}reportStats_(){const stats=this.statsListener_.get(),reportedStats={};let haveStatsToReport=!1;each(stats,(stat,value)=>{0<value&&(0,_util.contains)(this.statsToReport_,stat)&&(reportedStats[stat]=value,haveStatsToReport=!0)});haveStatsToReport&&this.server_.reportStats(reportedStats);setTimeoutNonBlocking(this.reportStats_.bind(this),Math.floor(6E5*Math.random()))}}var OperationType;(function(OperationType){OperationType[OperationType.OVERWRITE=
0]="OVERWRITE";OperationType[OperationType.MERGE=1]="MERGE";OperationType[OperationType.ACK_USER_WRITE=2]="ACK_USER_WRITE";OperationType[OperationType.LISTEN_COMPLETE=3]="LISTEN_COMPLETE"})(OperationType||(OperationType={}));class AckUserWrite{constructor(path,affectedTree,revert){this.path=path;this.affectedTree=affectedTree;this.revert=revert;this.type=OperationType.ACK_USER_WRITE;this.source=newOperationSourceUser()}operationForChild(childName){if(pathIsEmpty(this.path)){if(null!=this.affectedTree.value)return(0,_util.assert)(this.affectedTree.children.isEmpty(),
"affectedTree should not have overlapping affected paths."),this;childName=this.affectedTree.subtree(new Path(childName));return new AckUserWrite(newEmptyPath(),childName,this.revert)}(0,_util.assert)(pathGetFront(this.path)===childName,"operationForChild called for unrelated child.");return new AckUserWrite(pathPopFront(this.path),this.affectedTree,this.revert)}}class ListenComplete{constructor(source,path){this.source=source;this.path=path;this.type=OperationType.LISTEN_COMPLETE}operationForChild(childName){return pathIsEmpty(this.path)?
new ListenComplete(this.source,newEmptyPath()):new ListenComplete(this.source,pathPopFront(this.path))}}class Overwrite{constructor(source,path,snap){this.source=source;this.path=path;this.snap=snap;this.type=OperationType.OVERWRITE}operationForChild(childName){return pathIsEmpty(this.path)?new Overwrite(this.source,newEmptyPath(),this.snap.getImmediateChild(childName)):new Overwrite(this.source,pathPopFront(this.path),this.snap)}}class Merge{constructor(source,path,children){this.source=source;this.path=
path;this.children=children;this.type=OperationType.MERGE}operationForChild(childName){if(pathIsEmpty(this.path))return childName=this.children.subtree(new Path(childName)),childName.isEmpty()?null:childName.value?new Overwrite(this.source,newEmptyPath(),childName.value):new Merge(this.source,newEmptyPath(),childName);(0,_util.assert)(pathGetFront(this.path)===childName,"Can't get a merge for a child not on the path of the operation");return new Merge(this.source,pathPopFront(this.path),this.children)}toString(){return"Operation("+
this.path+": "+this.source.toString()+" merge: "+this.children.toString()+")"}}class CacheNode{constructor(node_,fullyInitialized_,filtered_){this.node_=node_;this.fullyInitialized_=fullyInitialized_;this.filtered_=filtered_}isFullyInitialized(){return this.fullyInitialized_}isFiltered(){return this.filtered_}isCompleteForPath(path){if(pathIsEmpty(path))return this.isFullyInitialized()&&!this.filtered_;path=pathGetFront(path);return this.isCompleteForChild(path)}isCompleteForChild(key){return this.isFullyInitialized()&&
!this.filtered_||this.node_.hasChild(key)}getNode(){return this.node_}}class EventGenerator{constructor(query_){this.query_=query_;this.index_=this.query_._queryParams.getIndex()}}let emptyChildrenSingleton;const EmptyChildren=()=>{emptyChildrenSingleton||(emptyChildrenSingleton=new SortedMap(stringCompare));return emptyChildrenSingleton};class ImmutableTree{constructor(value,children=EmptyChildren()){this.value=value;this.children=children}static fromObject(obj){let tree=new ImmutableTree(null);
each(obj,(childPath,childSnap)=>{tree=tree.set(new Path(childPath),childSnap)});return tree}isEmpty(){return null===this.value&&this.children.isEmpty()}findRootMostMatchingPathAndValue(relativePath,predicate){if(null!=this.value&&predicate(this.value))return{path:newEmptyPath(),value:this.value};if(pathIsEmpty(relativePath))return null;const front=pathGetFront(relativePath),child=this.children.get(front);return null!==child?(relativePath=child.findRootMostMatchingPathAndValue(pathPopFront(relativePath),
predicate),null!=relativePath?{path:pathChild(new Path(front),relativePath.path),value:relativePath.value}:null):null}findRootMostValueAndPath(relativePath){return this.findRootMostMatchingPathAndValue(relativePath,()=>!0)}subtree(relativePath){if(pathIsEmpty(relativePath))return this;var front=pathGetFront(relativePath);front=this.children.get(front);return null!==front?front.subtree(pathPopFront(relativePath)):new ImmutableTree(null)}set(relativePath,toSet){if(pathIsEmpty(relativePath))return new ImmutableTree(toSet,
this.children);var front=pathGetFront(relativePath);relativePath=(this.children.get(front)||new ImmutableTree(null)).set(pathPopFront(relativePath),toSet);front=this.children.insert(front,relativePath);return new ImmutableTree(this.value,front)}remove(relativePath){if(pathIsEmpty(relativePath))return this.children.isEmpty()?new ImmutableTree(null):new ImmutableTree(null,this.children);var front=pathGetFront(relativePath);const child=this.children.get(front);return child?(relativePath=child.remove(pathPopFront(relativePath)),
front=relativePath.isEmpty()?this.children.remove(front):this.children.insert(front,relativePath),null===this.value&&front.isEmpty()?new ImmutableTree(null):new ImmutableTree(this.value,front)):this}get(relativePath){if(pathIsEmpty(relativePath))return this.value;var front=pathGetFront(relativePath);return(front=this.children.get(front))?front.get(pathPopFront(relativePath)):null}setTree(relativePath,newTree){if(pathIsEmpty(relativePath))return newTree;var front=pathGetFront(relativePath);relativePath=
(this.children.get(front)||new ImmutableTree(null)).setTree(pathPopFront(relativePath),newTree);front=relativePath.isEmpty()?this.children.remove(front):this.children.insert(front,relativePath);return new ImmutableTree(this.value,front)}fold(fn){return this.fold_(newEmptyPath(),fn)}fold_(pathSoFar,fn){const accum={};this.children.inorderTraversal((childKey,childTree)=>{accum[childKey]=childTree.fold_(pathChild(pathSoFar,childKey),fn)});return fn(pathSoFar,this.value,accum)}findOnPath(path,f){return this.findOnPath_(path,
newEmptyPath(),f)}findOnPath_(pathToFollow,pathSoFar,f){var result=this.value?f(pathSoFar,this.value):!1;if(result)return result;if(pathIsEmpty(pathToFollow))return null;result=pathGetFront(pathToFollow);const nextChild=this.children.get(result);return nextChild?nextChild.findOnPath_(pathPopFront(pathToFollow),pathChild(pathSoFar,result),f):null}foreachOnPath(path,f){return this.foreachOnPath_(path,newEmptyPath(),f)}foreachOnPath_(pathToFollow,currentRelativePath,f){if(pathIsEmpty(pathToFollow))return this;
this.value&&f(currentRelativePath,this.value);const front=pathGetFront(pathToFollow),nextChild=this.children.get(front);return nextChild?nextChild.foreachOnPath_(pathPopFront(pathToFollow),pathChild(currentRelativePath,front),f):new ImmutableTree(null)}foreach(f){this.foreach_(newEmptyPath(),f)}foreach_(currentRelativePath,f){this.children.inorderTraversal((childName,childTree)=>{childTree.foreach_(pathChild(currentRelativePath,childName),f)});this.value&&f(currentRelativePath,this.value)}foreachChild(f){this.children.inorderTraversal((childName,
childTree)=>{childTree.value&&f(childName,childTree.value)})}}class CompoundWrite{constructor(writeTree_){this.writeTree_=writeTree_}static empty(){return new CompoundWrite(new ImmutableTree(null))}}class ChildChangeAccumulator{constructor(){this.changeMap=new Map}trackChildChange(change){const type=change.type,childKey=change.childName;(0,_util.assert)("child_added"===type||"child_changed"===type||"child_removed"===type,"Only child changes supported for tracking");(0,_util.assert)(".priority"!==
childKey,"Only non-priority child changes can be tracked.");const oldChange=this.changeMap.get(childKey);if(oldChange){const oldType=oldChange.type;if("child_added"===type&&"child_removed"===oldType)this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.snapshotNode));else if("child_removed"===type&&"child_added"===oldType)this.changeMap.delete(childKey);else if("child_removed"===type&&"child_changed"===oldType)this.changeMap.set(childKey,changeChildRemoved(childKey,
oldChange.oldSnap));else if("child_changed"===type&&"child_added"===oldType)this.changeMap.set(childKey,changeChildAdded(childKey,change.snapshotNode));else if("child_changed"===type&&"child_changed"===oldType)this.changeMap.set(childKey,changeChildChanged(childKey,change.snapshotNode,oldChange.oldSnap));else throw(0,_util.assertionError)("Illegal combination of changes: "+change+" occurred after "+oldChange);}else this.changeMap.set(childKey,change)}getChanges(){return Array.from(this.changeMap.values())}}
class NoCompleteChildSource_{getCompleteChild(childKey){return null}getChildAfterChild(index,child,reverse){return null}}const NO_COMPLETE_CHILD_SOURCE=new NoCompleteChildSource_;class WriteTreeCompleteChildSource{constructor(writes_,viewCache_,optCompleteServerCache_=null){this.writes_=writes_;this.viewCache_=viewCache_;this.optCompleteServerCache_=optCompleteServerCache_}getCompleteChild(childKey){var node=this.viewCache_.eventCache;if(node.isCompleteForChild(childKey))return node.getNode().getImmediateChild(childKey);
node=null!=this.optCompleteServerCache_?new CacheNode(this.optCompleteServerCache_,!0,!1):this.viewCache_.serverCache;var writeTreeRef=this.writes_;return writeTreeCalcCompleteChild(writeTreeRef.writeTree,writeTreeRef.treePath,childKey,node)}getChildAfterChild(index,child,reverse){var completeServerData=null!=this.optCompleteServerCache_?this.optCompleteServerCache_:viewCacheGetCompleteServerSnap(this.viewCache_),writeTreeRef=this.writes_;a:{writeTreeRef=compoundWriteChildCompoundWrite(writeTreeRef.writeTree.visibleWrites,
writeTreeRef.treePath);var toIterate=compoundWriteGetCompleteNode(writeTreeRef,newEmptyPath());if(null==toIterate)if(null!=completeServerData)toIterate=compoundWriteApply(writeTreeRef,completeServerData);else{child=[];break a}toIterate=toIterate.withIndex(index);if(toIterate.isEmpty()||toIterate.isLeafNode())child=[];else{completeServerData=[];writeTreeRef=index.getCompare();index=reverse?toIterate.getReverseIteratorFrom(child,index):toIterate.getIteratorFrom(child,index);for(reverse=index.getNext();reverse&&
1>completeServerData.length;)0!==writeTreeRef(reverse,child)&&completeServerData.push(reverse),reverse=index.getNext();child=completeServerData}}return 0===child.length?null:child[0]}}class View{constructor(query_,initialViewCache){this.query_=query_;this.eventRegistrations_=[];var params=this.query_._queryParams;query_=new IndexedFilter(params.getIndex());params=params.loadsAllData()?new IndexedFilter(params.getIndex()):params.hasLimit()?new LimitedFilter(params):new RangedFilter(params);this.processor_=
{filter:params};const initialServerCache=initialViewCache.serverCache;initialViewCache=initialViewCache.eventCache;const serverSnap=query_.updateFullNode(ChildrenNode.EMPTY_NODE,initialServerCache.getNode(),null),eventSnap=params.updateFullNode(ChildrenNode.EMPTY_NODE,initialViewCache.getNode(),null);query_=new CacheNode(serverSnap,initialServerCache.isFullyInitialized(),query_.filtersNodes());params=new CacheNode(eventSnap,initialViewCache.isFullyInitialized(),params.filtersNodes());this.viewCache_=
newViewCache(params,query_);this.eventGenerator_=new EventGenerator(this.query_)}get query(){return this.query_}}let referenceConstructor$1;class SyncPoint{constructor(){this.views=new Map}}let referenceConstructor,syncTreeNextQueryTag_=1;class SyncTree{constructor(listenProvider_){this.listenProvider_=listenProvider_;this.syncPointTree_=new ImmutableTree(null);this.pendingWriteTree_={visibleWrites:CompoundWrite.empty(),allWrites:[],lastWriteId:-1};this.tagToQueryMap=new Map;this.queryToTagMap=new Map}}
class ExistingValueProvider{constructor(node_){this.node_=node_}getImmediateChild(childName){childName=this.node_.getImmediateChild(childName);return new ExistingValueProvider(childName)}node(){return this.node_}}class DeferredValueProvider{constructor(syncTree,path){this.syncTree_=syncTree;this.path_=path}getImmediateChild(childName){childName=pathChild(this.path_,childName);return new DeferredValueProvider(this.syncTree_,childName)}node(){return syncTreeCalcCompleteEventCache(this.syncTree_,this.path_)}}
const resolveDeferredLeafValue=function(value,existingVal,serverValues){if(!value||"object"!==typeof value)return value;(0,_util.assert)(".sv"in value,"Unexpected leaf node or priority contents");if("string"===typeof value[".sv"]){a:{existingVal=value[".sv"];switch(existingVal){case "timestamp":existingVal=serverValues.timestamp;break a;default:(0,_util.assert)(!1,"Unexpected server value: "+existingVal)}existingVal=void 0}return existingVal}if("object"===typeof value[".sv"])return serverValues=value[".sv"],
serverValues.hasOwnProperty("increment")||(0,_util.assert)(!1,"Unexpected server value: "+JSON.stringify(serverValues,null,2)),serverValues=serverValues.increment,"number"!==typeof serverValues&&(0,_util.assert)(!1,"Unexpected increment value: "+serverValues),existingVal=existingVal.node(),(0,_util.assert)(null!==existingVal&&"undefined"!==typeof existingVal,"Expected ChildrenNode.EMPTY_NODE for nulls"),existingVal.isLeafNode()?(existingVal=existingVal.getValue(),existingVal="number"!==typeof existingVal?
serverValues:existingVal+serverValues):existingVal=serverValues,existingVal;(0,_util.assert)(!1,"Unexpected server value: "+JSON.stringify(value,null,2))},resolveDeferredValueSnapshot=function(node,existing,serverValues){return resolveDeferredValue(node,new ExistingValueProvider(existing),serverValues)};class Tree{constructor(name="",parent=null,node={children:{},childCount:0}){this.name=name;this.parent=parent;this.node=node}}const INVALID_KEY_REGEX_=/[\[\].#$\/\u0000-\u001F\u007F]/,INVALID_PATH_REGEX_=
/[\[\].#$\u0000-\u001F\u007F]/,isValidKey=function(key){return"string"===typeof key&&0!==key.length&&!INVALID_KEY_REGEX_.test(key)},isValidPathString=function(pathString){return"string"===typeof pathString&&0!==pathString.length&&!INVALID_PATH_REGEX_.test(pathString)},isValidPriority=function(priority){return null===priority||"string"===typeof priority||"number"===typeof priority&&!isInvalidJSONNumber(priority)||priority&&"object"===typeof priority&&(0,_util.contains)(priority,".sv")},validateFirebaseDataArg=
function(fnName,value,path,optional){optional&&void 0===value||validateFirebaseData((0,_util.errorPrefix)(fnName,"value"),value,path)},validateFirebaseData=function(errorPrefix,data,path_){const path=path_ instanceof Path?new ValidationPath(path_,errorPrefix):path_;if(void 0===data)throw Error(errorPrefix+"contains undefined "+validationPathToErrorString(path));if("function"===typeof data)throw Error(errorPrefix+"contains a function "+validationPathToErrorString(path)+" with contents \x3d "+data.toString());
if(isInvalidJSONNumber(data))throw Error(errorPrefix+"contains "+data.toString()+" "+validationPathToErrorString(path));if("string"===typeof data&&data.length>10485760/3&&10485760<(0,_util.stringLength)(data))throw Error(errorPrefix+"contains a string greater than 10485760 utf8 bytes "+validationPathToErrorString(path)+" ('"+data.substring(0,50)+"...')");if(data&&"object"===typeof data){let hasDotValue=!1,hasActualChild=!1;each(data,(key,value)=>{if(".value"===key)hasDotValue=!0;else if(".priority"!==
key&&".sv"!==key&&(hasActualChild=!0,!isValidKey(key)))throw Error(errorPrefix+" contains an invalid key ("+key+") "+validationPathToErrorString(path)+'.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');0<path.parts_.length&&(path.byteLength_+=1);path.parts_.push(key);path.byteLength_+=(0,_util.stringLength)(key);validationPathCheckValid(path);validateFirebaseData(errorPrefix,value,path);key=path.parts_.pop();path.byteLength_-=(0,_util.stringLength)(key);0<path.parts_.length&&
--path.byteLength_});if(hasDotValue&&hasActualChild)throw Error(errorPrefix+' contains ".value" child '+validationPathToErrorString(path)+" in addition to actual children.");}},validateFirebaseMergePaths=function(errorPrefix,mergePaths){let i,curPath;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];var keys=pathSlice(curPath);for(let j=0;j<keys.length;j++)if((".priority"!==keys[j]||j!==keys.length-1)&&!isValidKey(keys[j]))throw Error(errorPrefix+"contains an invalid key ("+keys[j]+") in path "+
curPath.toString()+'. Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"');}mergePaths.sort(pathCompare);keys=null;for(i=0;i<mergePaths.length;i++){curPath=mergePaths[i];if(null!==keys&&pathContains(keys,curPath))throw Error(errorPrefix+"contains a path "+keys.toString()+" that is ancestor of another path "+curPath.toString());keys=curPath}},validateFirebaseMergeDataArg=function(fnName,data,path,optional){if(!optional||void 0!==data){var errorPrefix$1=(0,_util.errorPrefix)(fnName,
"values");if(!data||"object"!==typeof data||Array.isArray(data))throw Error(errorPrefix$1+" must be an object containing the children to replace.");var mergePaths=[];each(data,(key,value)=>{key=new Path(key);validateFirebaseData(errorPrefix$1,value,pathChild(path,key));if(".priority"===pathGetBack(key)&&!isValidPriority(value))throw Error(errorPrefix$1+"contains an invalid value for '"+key.toString()+"', which must be a valid Firebase priority (a string, finite number, server value, or null).");mergePaths.push(key)});
validateFirebaseMergePaths(errorPrefix$1,mergePaths)}},validatePriority=function(fnName,priority,optional){if(!optional||void 0!==priority){if(isInvalidJSONNumber(priority))throw Error((0,_util.errorPrefix)(fnName,"priority")+"is "+priority.toString()+", but must be a valid Firebase priority (a string, finite number, server value, or null).");if(!isValidPriority(priority))throw Error((0,_util.errorPrefix)(fnName,"priority")+"must be a valid Firebase priority (a string, finite number, server value, or null).");
}},validateKey=function(fnName,argumentName,key,optional){if(!(optional&&void 0===key||isValidKey(key)))throw Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid key \x3d "'+key+'".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").');},validatePathString=function(fnName,argumentName,pathString,optional){if(!(optional&&void 0===pathString||isValidPathString(pathString)))throw Error((0,_util.errorPrefix)(fnName,argumentName)+'was an invalid path \x3d "'+
pathString+'". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"');};exports._validatePathString=validatePathString;const validateWritablePath=function(fnName,path){if(".info"===pathGetFront(path))throw Error(fnName+" failed \x3d Can't modify data under /.info/");};exports._validateWritablePath=validateWritablePath;const validateUrl=function(fnName,parsedUrl){var pathString=parsedUrl.path.toString();!(parsedUrl="string"!==typeof parsedUrl.repoInfo.host||0===parsedUrl.repoInfo.host.length||
!isValidKey(parsedUrl.repoInfo.namespace)&&"localhost"!==parsedUrl.repoInfo.host.split(":")[0])&&(parsedUrl=0!==pathString.length)&&(pathString&&(pathString=pathString.replace(/^\/*\.info(\/|$)/,"/")),parsedUrl=!isValidPathString(pathString));if(parsedUrl)throw Error((0,_util.errorPrefix)(fnName,"url")+'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".');};class EventQueue{constructor(){this.eventLists_=[];this.recursionDepth_=0}}class Repo{constructor(repoInfo_,
forceRestClient_,authTokenProvider_,appCheckProvider_){this.repoInfo_=repoInfo_;this.forceRestClient_=forceRestClient_;this.authTokenProvider_=authTokenProvider_;this.appCheckProvider_=appCheckProvider_;this.dataUpdateCount=0;this.statsListener_=null;this.eventQueue_=new EventQueue;this.nextWriteId_=1;this.interceptServerDataCallback_=null;this.onDisconnect_=newSparseSnapshotTree();this.transactionQueueTree_=new Tree;this.persistentConnection_=null;this.key=this.repoInfo_.toURLString()}toString(){return(this.repoInfo_.secure?
"https://":"http://")+this.repoInfo_.host}}const parseRepoInfo=function(dataURL,nodeAdmin){var JSCompiler_object_inline_host_1090,JSCompiler_object_inline_subdomain_1093,JSCompiler_object_inline_pathString_1096,dataURL$jscomp$0=dataURL,domain=JSCompiler_object_inline_host_1090="";dataURL=JSCompiler_object_inline_pathString_1096=JSCompiler_object_inline_subdomain_1093="";var JSCompiler_object_inline_secure_1094=!0;var JSCompiler_object_inline_scheme_1095="https";if("string"===typeof dataURL$jscomp$0){domain=
dataURL$jscomp$0.indexOf("//");0<=domain&&(JSCompiler_object_inline_scheme_1095=dataURL$jscomp$0.substring(0,domain-1),dataURL$jscomp$0=dataURL$jscomp$0.substring(domain+2));var slashInd=dataURL$jscomp$0.indexOf("/");-1===slashInd&&(slashInd=dataURL$jscomp$0.length);domain=dataURL$jscomp$0.indexOf("?");-1===domain&&(domain=dataURL$jscomp$0.length);JSCompiler_object_inline_host_1090=dataURL$jscomp$0.substring(0,Math.min(slashInd,domain));if(slashInd<domain){JSCompiler_object_inline_pathString_1096=
"";slashInd=dataURL$jscomp$0.substring(slashInd,domain).split("/");for(let i=0;i<slashInd.length;i++)if(0<slashInd[i].length){let piece=slashInd[i];try{piece=decodeURIComponent(piece.replace(/\+/g," "))}catch(e){}JSCompiler_object_inline_pathString_1096+="/"+piece}}dataURL$jscomp$0=dataURL$jscomp$0.substring(Math.min(dataURL$jscomp$0.length,domain));domain={};"?"===dataURL$jscomp$0.charAt(0)&&(dataURL$jscomp$0=dataURL$jscomp$0.substring(1));for(JSCompiler_object_inline_domain_1092 of dataURL$jscomp$0.split("\x26"))0!==
JSCompiler_object_inline_domain_1092.length&&(slashInd=JSCompiler_object_inline_domain_1092.split("\x3d"),2===slashInd.length?domain[decodeURIComponent(slashInd[0])]=decodeURIComponent(slashInd[1]):warn(`Invalid query segment '${JSCompiler_object_inline_domain_1092}' in query '${dataURL$jscomp$0}'`));var JSCompiler_object_inline_domain_1092=domain;domain=JSCompiler_object_inline_host_1090.indexOf(":");0<=domain?(JSCompiler_object_inline_secure_1094="https"===JSCompiler_object_inline_scheme_1095||
"wss"===JSCompiler_object_inline_scheme_1095,parseInt(JSCompiler_object_inline_host_1090.substring(domain+1),10)):domain=JSCompiler_object_inline_host_1090.length;dataURL$jscomp$0=JSCompiler_object_inline_host_1090.slice(0,domain);"localhost"===dataURL$jscomp$0.toLowerCase()?domain="localhost":2>=dataURL$jscomp$0.split(".").length?domain=dataURL$jscomp$0:(dataURL=JSCompiler_object_inline_host_1090.indexOf("."),JSCompiler_object_inline_subdomain_1093=JSCompiler_object_inline_host_1090.substring(0,
dataURL).toLowerCase(),domain=JSCompiler_object_inline_host_1090.substring(dataURL+1),dataURL=JSCompiler_object_inline_subdomain_1093);"ns"in JSCompiler_object_inline_domain_1092&&(dataURL=JSCompiler_object_inline_domain_1092.ns)}JSCompiler_object_inline_domain_1092=domain;"firebase.com"===JSCompiler_object_inline_domain_1092&&fatal(JSCompiler_object_inline_host_1090+" is no longer supported. Please use \x3cYOUR FIREBASE\x3e.firebaseio.com instead");dataURL&&"undefined"!==dataURL||"localhost"===JSCompiler_object_inline_domain_1092||
fatal("Cannot parse Firebase url. Please use https://\x3cYOUR FIREBASE\x3e.firebaseio.com");JSCompiler_object_inline_secure_1094||"undefined"!==typeof window&&window.location&&window.location.protocol&&-1!==window.location.protocol.indexOf("https:")&&warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");return{repoInfo:new RepoInfo(JSCompiler_object_inline_host_1090,JSCompiler_object_inline_secure_1094,dataURL,"ws"===JSCompiler_object_inline_scheme_1095||
"wss"===JSCompiler_object_inline_scheme_1095,nodeAdmin,"",dataURL!==JSCompiler_object_inline_subdomain_1093),path:new Path(JSCompiler_object_inline_pathString_1096)}};class DataEvent{constructor(eventType,eventRegistration,snapshot,prevName){this.eventType=eventType;this.eventRegistration=eventRegistration;this.snapshot=snapshot;this.prevName=prevName}getPath(){const ref=this.snapshot.ref;return"value"===this.eventType?ref._path:ref.parent._path}getEventType(){return this.eventType}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.getPath().toString()+
":"+this.eventType+":"+(0,_util.stringify)(this.snapshot.exportVal())}}class CancelEvent{constructor(eventRegistration,error,path){this.eventRegistration=eventRegistration;this.error=error;this.path=path}getPath(){return this.path}getEventType(){return"cancel"}getEventRunner(){return this.eventRegistration.getEventRunner(this)}toString(){return this.path.toString()+":cancel"}}class CallbackContext{constructor(snapshotCallback,cancelCallback){this.snapshotCallback=snapshotCallback;this.cancelCallback=
cancelCallback}onValue(expDataSnapshot,previousChildName){this.snapshotCallback.call(null,expDataSnapshot,previousChildName)}onCancel(error){(0,_util.assert)(this.hasCancelCallback,"Raising a cancel event on a listener with no cancel callback");return this.cancelCallback.call(null,error)}get hasCancelCallback(){return!!this.cancelCallback}matches(other){return this.snapshotCallback===other.snapshotCallback||void 0!==this.snapshotCallback.userCallback&&this.snapshotCallback.userCallback===other.snapshotCallback.userCallback&&
this.snapshotCallback.context===other.snapshotCallback.context}}class OnDisconnect{constructor(_repo,_path){this._repo=_repo;this._path=_path}cancel(){const deferred=new _util.Deferred;repoOnDisconnectCancel(this._repo,this._path,deferred.wrapCallback(()=>{}));return deferred.promise}remove(){validateWritablePath("OnDisconnect.remove",this._path);const deferred=new _util.Deferred;repoOnDisconnectSet(this._repo,this._path,null,deferred.wrapCallback(()=>{}));return deferred.promise}set(value){validateWritablePath("OnDisconnect.set",
this._path);validateFirebaseDataArg("OnDisconnect.set",value,this._path,!1);const deferred=new _util.Deferred;repoOnDisconnectSet(this._repo,this._path,value,deferred.wrapCallback(()=>{}));return deferred.promise}setWithPriority(value,priority){validateWritablePath("OnDisconnect.setWithPriority",this._path);validateFirebaseDataArg("OnDisconnect.setWithPriority",value,this._path,!1);validatePriority("OnDisconnect.setWithPriority",priority,!1);const deferred=new _util.Deferred;repoOnDisconnectSetWithPriority(this._repo,
this._path,value,priority,deferred.wrapCallback(()=>{}));return deferred.promise}update(values){validateWritablePath("OnDisconnect.update",this._path);validateFirebaseMergeDataArg("OnDisconnect.update",values,this._path,!1);const deferred=new _util.Deferred;repoOnDisconnectUpdate(this._repo,this._path,values,deferred.wrapCallback(()=>{}));return deferred.promise}}exports.OnDisconnect=OnDisconnect;class QueryImpl{constructor(_repo,_path,_queryParams,_orderByCalled){this._repo=_repo;this._path=_path;
this._queryParams=_queryParams;this._orderByCalled=_orderByCalled}get key(){return pathIsEmpty(this._path)?null:pathGetBack(this._path)}get ref(){return new ReferenceImpl(this._repo,this._path)}get _queryIdentifier(){var obj=queryParamsGetQueryObject(this._queryParams);obj=ObjectToUniqueKey(obj);return"{}"===obj?"default":obj}get _queryObject(){return queryParamsGetQueryObject(this._queryParams)}isEqual(other){other=(0,_util.getModularInstance)(other);if(!(other instanceof QueryImpl))return!1;const sameRepo=
this._repo===other._repo,samePath=pathEquals(this._path,other._path);other=this._queryIdentifier===other._queryIdentifier;return sameRepo&&samePath&&other}toJSON(){return this.toString()}toString(){var JSCompiler_temp_const=this._repo.toString(),path=this._path;let pathString="";for(let i=path.pieceNum_;i<path.pieces_.length;i++)""!==path.pieces_[i]&&(pathString+="/"+encodeURIComponent(String(path.pieces_[i])));return JSCompiler_temp_const+(pathString||"/")}}exports._QueryImpl=QueryImpl;class ReferenceImpl extends QueryImpl{constructor(repo,
path){super(repo,path,new QueryParams,!1)}get parent(){const parentPath=pathParent(this._path);return null===parentPath?null:new ReferenceImpl(this._repo,parentPath)}get root(){let ref=this;for(;null!==ref.parent;)ref=ref.parent;return ref}}exports._ReferenceImpl=ReferenceImpl;class DataSnapshot{constructor(_node,ref,_index){this._node=_node;this.ref=ref;this._index=_index}get priority(){return this._node.getPriority().val()}get key(){return this.ref.key}get size(){return this._node.numChildren()}child(path){const childPath=
new Path(path);path=child$jscomp$0(this.ref,path);return new DataSnapshot(this._node.getChild(childPath),path,PRIORITY_INDEX)}exists(){return!this._node.isEmpty()}exportVal(){return this._node.val(!0)}forEach(action){return this._node.isLeafNode()?!1:!!this._node.forEachChild(this._index,(key,node)=>action(new DataSnapshot(node,child$jscomp$0(this.ref,key),PRIORITY_INDEX)))}hasChild(path){path=new Path(path);return!this._node.getChild(path).isEmpty()}hasChildren(){return this._node.isLeafNode()?!1:
!this._node.isEmpty()}toJSON(){return this.exportVal()}val(){return this._node.val()}}exports.DataSnapshot=DataSnapshot;class ValueEventRegistration{constructor(callbackContext){this.callbackContext=callbackContext}respondsTo(eventType){return"value"===eventType}createEvent(change,query){const index=query._queryParams.getIndex();return new DataEvent("value",this,new DataSnapshot(change.snapshotNode,new ReferenceImpl(query._repo,query._path),index))}getEventRunner(eventData){return"cancel"===eventData.getEventType()?
()=>this.callbackContext.onCancel(eventData.error):()=>this.callbackContext.onValue(eventData.snapshot,null)}createCancelEvent(error,path){return this.callbackContext.hasCancelCallback?new CancelEvent(this,error,path):null}matches(other){return other instanceof ValueEventRegistration?other.callbackContext&&this.callbackContext?other.callbackContext.matches(this.callbackContext):!0:!1}hasAnyCallback(){return null!==this.callbackContext}}class ChildEventRegistration{constructor(eventType,callbackContext){this.eventType=
eventType;this.callbackContext=callbackContext}respondsTo(eventType){eventType="children_added"===eventType?"child_added":eventType;return this.eventType===("children_removed"===eventType?"child_removed":eventType)}createCancelEvent(error,path){return this.callbackContext.hasCancelCallback?new CancelEvent(this,error,path):null}createEvent(change,query){(0,_util.assert)(null!=change.childName,"Child events should have a childName.");const childRef=child$jscomp$0(new ReferenceImpl(query._repo,query._path),
change.childName);query=query._queryParams.getIndex();return new DataEvent(change.type,this,new DataSnapshot(change.snapshotNode,childRef,query),change.prevName)}getEventRunner(eventData){return"cancel"===eventData.getEventType()?()=>this.callbackContext.onCancel(eventData.error):()=>this.callbackContext.onValue(eventData.snapshot,eventData.prevName)}matches(other){return other instanceof ChildEventRegistration?this.eventType===other.eventType&&(!this.callbackContext||!other.callbackContext||this.callbackContext.matches(other.callbackContext)):
!1}hasAnyCallback(){return!!this.callbackContext}}class QueryConstraint{}exports.QueryConstraint=QueryConstraint;class QueryEndAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key}_apply(query){validateFirebaseDataArg("endAt",this._value,query._path,!0);const newParams=queryParamsEndAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasEnd())throw Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}class QueryEndBeforeConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key}_apply(query){validateFirebaseDataArg("endBefore",this._value,query._path,!1);var JSCompiler_inline_result=query._queryParams;var indexValue=this._value,key=this._key;JSCompiler_inline_result.index_===KEY_INDEX?("string"===typeof indexValue&&(indexValue=predecessor(indexValue)),JSCompiler_inline_result=
queryParamsEndAt(JSCompiler_inline_result,indexValue,key)):(key=null==key?"[MIN_NAME]":predecessor(key),JSCompiler_inline_result=queryParamsEndAt(JSCompiler_inline_result,indexValue,key));JSCompiler_inline_result.endBeforeSet_=!0;validateLimit(JSCompiler_inline_result);validateQueryEndpoints(JSCompiler_inline_result);if(query._queryParams.hasEnd())throw Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");return new QueryImpl(query._repo,query._path,
JSCompiler_inline_result,query._orderByCalled)}}class QueryStartAtConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key}_apply(query){validateFirebaseDataArg("startAt",this._value,query._path,!0);const newParams=queryParamsStartAt(query._queryParams,this._value,this._key);validateLimit(newParams);validateQueryEndpoints(newParams);if(query._queryParams.hasStart())throw Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
return new QueryImpl(query._repo,query._path,newParams,query._orderByCalled)}}class QueryStartAfterConstraint extends QueryConstraint{constructor(_value,_key){super();this._value=_value;this._key=_key}_apply(query){validateFirebaseDataArg("startAfter",this._value,query._path,!1);var JSCompiler_inline_result=query._queryParams;var indexValue=this._value,key=this._key;JSCompiler_inline_result.index_===KEY_INDEX?("string"===typeof indexValue&&(indexValue=successor(indexValue)),JSCompiler_inline_result=
queryParamsStartAt(JSCompiler_inline_result,indexValue,key)):(key=null==key?"[MAX_NAME]":successor(key),JSCompiler_inline_result=queryParamsStartAt(JSCompiler_inline_result,indexValue,key));JSCompiler_inline_result.startAfterSet_=!0;validateLimit(JSCompiler_inline_result);validateQueryEndpoints(JSCompiler_inline_result);if(query._queryParams.hasStart())throw Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");return new QueryImpl(query._repo,query._path,
JSCompiler_inline_result,query._orderByCalled)}}class QueryLimitToFirstConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit}_apply(query){if(query._queryParams.hasLimit())throw Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");var JSCompiler_temp_const=query._repo,JSCompiler_temp_const$jscomp$0=query._path,newLimit=this._limit;const newParams=query._queryParams.copy();newParams.limitSet_=!0;newParams.limit_=newLimit;newParams.viewFrom_=
"l";return new QueryImpl(JSCompiler_temp_const,JSCompiler_temp_const$jscomp$0,newParams,query._orderByCalled)}}class QueryLimitToLastConstraint extends QueryConstraint{constructor(_limit){super();this._limit=_limit}_apply(query){if(query._queryParams.hasLimit())throw Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");var JSCompiler_temp_const=query._repo,JSCompiler_temp_const$jscomp$0=query._path,newLimit=this._limit;const newParams=query._queryParams.copy();
newParams.limitSet_=!0;newParams.limit_=newLimit;newParams.viewFrom_="r";return new QueryImpl(JSCompiler_temp_const,JSCompiler_temp_const$jscomp$0,newParams,query._orderByCalled)}}class QueryOrderByChildConstraint extends QueryConstraint{constructor(_path){super();this._path=_path}_apply(query){validateNoPreviousOrderByCall(query,"orderByChild");var parsedPath=new Path(this._path);if(pathIsEmpty(parsedPath))throw Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");parsedPath=
new PathIndex(parsedPath);parsedPath=queryParamsOrderBy(query._queryParams,parsedPath);validateQueryEndpoints(parsedPath);return new QueryImpl(query._repo,query._path,parsedPath,!0)}}class QueryOrderByKeyConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,"orderByKey");const newParams=queryParamsOrderBy(query._queryParams,KEY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,!0)}}class QueryOrderByPriorityConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,
"orderByPriority");const newParams=queryParamsOrderBy(query._queryParams,PRIORITY_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,!0)}}class QueryOrderByValueConstraint extends QueryConstraint{_apply(query){validateNoPreviousOrderByCall(query,"orderByValue");const newParams=queryParamsOrderBy(query._queryParams,VALUE_INDEX);validateQueryEndpoints(newParams);return new QueryImpl(query._repo,query._path,newParams,!0)}}class QueryEqualToValueConstraint extends QueryConstraint{constructor(_value,
_key){super();this._value=_value;this._key=_key}_apply(query){validateFirebaseDataArg("equalTo",this._value,query._path,!1);if(query._queryParams.hasStart())throw Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");if(query._queryParams.hasEnd())throw Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");return(new QueryEndAtConstraint(this._value,this._key))._apply((new QueryStartAtConstraint(this._value,this._key))._apply(query))}}
(function(val){(0,_util.assert)(!referenceConstructor$1,"__referenceConstructor has already been defined");referenceConstructor$1=val})(ReferenceImpl);(function(val){(0,_util.assert)(!referenceConstructor,"__referenceConstructor has already been defined");referenceConstructor=val})(ReferenceImpl);const repos={};let useRestClient=!1;class Database{constructor(_repoInternal,app){this._repoInternal=_repoInternal;this.app=app;this.type="database";this._instanceStarted=!1}get _repo(){this._instanceStarted||
(repoStart(this._repoInternal,this.app.options.appId,this.app.options.databaseAuthVariableOverride),this._instanceStarted=!0);return this._repoInternal}get _root(){this._rootInternal||(this._rootInternal=new ReferenceImpl(this._repo,newEmptyPath()));return this._rootInternal}_delete(){if(null!==this._rootInternal){var repo=this._repo,appName=this.app.name;const appRepos=repos[appName];appRepos&&appRepos[repo.key]===repo||fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);repoInterrupt(repo);
delete appRepos[repo.key];this._rootInternal=this._repoInternal=null}return Promise.resolve()}_checkNotDeleted(apiName){null===this._rootInternal&&fatal("Cannot call "+apiName+" on a deleted database.")}}exports.Database=Database;const SERVER_TIMESTAMP={".sv":"timestamp"};class TransactionResult{constructor(committed,snapshot){this.committed=committed;this.snapshot=snapshot}toJSON(){return{committed:this.committed,snapshot:this.snapshot.toJSON()}}}exports.TransactionResult=TransactionResult;PersistentConnection;
PersistentConnection.prototype.simpleListen=function(pathString,onComplete){this.sendRequest("q",{p:pathString},onComplete)};PersistentConnection.prototype.echo=function(data,onEcho){this.sendRequest("echo",{d:data},onEcho)};Connection;exports._TEST_ACCESS_hijackHash=function(newHash){const oldPut=PersistentConnection.prototype.put;PersistentConnection.prototype.put=function(pathString,data,onComplete,hash){void 0!==hash&&(hash=newHash());oldPut.call(this,pathString,data,onComplete,hash)};return function(){PersistentConnection.prototype.put=
oldPut}};RepoInfo;exports._TEST_ACCESS_forceRestClient=function(forceRestClient){useRestClient=forceRestClient};(function(variant){SDK_VERSION=_app.SDK_VERSION;(0,_app._registerComponent)((new _component.Component("database",(container,{instanceIdentifier:url})=>{const app=container.getProvider("app").getImmediate(),authProvider=container.getProvider("auth-internal");container=container.getProvider("app-check-internal");return repoManagerDatabaseFromApp(app,authProvider,container,url)},"PUBLIC")).setMultipleInstances(!0));
(0,_app.registerVersion)("@firebase/database","0.12.8",variant);(0,_app.registerVersion)("@firebase/database","0.12.8","esm2017")})()}
//# sourceMappingURL=module$node_modules$$firebase$database$dist$index_esm2017.js.map
