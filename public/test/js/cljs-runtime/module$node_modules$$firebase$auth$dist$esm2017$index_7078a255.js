shadow$provide.module$node_modules$$firebase$auth$dist$esm2017$index_7078a255=function(global,require,module,exports){function _prodErrorMap(){return{["dependent-sdk-initialized-before-auth"]:"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."}}function _logError(msg,...args){logClient.logLevel<=_logger.LogLevel.ERROR&&logClient.error(`Auth (${_app.SDK_VERSION}): ${msg}`,
...args)}function _fail(authOrCode,...rest){throw createErrorInternal(authOrCode,...rest);}function _createError(authOrCode,...rest){return createErrorInternal(authOrCode,...rest)}function _errorWithCustomMessage(auth,code,message){message=Object.assign(Object.assign({},prodErrorMap()),{[code]:message});return(new _util.ErrorFactory("auth","Firebase",message)).create(code,{appName:auth.name})}function _assertInstanceOf(auth,object,instance){if(!(object instanceof instance))throw instance.name!==object.constructor.name&&
_fail(auth,"argument-error"),_errorWithCustomMessage(auth,"argument-error",`Type of ${object.constructor.name} does not match expected instance.`+"Did you pass a reference from a different Auth SDK?");}function createErrorInternal(authOrCode,...rest){if("string"!==typeof authOrCode){const code=rest[0];rest=[...rest.slice(1)];rest[0]&&(rest[0].appName=authOrCode.name);return authOrCode._errorFactory.create(code,...rest)}return _DEFAULT_AUTH_ERROR_FACTORY.create(authOrCode,...rest)}function _assert(assertion,
authOrCode,...rest){if(!assertion)throw createErrorInternal(authOrCode,...rest);}function debugFail(failure){failure="INTERNAL ASSERTION FAILED: "+failure;_logError(failure);throw Error(failure);}function debugAssert(assertion,message){assertion||debugFail(message)}function _getInstance(cls){debugAssert(cls instanceof Function,"Expected a class definition");let instance=instanceCache.get(cls);if(instance)return debugAssert(instance instanceof cls,"Instance stored in cache mismatched with class"),
instance;instance=new cls;instanceCache.set(cls,instance);return instance}function initializeAuth(app,deps){app=(0,_app._getProvider)(app,"auth");if(app.isInitialized()){const auth=app.getImmediate(),initialOptions=app.getOptions();if((0,_util.deepEqual)(initialOptions,null!==deps&&void 0!==deps?deps:{}))return auth;_fail(auth,"already-initialized")}return app.initialize({options:deps})}function _getCurrentUrl(){var _a;return"undefined"!==typeof self&&(null===(_a=self.location)||void 0===_a?void 0:
_a.href)||""}function _isHttpOrHttps(){return"http:"===_getCurrentScheme()||"https:"===_getCurrentScheme()}function _getCurrentScheme(){var _a;return"undefined"!==typeof self&&(null===(_a=self.location)||void 0===_a?void 0:_a.protocol)||null}function _emulatorUrl(config,path){debugAssert(config.emulator,"Emulator should always be set here");({url:config}=config.emulator);return path?`${config}${path.startsWith("/")?path.slice(1):path}`:config}function _addTidIfNecessary(auth,request){return auth.tenantId&&
!request.tenantId?Object.assign(Object.assign({},request),{tenantId:auth.tenantId}):request}function _performApiRequest(auth,method,path,request,customErrorMap={}){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performFetchWithErrorHandling(auth,customErrorMap,()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){let body={};var params={};request&&("GET"===method?params=request:body={body:JSON.stringify(request)});params=(0,_util.querystring)(Object.assign({key:auth.config.apiKey},
params)).slice(1);const headers=yield auth._getAdditionalHeaders();headers["Content-Type"]="application/json";auth.languageCode&&(headers["X-Firebase-Locale"]=auth.languageCode);return FetchProvider.fetch()(_getFinalTarget(auth,auth.config.apiHost,path,params),Object.assign({method,headers,referrerPolicy:"no-referrer"},body))}))})}function _performFetchWithErrorHandling(auth,customErrorMap,fetchFn){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){auth._canInitEmulator=!1;const errorMap=
Object.assign(Object.assign({},SERVER_ERROR_MAP),customErrorMap);try{const networkTimeout=new NetworkTimeout(auth),response=yield Promise.race([fetchFn(),networkTimeout.promise]);networkTimeout.clearNetworkTimeout();const json=yield response.json();if("needConfirmation"in json)throw _makeTaggedError(auth,"account-exists-with-different-credential",json);if(!response.ok||"errorMessage"in json){const [serverErrorCode,serverErrorMessage]=(response.ok?json.errorMessage:json.error.message).split(" : ");
if("FEDERATED_USER_ID_ALREADY_LINKED"===serverErrorCode)throw _makeTaggedError(auth,"credential-already-in-use",json);if("EMAIL_EXISTS"===serverErrorCode)throw _makeTaggedError(auth,"email-already-in-use",json);const authError=errorMap[serverErrorCode]||serverErrorCode.toLowerCase().replace(/[_\s]+/g,"-");if(serverErrorMessage)throw _errorWithCustomMessage(auth,authError,serverErrorMessage);_fail(auth,authError)}else return json}catch(e){if(e instanceof _util.FirebaseError)throw e;_fail(auth,"network-request-failed")}})}
function _performSignInRequest(auth,method,path,request,customErrorMap={}){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const serverResponse=yield _performApiRequest(auth,method,path,request,customErrorMap);"mfaPendingCredential"in serverResponse&&_fail(auth,"multi-factor-auth-required",{_serverResponse:serverResponse});return serverResponse})}function _getFinalTarget(auth,host,path,query){host=`${host}${path}?${query}`;return auth.config.emulator?_emulatorUrl(auth.config,host):
`${auth.config.apiScheme}://${host}`}function _makeTaggedError(auth,code,response){const errorParams={appName:auth.name};response.email&&(errorParams.email=response.email);response.phoneNumber&&(errorParams.phoneNumber=response.phoneNumber);auth=_createError(auth,code,errorParams);auth.customData._tokenResponse=response;return auth}function deleteAccount(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:delete",request)})}
function deleteLinkedAccounts(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:update",request)})}function getAccountInfo(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:lookup",request)})}function utcTimestampToDateString(utcTimestamp){if(utcTimestamp)try{const date=new Date(Number(utcTimestamp));if(!isNaN(date.getTime()))return date.toUTCString()}catch(e){}}
function getIdTokenResult(user,forceRefresh=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var userInternal=(0,_util.getModularInstance)(user);const token=yield userInternal.getIdToken(forceRefresh),claims=_parseToken(token);_assert(claims&&claims.exp&&claims.auth_time&&claims.iat,userInternal.auth,"internal-error");userInternal="object"===typeof claims.firebase?claims.firebase:void 0;const signInProvider=null===userInternal||void 0===userInternal?void 0:userInternal.sign_in_provider;
return{claims,token,authTime:utcTimestampToDateString(1E3*Number(claims.auth_time)),issuedAtTime:utcTimestampToDateString(1E3*Number(claims.iat)),expirationTime:utcTimestampToDateString(1E3*Number(claims.exp)),signInProvider:signInProvider||null,signInSecondFactor:(null===userInternal||void 0===userInternal?void 0:userInternal.sign_in_second_factor)||null}})}function _parseToken(token){const [algorithm,payload,signature]=token.split(".");if(void 0===algorithm||void 0===payload||void 0===signature)return _logError("JWT malformed, contained fewer than 3 sections"),
null;try{const decoded=(0,_util.base64Decode)(payload);return decoded?JSON.parse(decoded):(_logError("Failed to decode base64 JWT payload"),null)}catch(e){return _logError("Caught error parsing JWT payload as JSON",e),null}}function _logoutIfInvalidated(user,promise,bypassAuthState=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(bypassAuthState)return promise;try{return yield promise}catch(e){throw e instanceof _util.FirebaseError&&isUserInvalidated(e)&&user.auth.currentUser===
user&&(yield user.auth.signOut()),e;}})}function isUserInvalidated({code}){return"auth/user-disabled"===code||"auth/user-token-expired"===code}function _reloadWithoutSaving(user){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a,auth=user.auth,idToken=yield user.getIdToken();idToken=yield _logoutIfInvalidated(user,getAccountInfo(auth,{idToken}));_assert(null===idToken||void 0===idToken?void 0:idToken.users.length,auth,"internal-error");auth=idToken.users[0];user._notifyReloadListener(auth);
idToken=(null===(_a=auth.providerUserInfo)||void 0===_a?0:_a.length)?extractProviderData(auth.providerUserInfo):[];_a=mergeProviderData(user.providerData,idToken);idToken=!(user.email&&auth.passwordHash)&&!(null===_a||void 0===_a?0:_a.length);idToken=user.isAnonymous?idToken:!1;_a={uid:auth.localId,displayName:auth.displayName||null,photoURL:auth.photoUrl||null,email:auth.email||null,emailVerified:auth.emailVerified||!1,phoneNumber:auth.phoneNumber||null,tenantId:auth.tenantId||null,providerData:_a,
metadata:new UserMetadata(auth.createdAt,auth.lastLoginAt),isAnonymous:idToken};Object.assign(user,_a)})}function reload(user){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);yield _reloadWithoutSaving(userInternal);yield userInternal.auth._persistUserIfCurrent(userInternal);userInternal.auth._notifyListenersIfCurrent(userInternal)})}function mergeProviderData(original,newData){return[...original.filter(o=>!newData.some(n=>n.providerId===
o.providerId)),...newData]}function extractProviderData(providers){return providers.map(_a=>{var {providerId}=_a;_a=(0,_tslib.__rest)(_a,["providerId"]);return{providerId,uid:_a.rawId||"",displayName:_a.displayName||null,email:_a.email||null,phoneNumber:_a.phoneNumber||null,photoURL:_a.photoUrl||null}})}function requestStsToken(auth,refreshToken){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const response=yield _performFetchWithErrorHandling(auth,{},()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){const body=
(0,_util.querystring)({grant_type:"refresh_token",refresh_token:refreshToken}).slice(1),{tokenApiHost,apiKey}=auth.config,url=_getFinalTarget(auth,tokenApiHost,"/v1/token",`key=${apiKey}`),headers=yield auth._getAdditionalHeaders();headers["Content-Type"]="application/x-www-form-urlencoded";return FetchProvider.fetch()(url,{method:"POST",headers,body})}));return{accessToken:response.access_token,expiresIn:response.expires_in,refreshToken:response.refresh_token}})}function assertStringOrUndefined(assertion,
appName){_assert("string"===typeof assertion||"undefined"===typeof assertion,"internal-error",{appName})}function _persistenceKeyName(key,apiKey,appName){return`${"firebase"}:${key}:${apiKey}:${appName}`}function _getBrowserName(userAgent){const ua=userAgent.toLowerCase();if(ua.includes("opera/")||ua.includes("opr/")||ua.includes("opios/"))return"Opera";if(_isIEMobile(ua))return"IEMobile";if(ua.includes("msie")||ua.includes("trident/"))return"IE";if(ua.includes("edge/"))return"Edge";if(_isFirefox(ua))return"Firefox";
if(ua.includes("silk/"))return"Silk";if(_isBlackBerry(ua))return"Blackberry";if(_isWebOS(ua))return"Webos";if(_isSafari(ua))return"Safari";if(!ua.includes("chrome/")&&!_isChromeIOS(ua)||ua.includes("edge/")){if(_isAndroid(ua))return"Android";userAgent=userAgent.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/);if(2===(null===userAgent||void 0===userAgent?void 0:userAgent.length))return userAgent[1]}else return"Chrome";return"Other"}function _isFirefox(ua=(0,_util.getUA)()){return/firefox\//i.test(ua)}function _isSafari(userAgent=
(0,_util.getUA)()){userAgent=userAgent.toLowerCase();return userAgent.includes("safari/")&&!userAgent.includes("chrome/")&&!userAgent.includes("crios/")&&!userAgent.includes("android")}function _isChromeIOS(ua=(0,_util.getUA)()){return/crios\//i.test(ua)}function _isIEMobile(ua=(0,_util.getUA)()){return/iemobile/i.test(ua)}function _isAndroid(ua=(0,_util.getUA)()){return/android/i.test(ua)}function _isBlackBerry(ua=(0,_util.getUA)()){return/blackberry/i.test(ua)}function _isWebOS(ua=(0,_util.getUA)()){return/webos/i.test(ua)}
function _isIOS(ua=(0,_util.getUA)()){return/iphone|ipad|ipod/i.test(ua)}function _isIOSStandalone(ua=(0,_util.getUA)()){var _a;return _isIOS(ua)&&!(null===(_a=window.navigator)||void 0===_a||!_a.standalone)}function _isMobileBrowser(ua=(0,_util.getUA)()){return _isIOS(ua)||_isAndroid(ua)||_isWebOS(ua)||_isBlackBerry(ua)||/windows phone/i.test(ua)||_isIEMobile(ua)}function _getClientVersion(clientPlatform,frameworks=[]){switch(clientPlatform){case "Browser":clientPlatform=_getBrowserName((0,_util.getUA)());
break;case "Worker":clientPlatform=`${_getBrowserName((0,_util.getUA)())}-${clientPlatform}`}frameworks=frameworks.length?frameworks.join(","):"FirebaseCore-web";return`${clientPlatform}/${"JsCore"}/${_app.SDK_VERSION}/${frameworks}`}function _castAuth(auth){return(0,_util.getModularInstance)(auth)}function extractProtocol(url){const protocolEnd=url.indexOf(":");return 0>protocolEnd?"":url.substr(0,protocolEnd+1)}function parsePort(portStr){if(!portStr)return null;portStr=Number(portStr);return isNaN(portStr)?
null:portStr}function emitEmulatorWarning(){function attachBanner(){const el=document.createElement("p"),sty=el.style;el.innerText="Running in emulator mode. Do not use with production credentials.";sty.position="fixed";sty.width="100%";sty.backgroundColor="#ffffff";sty.border=".1em solid #000000";sty.color="#b50000";sty.bottom="0px";sty.left="0px";sty.margin="0px";sty.zIndex="10000";sty.textAlign="center";el.classList.add("firebase-emulator-warning");document.body.appendChild(el)}"undefined"!==typeof console&&
"function"===typeof console.info&&console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials.");"undefined"!==typeof window&&"undefined"!==typeof document&&("loading"===document.readyState?window.addEventListener("DOMContentLoaded",attachBanner):attachBanner())}function resetPassword(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:resetPassword",
_addTidIfNecessary(auth,request))})}function updateEmailPassword(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:update",request)})}function applyActionCode$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:update",_addTidIfNecessary(auth,request))})}function signInWithPassword(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,
"POST","/v1/accounts:signInWithPassword",_addTidIfNecessary(auth,request))})}function sendOobCode(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:sendOobCode",_addTidIfNecessary(auth,request))})}function sendEmailVerification$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return sendOobCode(auth,request)})}function sendPasswordResetEmail$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return sendOobCode(auth,
request)})}function sendSignInLinkToEmail$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return sendOobCode(auth,request)})}function verifyAndChangeEmail(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return sendOobCode(auth,request)})}function signInWithEmailLink$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithEmailLink",_addTidIfNecessary(auth,
request))})}function signInWithEmailLinkForLinking(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithEmailLink",_addTidIfNecessary(auth,request))})}function signInWithIdp(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithIdp",_addTidIfNecessary(auth,request))})}function sendPhoneVerificationCode(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,
"POST","/v1/accounts:sendVerificationCode",_addTidIfNecessary(auth,request))})}function signInWithPhoneNumber$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",_addTidIfNecessary(auth,request))})}function linkWithPhoneNumber$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const response=yield _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",
_addTidIfNecessary(auth,request));if(response.temporaryProof)throw _makeTaggedError(auth,"account-exists-with-different-credential",response);return response})}function verifyPhoneNumberForExisting(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const apiRequest=Object.assign(Object.assign({},request),{operation:"REAUTH"});return _performSignInRequest(auth,"POST","/v1/accounts:signInWithPhoneNumber",_addTidIfNecessary(auth,apiRequest),VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_)})}
function parseMode(mode){switch(mode){case "recoverEmail":return"RECOVER_EMAIL";case "resetPassword":return"PASSWORD_RESET";case "signIn":return"EMAIL_SIGNIN";case "verifyEmail":return"VERIFY_EMAIL";case "verifyAndChangeEmail":return"VERIFY_AND_CHANGE_EMAIL";case "revertSecondFactorAddition":return"REVERT_SECOND_FACTOR_ADDITION";default:return null}}function signUp(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signUp",
_addTidIfNecessary(auth,request))})}function providerIdForResponse(response){return response.providerId?response.providerId:"phoneNumber"in response?"phone":null}function _processCredentialSavingMfaContextIfNecessary(auth,operationType,credential,user){return("reauthenticate"===operationType?credential._getReauthenticationResolver(auth):credential._getIdTokenResponse(auth)).catch(error=>{if("auth/multi-factor-auth-required"===error.code)throw MultiFactorError._fromErrorAndOperation(auth,error,operationType,
user);throw error;})}function providerDataAsNames(providerData){return new Set(providerData.map(({providerId})=>providerId).filter(pid=>!!pid))}function _link$1(user,credential,bypassAuthState=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const response=yield _logoutIfInvalidated(user,credential._linkToIdToken(user.auth,yield user.getIdToken()),bypassAuthState);return UserCredentialImpl._forOperation(user,"link",response)})}function _assertLinkedStatus(expected,user,provider){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield _reloadWithoutSaving(user);
const providerIds=providerDataAsNames(user.providerData),code=!1===expected?"provider-already-linked":"no-such-provider";_assert(providerIds.has(provider)===expected,user.auth,code)})}function _reauthenticate(user,credential,bypassAuthState=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {auth}=user;try{const response=yield _logoutIfInvalidated(user,_processCredentialSavingMfaContextIfNecessary(auth,"reauthenticate",credential,user),bypassAuthState);_assert(response.idToken,
auth,"internal-error");var parsed=_parseToken(response.idToken);_assert(parsed,auth,"internal-error");({sub:parsed}=parsed);_assert(user.uid===parsed,auth,"user-mismatch");return UserCredentialImpl._forOperation(user,"reauthenticate",response)}catch(e){throw"auth/user-not-found"===(null===e||void 0===e?void 0:e.code)&&_fail(auth,"user-mismatch"),e;}})}function _signInWithCredential(auth,credential,bypassAuthState=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var response=yield _processCredentialSavingMfaContextIfNecessary(auth,
"signIn",credential);response=yield UserCredentialImpl._fromIdTokenResponse(auth,"signIn",response);bypassAuthState||(yield auth._updateCurrentUser(response.user));return response})}function signInWithCredential(auth,credential){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _signInWithCredential(_castAuth(auth),credential)})}function linkWithCredential(user,credential){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);
yield _assertLinkedStatus(!1,userInternal,credential.providerId);return _link$1(userInternal,credential)})}function reauthenticateWithCredential(user,credential){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _reauthenticate((0,_util.getModularInstance)(user),credential)})}function signInWithCustomToken$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performSignInRequest(auth,"POST","/v1/accounts:signInWithCustomToken",_addTidIfNecessary(auth,
request))})}function _setActionCodeSettingsOnRequest(auth,request,actionCodeSettings){var _a;_assert(0<(null===(_a=actionCodeSettings.url)||void 0===_a?void 0:_a.length),auth,"invalid-continue-uri");_assert("undefined"===typeof actionCodeSettings.dynamicLinkDomain||0<actionCodeSettings.dynamicLinkDomain.length,auth,"invalid-dynamic-link-domain");request.continueUrl=actionCodeSettings.url;request.dynamicLinkDomain=actionCodeSettings.dynamicLinkDomain;request.canHandleCodeInApp=actionCodeSettings.handleCodeInApp;
actionCodeSettings.iOS&&(_assert(0<actionCodeSettings.iOS.bundleId.length,auth,"missing-ios-bundle-id"),request.iOSBundleId=actionCodeSettings.iOS.bundleId);actionCodeSettings.android&&(_assert(0<actionCodeSettings.android.packageName.length,auth,"missing-android-pkg-name"),request.androidInstallApp=actionCodeSettings.android.installApp,request.androidMinimumVersionCode=actionCodeSettings.android.minimumVersion,request.androidPackageName=actionCodeSettings.android.packageName)}function checkActionCode(auth,
oobCode){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authModular=(0,_util.getModularInstance)(auth),response=yield resetPassword(authModular,{oobCode}),operation=response.requestType;_assert(operation,authModular,"internal-error");switch(operation){case "EMAIL_SIGNIN":break;case "VERIFY_AND_CHANGE_EMAIL":_assert(response.newEmail,authModular,"internal-error");break;case "REVERT_SECOND_FACTOR_ADDITION":_assert(response.mfaInfo,authModular,"internal-error");default:_assert(response.email,
authModular,"internal-error")}let multiFactorInfo=null;response.mfaInfo&&(multiFactorInfo=MultiFactorInfoImpl._fromServerResponse(_castAuth(authModular),response.mfaInfo));return{data:{email:("VERIFY_AND_CHANGE_EMAIL"===response.requestType?response.newEmail:response.email)||null,previousEmail:("VERIFY_AND_CHANGE_EMAIL"===response.requestType?response.email:response.newEmail)||null,multiFactorInfo},operation}})}function createAuthUri(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,
"POST","/v1/accounts:createAuthUri",_addTidIfNecessary(auth,request))})}function updateProfile$1(auth,request){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"POST","/v1/accounts:update",request)})}function updateEmailOrPassword(user,email,password){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var {auth}=user;const request={idToken:yield user.getIdToken(),returnSecureToken:!0};email&&(request.email=email);password&&(request.password=
password);auth=yield _logoutIfInvalidated(user,updateEmailPassword(auth,request));yield user._updateTokensIfNecessary(auth,!0)})}function _fromIdTokenResponse(idTokenResponse){var _a,_b;if(!idTokenResponse)return null;const {providerId}=idTokenResponse,profile=idTokenResponse.rawUserInfo?JSON.parse(idTokenResponse.rawUserInfo):{},isNewUser=idTokenResponse.isNewUser||"identitytoolkit#SignupNewUserResponse"===idTokenResponse.kind;if(!providerId&&(null===idTokenResponse||void 0===idTokenResponse?0:idTokenResponse.idToken)){const signInProvider=
null===(_b=null===(_a=_parseToken(idTokenResponse.idToken))||void 0===_a?void 0:_a.firebase)||void 0===_b?void 0:_b.sign_in_provider;if(signInProvider)return new GenericAdditionalUserInfo(isNewUser,"anonymous"!==signInProvider&&"custom"!==signInProvider?signInProvider:null)}if(!providerId)return null;switch(providerId){case "facebook.com":return new FacebookAdditionalUserInfo(isNewUser,profile);case "github.com":return new GithubAdditionalUserInfo(isNewUser,profile);case "google.com":return new GoogleAdditionalUserInfo(isNewUser,
profile);case "twitter.com":return new TwitterAdditionalUserInfo(isNewUser,profile,idTokenResponse.screenName||null);case "custom":case "anonymous":return new GenericAdditionalUserInfo(isNewUser,null);default:return new GenericAdditionalUserInfo(isNewUser,providerId,profile)}}function withdrawMfa(auth,request){return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:withdraw",_addTidIfNecessary(auth,request))}function _iframeCannotSyncWebStorage(){const ua=(0,_util.getUA)();return _isSafari(ua)||
_isIOS(ua)}function _allSettled(promises){return Promise.all(promises.map(promise=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){try{return{fulfilled:!0,value:yield promise}}catch(reason){return{fulfilled:!1,reason}}})))}function _generateEventId(prefix="",digits=10){let random="";for(let i=0;i<digits;i++)random+=Math.floor(10*Math.random());return prefix+random}function _isWorker(){return"undefined"!==typeof window.WorkerGlobalScope&&"function"===typeof window.importScripts}function _getActiveServiceWorker(){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(null===
navigator||void 0===navigator||!navigator.serviceWorker)return null;try{return(yield navigator.serviceWorker.ready).active}catch(_a){return null}})}function getObjectStore(db,isReadWrite){return db.transaction(["firebaseLocalStorage"],isReadWrite?"readwrite":"readonly").objectStore("firebaseLocalStorage")}function _openDatabase(){const request=indexedDB.open("firebaseLocalStorageDb",1);return new Promise((resolve,reject)=>{request.addEventListener("error",()=>{reject(request.error)});request.addEventListener("upgradeneeded",
()=>{const db=request.result;try{db.createObjectStore("firebaseLocalStorage",{keyPath:"fbase_key"})}catch(e){reject(e)}});request.addEventListener("success",()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){var db=request.result;db.objectStoreNames.contains("firebaseLocalStorage")?resolve(db):(db.close(),db=indexedDB.deleteDatabase("firebaseLocalStorageDb"),yield(new DBPromise(db)).toPromise(),resolve(yield _openDatabase()))}))})}function _putObject(db,key,value){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const request=
getObjectStore(db,!0).put({fbase_key:key,value});return(new DBPromise(request)).toPromise()})}function getObject(db,key){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var request=getObjectStore(db,!1).get(key);request=yield(new DBPromise(request)).toPromise();return void 0===request?null:request.value})}function _deleteObject(db,key){db=getObjectStore(db,!0).delete(key);return(new DBPromise(db)).toPromise()}function getRecaptchaParams(auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return(yield _performApiRequest(auth,
"GET","/v1/recaptchaParams")).recaptchaSiteKey||""})}function getScriptParentElement(){var _a,_b;return null!==(_b=null===(_a=document.getElementsByTagName("head"))||void 0===_a?void 0:_a[0])&&void 0!==_b?_b:document}function _loadJS(url){return new Promise((resolve,reject)=>{const el=document.createElement("script");el.setAttribute("src",url);el.onload=resolve;el.onerror=e=>{const error=_createError("internal-error");error.customData=e;reject(error)};el.type="text/javascript";el.charset="UTF-8";
getScriptParentElement().appendChild(el)})}function generateRandomAlphaNumericString(len){const chars=[];for(let i=0;i<len;i++)chars.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Math.floor(62*Math.random())));return chars.join("")}function domReady(){let resolver=null;return(new Promise(resolve=>{"complete"===document.readyState?resolve():(resolver=()=>resolve(),window.addEventListener("load",resolver))})).catch(e=>{resolver&&window.removeEventListener("load",resolver);
throw e;})}function _verifyPhoneNumber(auth,options,verifier){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;const recaptchaToken=yield verifier.verify();try{_assert("string"===typeof recaptchaToken,auth,"argument-error");_assert("recaptcha"===verifier.type,auth,"argument-error");let phoneInfoOptions;phoneInfoOptions="string"===typeof options?{phoneNumber:options}:options;if("session"in phoneInfoOptions){const session=phoneInfoOptions.session;if("phoneNumber"in phoneInfoOptions)return _assert("enroll"===
session.type,auth,"internal-error"),(yield _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:start",_addTidIfNecessary(auth,{idToken:session.credential,phoneEnrollmentInfo:{phoneNumber:phoneInfoOptions.phoneNumber,recaptchaToken}}))).phoneSessionInfo.sessionInfo;_assert("signin"===session.type,auth,"internal-error");const mfaEnrollmentId=(null===(_a=phoneInfoOptions.multiFactorHint)||void 0===_a?void 0:_a.uid)||phoneInfoOptions.multiFactorUid;_assert(mfaEnrollmentId,auth,"missing-multi-factor-info");
return(yield _performApiRequest(auth,"POST","/v2/accounts/mfaSignIn:start",_addTidIfNecessary(auth,{mfaPendingCredential:session.credential,mfaEnrollmentId,phoneSignInInfo:{recaptchaToken}}))).phoneResponseInfo.sessionInfo}const {sessionInfo}=yield sendPhoneVerificationCode(auth,{phoneNumber:phoneInfoOptions.phoneNumber,recaptchaToken});return sessionInfo}finally{verifier._reset()}})}function _withDefaultResolver(auth,resolverOverride){if(resolverOverride)return _getInstance(resolverOverride);_assert(auth._popupRedirectResolver,
auth,"argument-error");return auth._popupRedirectResolver}function _signIn(params){return _signInWithCredential(params.auth,new IdpCredential(params),params.bypassAuthState)}function _reauth(params){const {auth,user}=params;_assert(user,auth,"internal-error");return _reauthenticate(user,new IdpCredential(params),params.bypassAuthState)}function _link(params){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {auth,user}=params;_assert(user,auth,"internal-error");return _link$1(user,
new IdpCredential(params),params.bypassAuthState)})}function _getAndClearPendingRedirectStatus(resolver,auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const key=_persistenceKeyName("pendingRedirect",auth.config.apiKey,auth.name),persistence=_getInstance(resolver._redirectPersistence);if(!(yield persistence._isAvailable()))return!1;const hasPendingRedirect="true"===(yield persistence._get(key));yield persistence._remove(key);return hasPendingRedirect})}function _setPendingRedirectStatus(resolver,
auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _getInstance(resolver._redirectPersistence)._set(_persistenceKeyName("pendingRedirect",auth.config.apiKey,auth.name),"true")})}function _signInWithRedirect(auth,provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth);_assertInstanceOf(auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(authInternal,resolver);yield _setPendingRedirectStatus(resolverInternal,
authInternal);return resolverInternal._openRedirect(authInternal,provider,"signInViaRedirect")})}function _reauthenticateWithRedirect(user,provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);yield _setPendingRedirectStatus(resolverInternal,userInternal.auth);const eventId=yield prepareUserForRedirect(userInternal);
return resolverInternal._openRedirect(userInternal.auth,provider,"reauthViaRedirect",eventId)})}function _linkWithRedirect(user,provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);yield _assertLinkedStatus(!1,userInternal,provider.providerId);yield _setPendingRedirectStatus(resolverInternal,
userInternal.auth);const eventId=yield prepareUserForRedirect(userInternal);return resolverInternal._openRedirect(userInternal.auth,provider,"linkViaRedirect",eventId)})}function _getRedirectResult(auth,resolverExtern,bypassAuthState=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth);var resolver=_withDefaultResolver(authInternal,resolverExtern);(resolver=yield(new RedirectAction(authInternal,resolver,bypassAuthState)).execute())&&!bypassAuthState&&
(delete resolver.user._redirectEventId,yield authInternal._persistUserIfCurrent(resolver.user),yield authInternal._setRedirectUser(null,resolverExtern));return resolver})}function prepareUserForRedirect(user){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const eventId=_generateEventId(`${user.uid}:::`);user._redirectEventId=eventId;yield user.auth._setRedirectUser(user);yield user.auth._persistUserIfCurrent(user);return eventId})}function eventUid(e){return[e.type,e.eventId,e.sessionId,
e.tenantId].filter(v=>v).join("-")}function isNullRedirectEvent({type,error}){return"unknown"===type&&"auth/no-auth-event"===(null===error||void 0===error?void 0:error.code)}function _getProjectConfig(auth,request={}){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _performApiRequest(auth,"GET","/v1/projects",request)})}function _validateOrigin(auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(!auth.config.emulator){var {authorizedDomains}=yield _getProjectConfig(auth);
for(const domain of authorizedDomains)try{if(matchDomain(domain))return}catch(_a){}_fail(auth,"unauthorized-domain")}})}function matchDomain(expected){const currentUrl=_getCurrentUrl(),{protocol,hostname}=new URL(currentUrl);if(expected.startsWith("chrome-extension://")){const ceUrl=new URL(expected);return""===ceUrl.hostname&&""===hostname?"chrome-extension:"===protocol&&expected.replace("chrome-extension://","")===currentUrl.replace("chrome-extension://",""):"chrome-extension:"===protocol&&ceUrl.hostname===
hostname}if(!HTTP_REGEX.test(protocol))return!1;if(IP_ADDRESS_REGEX.test(expected))return hostname===expected;expected=expected.replace(/\./g,"\\.");return(new RegExp("^(.+\\."+expected+"|"+expected+")$","i")).test(hostname)}function resetUnloadedGapiModules(){const beacon=window.___jsl;if(null===beacon||void 0===beacon?0:beacon.H)for(const hint of Object.keys(beacon.H))if(beacon.H[hint].r=beacon.H[hint].r||[],beacon.H[hint].L=beacon.H[hint].L||[],beacon.H[hint].r=[...beacon.H[hint].L],beacon.CP)for(let i=
0;i<beacon.CP.length;i++)beacon.CP[i]=null}function loadGapi(auth){return(new Promise((resolve,reject)=>{function loadGapiIframe(){resetUnloadedGapiModules();gapi.load("gapi.iframes",{callback:()=>{resolve(gapi.iframes.getContext())},ontimeout:()=>{resetUnloadedGapiModules();reject(_createError(auth,"network-request-failed"))},timeout:NETWORK_TIMEOUT.get()})}var _a,_b,_c;if(null===(_b=null===(_a=window.gapi)||void 0===_a?void 0:_a.iframes)||void 0===_b?0:_b.Iframe)resolve(gapi.iframes.getContext());
else if(null===(_c=window.gapi)||void 0===_c?0:_c.load)loadGapiIframe();else return _a=`__${"iframefcb"}${Math.floor(1E6*Math.random())}`,window[_a]=()=>{gapi.load?loadGapiIframe():reject(_createError(auth,"network-request-failed"))},_loadJS(`https://apis.google.com/js/api.js?onload=${_a}`).catch(e=>reject(e))})).catch(error=>{cachedGApiLoader=null;throw error;})}function getIframeUrl(auth){var config=auth.config;_assert(config.authDomain,auth,"auth-domain-config-required");const url=config.emulator?
_emulatorUrl(config,"emulator/auth/iframe"):`https://${auth.config.authDomain}/${"__/auth/iframe"}`;config={apiKey:config.apiKey,appName:auth.name,v:_app.SDK_VERSION};const eid=EID_FROM_APIHOST.get(auth.config.apiHost);eid&&(config.eid=eid);auth=auth._getFrameworks();auth.length&&(config.fw=auth.join(","));return`${url}?${(0,_util.querystring)(config).slice(1)}`}function _openIframe(auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){cachedGApiLoader=cachedGApiLoader||loadGapi(auth);
const context=yield cachedGApiLoader,gapi=window.gapi;_assert(gapi,auth,"internal-error");return context.open({where:document.body,url:getIframeUrl(auth),messageHandlersFilter:gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER,attributes:IFRAME_ATTRIBUTES,dontclear:!0},iframe=>new Promise((resolve,reject)=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){function clearTimerAndResolve(){window.clearTimeout(networkErrorTimer);resolve(iframe)}yield iframe.restyle({setHideOnLeave:!1});const networkError=
_createError(auth,"network-request-failed"),networkErrorTimer=window.setTimeout(()=>{reject(networkError)},PING_TIMEOUT.get());iframe.ping(clearTimerAndResolve).then(clearTimerAndResolve,()=>{reject(networkError)})})))})}function _open(auth,url,name,width=500,height=600){const top=Math.max((window.screen.availHeight-height)/2,0).toString(),left=Math.max((window.screen.availWidth-width)/2,0).toString();let target="";height=Object.assign(Object.assign({},BASE_POPUP_OPTIONS),{width:width.toString(),
height:height.toString(),top,left});width=(0,_util.getUA)().toLowerCase();name&&(target=_isChromeIOS(width)?"_blank":name);_isFirefox(width)&&(url=url||"http://localhost",height.scrollbars="yes");name=Object.entries(height).reduce((accum,[key,value])=>`${accum}${key}=${value},`,"");if(_isIOSStandalone(width)&&"_self"!==target)return openAsNewWindowIOS(url||"",target),new AuthPopup(null);url=window.open(url||"",target,name);_assert(url,auth,"popup-blocked");try{url.focus()}catch(e){}return new AuthPopup(url)}
function openAsNewWindowIOS(url,target){const el=document.createElement("a");el.href=url;el.target=target;url=document.createEvent("MouseEvent");url.initMouseEvent("click",!0,!0,window,1,0,0,0,0,!1,!1,!1,!1,1,null);el.dispatchEvent(url)}function _getRedirectUrl(auth,provider,authType,redirectUrl,eventId,additionalParams){_assert(auth.config.authDomain,auth,"auth-domain-config-required");_assert(auth.config.apiKey,auth,"invalid-api-key");authType={apiKey:auth.config.apiKey,appName:auth.name,authType,
redirectUrl,v:_app.SDK_VERSION,eventId};if(provider instanceof FederatedAuthProvider){provider.setDefaultLanguage(auth.languageCode);authType.providerId=provider.providerId||"";(0,_util.isEmpty)(provider.getCustomParameters())||(authType.customParameters=JSON.stringify(provider.getCustomParameters()));for(const [key,value]of Object.entries(additionalParams||{}))authType[key]=value}provider instanceof BaseOAuthProvider&&(provider=provider.getScopes().filter(scope=>""!==scope),0<provider.length&&(authType.scopes=
provider.join(",")));auth.tenantId&&(authType.tid=auth.tenantId);for(const key of Object.keys(authType))void 0===authType[key]&&delete authType[key];return`${getHandlerBase(auth)}?${(0,_util.querystring)(authType).slice(1)}`}function getHandlerBase({config}){return config.emulator?_emulatorUrl(config,"emulator/auth/handler"):`https://${config.authDomain}/${"__/auth/handler"}`}function getVersionForPlatform(clientPlatform){switch(clientPlatform){case "Node":return"node";case "ReactNative":return"rn";
case "Worker":return"webworker";case "Cordova":return"cordova"}}Object.defineProperty(exports,"__esModule",{value:!0});exports.$=function(auth,email,actionCodeSettings){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authModular=(0,_util.getModularInstance)(auth),request={requestType:"PASSWORD_RESET",email};actionCodeSettings&&_setActionCodeSettingsOnRequest(authModular,request,actionCodeSettings);yield sendPasswordResetEmail$1(authModular,request)})};exports.D=initializeAuth;
exports.E=function(auth,url,options){auth=_castAuth(auth);_assert(auth._canInitEmulator,auth,"emulator-config-failed");_assert(/^https?:\/\//.test(url),auth,"invalid-emulator-scheme");options=!(null===options||void 0===options||!options.disableWarnings);const protocol=extractProtocol(url);var protocol$jscomp$0=extractProtocol(url);if(url=/(\/\/)?([^?#/]+)/.exec(url.substr(protocol$jscomp$0.length)))if(url=url[2].split("@").pop()||"",protocol$jscomp$0=/^(\[[^\]]+\])(:|$)/.exec(url))protocol$jscomp$0=
protocol$jscomp$0[1],url={host:protocol$jscomp$0,port:parsePort(url.substr(protocol$jscomp$0.length+1))};else{const [host,port]=url.split(":");url={host,port:parsePort(port)}}else url={host:"",port:null};const {host:host$jscomp$0,port:port$jscomp$0}=url;auth.config.emulator={url:`${protocol}//${host$jscomp$0}${null===port$jscomp$0?"":`:${port$jscomp$0}`}/`};auth.settings.appVerificationDisabledForTesting=!0;auth.emulatorConfig=Object.freeze({host:host$jscomp$0,port:port$jscomp$0,protocol:protocol.replace(":",
""),options:Object.freeze({disableWarnings:options})});options||emitEmulatorWarning()};exports.W=function(auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;const authInternal=_castAuth(auth);yield authInternal._initializationPromise;if(null===(_a=authInternal.currentUser)||void 0===_a?0:_a.isAnonymous)return new UserCredentialImpl({user:authInternal.currentUser,providerId:null,operationType:"signIn"});_a=yield signUp(authInternal,{returnSecureToken:!0});_a=yield UserCredentialImpl._fromIdTokenResponse(authInternal,
"signIn",_a,!0);yield authInternal._updateCurrentUser(_a.user);return _a})};exports.X=signInWithCredential;exports.Y=linkWithCredential;exports.Z=reauthenticateWithCredential;exports._=function(auth,customToken){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth);var response=yield signInWithCustomToken$1(authInternal,{token:customToken,returnSecureToken:!0});response=yield UserCredentialImpl._fromIdTokenResponse(authInternal,"signIn",response);yield authInternal._updateCurrentUser(response.user);
return response})};exports.a0=function(auth,oobCode,newPassword){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield resetPassword((0,_util.getModularInstance)(auth),{oobCode,newPassword})})};exports.a1=function(auth,oobCode){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield applyActionCode$1((0,_util.getModularInstance)(auth),{oobCode})})};exports.a2=checkActionCode;exports.a3=function(auth,code){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {data}=
yield checkActionCode((0,_util.getModularInstance)(auth),code);return data.email})};exports.a4=function(auth,email,password){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth);var response=yield signUp(authInternal,{returnSecureToken:!0,email,password});response=yield UserCredentialImpl._fromIdTokenResponse(authInternal,"signIn",response);yield authInternal._updateCurrentUser(response.user);return response})};exports.a5=function(auth,email,password){return signInWithCredential((0,_util.getModularInstance)(auth),
EmailAuthProvider.credential(email,password))};exports.a6=function(auth,email,actionCodeSettings){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authModular=(0,_util.getModularInstance)(auth),request={requestType:"EMAIL_SIGNIN",email};_assert(actionCodeSettings.handleCodeInApp,authModular,"argument-error");actionCodeSettings&&_setActionCodeSettingsOnRequest(authModular,request,actionCodeSettings);yield sendSignInLinkToEmail$1(authModular,request)})};exports.a7=function(auth,
emailLink){auth=ActionCodeURL.parseLink(emailLink);return"EMAIL_SIGNIN"===(null===auth||void 0===auth?void 0:auth.operation)};exports.a8=function(auth,email,emailLink){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authModular=(0,_util.getModularInstance)(auth),credential=EmailAuthProvider.credentialWithLink(email,emailLink||_getCurrentUrl());_assert(credential._tenantId===(authModular.tenantId||null),authModular,"tenant-id-mismatch");return signInWithCredential(authModular,
credential)})};exports.a9=function(auth,email){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var continueUri=_isHttpOrHttps()?_getCurrentUrl():"http://localhost";continueUri={identifier:email,continueUri};({signinMethods:continueUri}=yield createAuthUri((0,_util.getModularInstance)(auth),continueUri));return continueUri||[]})};exports.aA=_getRedirectResult;exports.aB=function(){redirectOutcomeMap.clear()};exports.aC=_castAuth;exports.aF=_getClientVersion;exports.aG=_generateEventId;
exports.aa=function(user,actionCodeSettings){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var userInternal=(0,_util.getModularInstance)(user);const request={requestType:"VERIFY_EMAIL",idToken:yield user.getIdToken()};actionCodeSettings&&_setActionCodeSettingsOnRequest(userInternal.auth,request,actionCodeSettings);({email:userInternal}=yield sendEmailVerification$1(userInternal.auth,request));userInternal!==user.email&&(yield user.reload())})};exports.ab=function(user,newEmail,actionCodeSettings){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var userInternal=
(0,_util.getModularInstance)(user);const request={requestType:"VERIFY_AND_CHANGE_EMAIL",idToken:yield user.getIdToken(),newEmail};actionCodeSettings&&_setActionCodeSettingsOnRequest(userInternal.auth,request,actionCodeSettings);({email:userInternal}=yield verifyAndChangeEmail(userInternal.auth,request));userInternal!==user.email&&(yield user.reload())})};exports.ad=function(link){return ActionCodeURL.parseLink(link)};exports.ae=function(user,{displayName,photoURL:photoUrl}){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(void 0!==
displayName||void 0!==photoUrl){var userInternal=(0,_util.getModularInstance)(user),profileRequest={idToken:yield userInternal.getIdToken(),displayName,photoUrl,returnSecureToken:!0};profileRequest=yield _logoutIfInvalidated(userInternal,updateProfile$1(userInternal.auth,profileRequest));userInternal.displayName=profileRequest.displayName||null;userInternal.photoURL=profileRequest.photoUrl||null;var passwordProvider=userInternal.providerData.find(({providerId})=>"password"===providerId);passwordProvider&&
(passwordProvider.displayName=userInternal.displayName,passwordProvider.photoURL=userInternal.photoURL);yield userInternal._updateTokensIfNecessary(profileRequest)}})};exports.af=function(user,newEmail){return updateEmailOrPassword((0,_util.getModularInstance)(user),newEmail,null)};exports.ag=function(user,newPassword){return updateEmailOrPassword((0,_util.getModularInstance)(user),null,newPassword)};exports.ah=function(user,forceRefresh=!1){return(0,_util.getModularInstance)(user).getIdToken(forceRefresh)};
exports.ai=getIdTokenResult;exports.aj=function(user,providerId){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);yield _assertLinkedStatus(!0,userInternal,providerId);const {providerUserInfo}=yield deleteLinkedAccounts(userInternal.auth,{idToken:yield userInternal.getIdToken(),deleteProvider:[providerId]}),providersLeft=providerDataAsNames(providerUserInfo||[]);userInternal.providerData=userInternal.providerData.filter(pd=>providersLeft.has(pd.providerId));
providersLeft.has("phone")||(userInternal.phoneNumber=null);yield userInternal.auth._persistUserIfCurrent(userInternal);return userInternal})};exports.ak=function(userCredential){const {user,_tokenResponse}=userCredential;return user.isAnonymous&&!_tokenResponse?{providerId:null,isNewUser:!1,profile:null}:_fromIdTokenResponse(_tokenResponse)};exports.al=reload;exports.am=function(auth,error){var _a;auth=(0,_util.getModularInstance)(auth);_assert(error.customData.operationType,auth,"argument-error");
_assert(null===(_a=error.customData._serverResponse)||void 0===_a?void 0:_a.mfaPendingCredential,auth,"argument-error");return MultiFactorResolverImpl._fromError(auth,error)};exports.an=function(user){user=(0,_util.getModularInstance)(user);multiFactorUserCache.has(user)||multiFactorUserCache.set(user,MultiFactorUserImpl._fromUser(user));return multiFactorUserCache.get(user)};exports.ao=function(ua=(0,_util.getUA)()){return/(iPad|iPhone|iPod).*OS 7_\d/i.test(ua)||/(iPad|iPhone|iPod).*OS 8_\d/i.test(ua)};
exports.ap=debugAssert;exports.aq=_isIOS;exports.ar=_isAndroid;exports.as=_fail;exports.at=_getRedirectUrl;exports.au=_getProjectConfig;exports.av=_createError;exports.aw=_assert;exports.ax=_getInstance;exports.ay=_persistenceKeyName;exports.c=function(auth,provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth);_assertInstanceOf(auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(authInternal,resolver);return(new PopupOperation(authInternal,
"signInViaPopup",provider,resolverInternal)).executeNotNull()})};exports.d=function(user,provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);return(new PopupOperation(userInternal.auth,"linkViaPopup",provider,resolverInternal,userInternal)).executeNotNull()})};exports.e=function(user,
provider,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user);_assertInstanceOf(userInternal.auth,provider,FederatedAuthProvider);const resolverInternal=_withDefaultResolver(userInternal.auth,resolver);return(new PopupOperation(userInternal.auth,"reauthViaPopup",provider,resolverInternal,userInternal)).executeNotNull()})};exports.f=function(auth,provider,resolver){return _signInWithRedirect(auth,provider,resolver)};exports.g=
function(user,provider,resolver){return _linkWithRedirect(user,provider,resolver)};exports.h=function(user,provider,resolver){return _reauthenticateWithRedirect(user,provider,resolver)};exports.j=function(auth,resolver){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield _castAuth(auth)._initializationPromise;return _getRedirectResult(auth,resolver,!1)})};exports.l=function(user,phoneNumber,appVerifier){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=
(0,_util.getModularInstance)(user);yield _assertLinkedStatus(!1,userInternal,"phone");const verificationId=yield _verifyPhoneNumber(userInternal.auth,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,cred=>linkWithCredential(userInternal,cred))})};exports.n=function(app=(0,_app.getApp)()){const provider=(0,_app._getProvider)(app,"auth");return provider.isInitialized()?provider.getImmediate():initializeAuth(app,{popupRedirectResolver:browserPopupRedirectResolver,
persistence:[indexedDBLocalPersistence,browserLocalPersistence,browserSessionPersistence]})};exports.p=function(auth,persistence){return(0,_util.getModularInstance)(auth).setPersistence(persistence)};exports.q=function(auth,nextOrObserver,error,completed){return(0,_util.getModularInstance)(auth).onIdTokenChanged(nextOrObserver,error,completed)};exports.r=function(user,phoneNumber,appVerifier){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const userInternal=(0,_util.getModularInstance)(user),
verificationId=yield _verifyPhoneNumber(userInternal.auth,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,cred=>reauthenticateWithCredential(userInternal,cred))})};exports.s=function(auth,phoneNumber,appVerifier){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const authInternal=_castAuth(auth),verificationId=yield _verifyPhoneNumber(authInternal,phoneNumber,(0,_util.getModularInstance)(appVerifier));return new ConfirmationResultImpl(verificationId,
cred=>signInWithCredential(authInternal,cred))})};exports.t=function(auth,nextOrObserver,error,completed){return(0,_util.getModularInstance)(auth).onAuthStateChanged(nextOrObserver,error,completed)};exports.u=function(user,credential){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield _link$1((0,_util.getModularInstance)(user),credential)})};exports.v=function(auth){(0,_util.getModularInstance)(auth).useDeviceLanguage()};exports.w=function(auth,user){return(0,_util.getModularInstance)(auth).updateCurrentUser(user)};
exports.x=function(auth){return(0,_util.getModularInstance)(auth).signOut()};exports.y=function(user){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return(0,_util.getModularInstance)(user).delete()})};exports.z=exports.o=exports.m=exports.k=exports.i=exports.b=exports.az=exports.ac=exports.aJ=exports.aI=exports.aH=exports.aE=exports.aD=exports.a=exports.V=exports.U=exports.T=exports.S=exports.R=exports.Q=exports.P=exports.O=exports.N=exports.M=exports.L=exports.K=exports.J=exports.I=
exports.H=exports.G=exports.F=exports.C=exports.B=exports.A=void 0;var _util=require("module$node_modules$$firebase$util$dist$index_esm2017"),_app=require("module$node_modules$$firebase$app$dist$esm$index_esm2017"),_tslib=require("module$node_modules$tslib$tslib"),_logger=require("module$node_modules$$firebase$logger$dist$index_cjs"),_component=require("module$node_modules$$firebase$component$dist$esm$index_esm2017");exports.F={PHONE:"phone"};exports.o={FACEBOOK:"facebook.com",GITHUB:"github.com",
GOOGLE:"google.com",PASSWORD:"password",PHONE:"phone",TWITTER:"twitter.com"};exports.S={EMAIL_LINK:"emailLink",EMAIL_PASSWORD:"password",FACEBOOK:"facebook.com",GITHUB:"github.com",GOOGLE:"google.com",PHONE:"phone",TWITTER:"twitter.com"};exports.O={LINK:"link",REAUTHENTICATE:"reauthenticate",SIGN_IN:"signIn"};exports.A={EMAIL_SIGNIN:"EMAIL_SIGNIN",PASSWORD_RESET:"PASSWORD_RESET",RECOVER_EMAIL:"RECOVER_EMAIL",REVERT_SECOND_FACTOR_ADDITION:"REVERT_SECOND_FACTOR_ADDITION",VERIFY_AND_CHANGE_EMAIL:"VERIFY_AND_CHANGE_EMAIL",
VERIFY_EMAIL:"VERIFY_EMAIL"};exports.z=function(){return{["admin-restricted-operation"]:"This operation is restricted to administrators only.",["argument-error"]:"",["app-not-authorized"]:"This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.",["app-not-installed"]:"The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.",
["captcha-check-failed"]:"The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.",["code-expired"]:"The SMS code has expired. Please re-send the verification code to try again.",["cordova-not-ready"]:"Cordova framework is not ready.",["cors-unsupported"]:"This browser is not supported.",["credential-already-in-use"]:"This credential is already associated with a different user account.",["custom-token-mismatch"]:"The custom token corresponds to a different audience.",
["requires-recent-login"]:"This operation is sensitive and requires recent authentication. Log in again before retrying this request.",["dependent-sdk-initialized-before-auth"]:"Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.",["dynamic-link-not-activated"]:"Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.",["email-change-needs-verification"]:"Multi-factor users must always have a verified email.",
["email-already-in-use"]:"The email address is already in use by another account.",["emulator-config-failed"]:'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.',["expired-action-code"]:"The action code has expired.",["cancelled-popup-request"]:"This operation has been cancelled due to another conflicting popup being opened.",["internal-error"]:"An internal AuthError has occurred.",["invalid-app-credential"]:"The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.",
["invalid-app-id"]:"The mobile app identifier is not registed for the current project.",["invalid-user-token"]:"This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.",["invalid-auth-event"]:"An internal AuthError has occurred.",["invalid-verification-code"]:"The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.",
["invalid-continue-uri"]:"The continue URL provided in the request is invalid.",["invalid-cordova-configuration"]:"The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.",["invalid-custom-token"]:"The custom token format is incorrect. Please check the documentation.",["invalid-dynamic-link-domain"]:"The provided dynamic link domain is not configured or authorized for the current project.",
["invalid-email"]:"The email address is badly formatted.",["invalid-emulator-scheme"]:"Emulator URL must start with a valid scheme (http:// or https://).",["invalid-api-key"]:"Your API key is invalid, please check you have copied it correctly.",["invalid-cert-hash"]:"The SHA-1 certificate hash provided is invalid.",["invalid-credential"]:"The supplied auth credential is malformed or has expired.",["invalid-message-payload"]:"The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.",
["invalid-multi-factor-session"]:"The request does not contain a valid proof of first factor successful sign-in.",["invalid-oauth-provider"]:"EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.",["invalid-oauth-client-id"]:"The OAuth client ID provided is either invalid or does not match the specified API key.",["unauthorized-domain"]:"This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.",
["invalid-action-code"]:"The action code is invalid. This can happen if the code is malformed, expired, or has already been used.",["wrong-password"]:"The password is invalid or the user does not have a password.",["invalid-persistence-type"]:"The specified persistence type is invalid. It can only be local, session or none.",["invalid-phone-number"]:"The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].",
["invalid-provider-id"]:"The specified provider ID is invalid.",["invalid-recipient-email"]:"The email corresponding to this action failed to send as the provided recipient email address is invalid.",["invalid-sender"]:"The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.",["invalid-verification-id"]:"The verification ID used to create the phone auth credential is invalid.",["invalid-tenant-id"]:"The Auth instance's tenant ID is invalid.",
["missing-android-pkg-name"]:"An Android Package Name must be provided if the Android App is required to be installed.",["auth-domain-config-required"]:"Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.",["missing-app-credential"]:"The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.",["missing-verification-code"]:"The phone auth credential was created with an empty SMS verification code.",
["missing-continue-uri"]:"A continue URL must be provided in the request.",["missing-iframe-start"]:"An internal AuthError has occurred.",["missing-ios-bundle-id"]:"An iOS Bundle ID must be provided if an App Store ID is provided.",["missing-or-invalid-nonce"]:"The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.",["missing-multi-factor-info"]:"No second factor identifier is provided.",["missing-multi-factor-session"]:"The request is missing proof of first factor successful sign-in.",
["missing-phone-number"]:"To send verification codes, provide a phone number for the recipient.",["missing-verification-id"]:"The phone auth credential was created with an empty verification ID.",["app-deleted"]:"This instance of FirebaseApp has been deleted.",["multi-factor-info-not-found"]:"The user does not have a second factor matching the identifier provided.",["multi-factor-auth-required"]:"Proof of ownership of a second factor is required to complete sign-in.",["account-exists-with-different-credential"]:"An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.",
["network-request-failed"]:"A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.",["no-auth-event"]:"An internal AuthError has occurred.",["no-such-provider"]:"User was not linked to an account with the given provider.",["null-user"]:"A null user object was provided as the argument for an operation which requires a non-null user object.",["operation-not-allowed"]:"The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.",
["operation-not-supported-in-this-environment"]:'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.',["popup-blocked"]:"Unable to establish a connection with the popup. It may have been blocked by the browser.",["popup-closed-by-user"]:"The popup has been closed by the user before finalizing the operation.",["provider-already-linked"]:"User can only be linked to one identity for the given provider.",
["quota-exceeded"]:"The project's quota for this operation has been exceeded.",["redirect-cancelled-by-user"]:"The redirect operation has been cancelled by the user before finalizing.",["redirect-operation-pending"]:"A redirect sign-in operation is already pending.",["rejected-credential"]:"The request contains malformed or mismatching credentials.",["second-factor-already-in-use"]:"The second factor is already enrolled on this account.",["maximum-second-factor-count-exceeded"]:"The maximum allowed number of second factors on a user has been exceeded.",
["tenant-id-mismatch"]:"The provided tenant ID does not match the Auth instance's tenant ID",timeout:"The operation has timed out.",["user-token-expired"]:"The user's credential is no longer valid. The user must sign in again.",["too-many-requests"]:"We have blocked all requests from this device due to unusual activity. Try again later.",["unauthorized-continue-uri"]:"The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.",["unsupported-first-factor"]:"Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.",
["unsupported-persistence-type"]:"The current environment does not support the specified persistence type.",["unsupported-tenant-operation"]:"This operation is not supported in a multi-tenant context.",["unverified-email"]:"The operation requires a verified email.",["user-cancelled"]:"The user did not grant your application the permissions it requested.",["user-not-found"]:"There is no user record corresponding to this identifier. The user may have been deleted.",["user-disabled"]:"The user account has been disabled by an administrator.",
["user-mismatch"]:"The supplied credentials do not correspond to the previously signed in user.",["user-signed-out"]:"",["weak-password"]:"The password must be 6 characters long or more.",["web-storage-unsupported"]:"This browser is not supported or 3rd party cookies and data may be disabled.",["already-initialized"]:"initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance."}};
const prodErrorMap=_prodErrorMap;exports.B=prodErrorMap;const _DEFAULT_AUTH_ERROR_FACTORY=new _util.ErrorFactory("auth","Firebase",_prodErrorMap());exports.C={ADMIN_ONLY_OPERATION:"auth/admin-restricted-operation",ARGUMENT_ERROR:"auth/argument-error",APP_NOT_AUTHORIZED:"auth/app-not-authorized",APP_NOT_INSTALLED:"auth/app-not-installed",CAPTCHA_CHECK_FAILED:"auth/captcha-check-failed",CODE_EXPIRED:"auth/code-expired",CORDOVA_NOT_READY:"auth/cordova-not-ready",CORS_UNSUPPORTED:"auth/cors-unsupported",
CREDENTIAL_ALREADY_IN_USE:"auth/credential-already-in-use",CREDENTIAL_MISMATCH:"auth/custom-token-mismatch",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"auth/requires-recent-login",DEPENDENT_SDK_INIT_BEFORE_AUTH:"auth/dependent-sdk-initialized-before-auth",DYNAMIC_LINK_NOT_ACTIVATED:"auth/dynamic-link-not-activated",EMAIL_CHANGE_NEEDS_VERIFICATION:"auth/email-change-needs-verification",EMAIL_EXISTS:"auth/email-already-in-use",EMULATOR_CONFIG_FAILED:"auth/emulator-config-failed",EXPIRED_OOB_CODE:"auth/expired-action-code",
EXPIRED_POPUP_REQUEST:"auth/cancelled-popup-request",INTERNAL_ERROR:"auth/internal-error",INVALID_API_KEY:"auth/invalid-api-key",INVALID_APP_CREDENTIAL:"auth/invalid-app-credential",INVALID_APP_ID:"auth/invalid-app-id",INVALID_AUTH:"auth/invalid-user-token",INVALID_AUTH_EVENT:"auth/invalid-auth-event",INVALID_CERT_HASH:"auth/invalid-cert-hash",INVALID_CODE:"auth/invalid-verification-code",INVALID_CONTINUE_URI:"auth/invalid-continue-uri",INVALID_CORDOVA_CONFIGURATION:"auth/invalid-cordova-configuration",
INVALID_CUSTOM_TOKEN:"auth/invalid-custom-token",INVALID_DYNAMIC_LINK_DOMAIN:"auth/invalid-dynamic-link-domain",INVALID_EMAIL:"auth/invalid-email",INVALID_EMULATOR_SCHEME:"auth/invalid-emulator-scheme",INVALID_IDP_RESPONSE:"auth/invalid-credential",INVALID_MESSAGE_PAYLOAD:"auth/invalid-message-payload",INVALID_MFA_SESSION:"auth/invalid-multi-factor-session",INVALID_OAUTH_CLIENT_ID:"auth/invalid-oauth-client-id",INVALID_OAUTH_PROVIDER:"auth/invalid-oauth-provider",INVALID_OOB_CODE:"auth/invalid-action-code",
INVALID_ORIGIN:"auth/unauthorized-domain",INVALID_PASSWORD:"auth/wrong-password",INVALID_PERSISTENCE:"auth/invalid-persistence-type",INVALID_PHONE_NUMBER:"auth/invalid-phone-number",INVALID_PROVIDER_ID:"auth/invalid-provider-id",INVALID_RECIPIENT_EMAIL:"auth/invalid-recipient-email",INVALID_SENDER:"auth/invalid-sender",INVALID_SESSION_INFO:"auth/invalid-verification-id",INVALID_TENANT_ID:"auth/invalid-tenant-id",MFA_INFO_NOT_FOUND:"auth/multi-factor-info-not-found",MFA_REQUIRED:"auth/multi-factor-auth-required",
MISSING_ANDROID_PACKAGE_NAME:"auth/missing-android-pkg-name",MISSING_APP_CREDENTIAL:"auth/missing-app-credential",MISSING_AUTH_DOMAIN:"auth/auth-domain-config-required",MISSING_CODE:"auth/missing-verification-code",MISSING_CONTINUE_URI:"auth/missing-continue-uri",MISSING_IFRAME_START:"auth/missing-iframe-start",MISSING_IOS_BUNDLE_ID:"auth/missing-ios-bundle-id",MISSING_OR_INVALID_NONCE:"auth/missing-or-invalid-nonce",MISSING_MFA_INFO:"auth/missing-multi-factor-info",MISSING_MFA_SESSION:"auth/missing-multi-factor-session",
MISSING_PHONE_NUMBER:"auth/missing-phone-number",MISSING_SESSION_INFO:"auth/missing-verification-id",MODULE_DESTROYED:"auth/app-deleted",NEED_CONFIRMATION:"auth/account-exists-with-different-credential",NETWORK_REQUEST_FAILED:"auth/network-request-failed",NULL_USER:"auth/null-user",NO_AUTH_EVENT:"auth/no-auth-event",NO_SUCH_PROVIDER:"auth/no-such-provider",OPERATION_NOT_ALLOWED:"auth/operation-not-allowed",OPERATION_NOT_SUPPORTED:"auth/operation-not-supported-in-this-environment",POPUP_BLOCKED:"auth/popup-blocked",
POPUP_CLOSED_BY_USER:"auth/popup-closed-by-user",PROVIDER_ALREADY_LINKED:"auth/provider-already-linked",QUOTA_EXCEEDED:"auth/quota-exceeded",REDIRECT_CANCELLED_BY_USER:"auth/redirect-cancelled-by-user",REDIRECT_OPERATION_PENDING:"auth/redirect-operation-pending",REJECTED_CREDENTIAL:"auth/rejected-credential",SECOND_FACTOR_ALREADY_ENROLLED:"auth/second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"auth/maximum-second-factor-count-exceeded",TENANT_ID_MISMATCH:"auth/tenant-id-mismatch",TIMEOUT:"auth/timeout",
TOKEN_EXPIRED:"auth/user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"auth/too-many-requests",UNAUTHORIZED_DOMAIN:"auth/unauthorized-continue-uri",UNSUPPORTED_FIRST_FACTOR:"auth/unsupported-first-factor",UNSUPPORTED_PERSISTENCE:"auth/unsupported-persistence-type",UNSUPPORTED_TENANT_OPERATION:"auth/unsupported-tenant-operation",UNVERIFIED_EMAIL:"auth/unverified-email",USER_CANCELLED:"auth/user-cancelled",USER_DELETED:"auth/user-not-found",USER_DISABLED:"auth/user-disabled",USER_MISMATCH:"auth/user-mismatch",
USER_SIGNED_OUT:"auth/user-signed-out",WEAK_PASSWORD:"auth/weak-password",WEB_STORAGE_UNSUPPORTED:"auth/web-storage-unsupported",ALREADY_INITIALIZED:"auth/already-initialized"};const logClient=new _logger.Logger("@firebase/auth"),instanceCache=new Map;class Delay{constructor(shortDelay,longDelay){this.shortDelay=shortDelay;this.longDelay=longDelay;debugAssert(longDelay>shortDelay,"Short delay should be less than long delay!");this.isMobile=(0,_util.isMobileCordova)()||(0,_util.isReactNative)()}get(){var JSCompiler_inline_result=
"undefined"!==typeof navigator&&navigator&&"onLine"in navigator&&"boolean"===typeof navigator.onLine&&(_isHttpOrHttps()||(0,_util.isBrowserExtension)()||"connection"in navigator)?navigator.onLine:!0;return JSCompiler_inline_result?this.isMobile?this.longDelay:this.shortDelay:Math.min(5E3,this.shortDelay)}}class FetchProvider{static initialize(fetchImpl,headersImpl,responseImpl){this.fetchImpl=fetchImpl;headersImpl&&(this.headersImpl=headersImpl);responseImpl&&(this.responseImpl=responseImpl)}static fetch(){if(this.fetchImpl)return this.fetchImpl;
if("undefined"!==typeof self&&"fetch"in self)return self.fetch;debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static headers(){if(this.headersImpl)return this.headersImpl;if("undefined"!==typeof self&&"Headers"in self)return self.Headers;debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}static response(){if(this.responseImpl)return this.responseImpl;
if("undefined"!==typeof self&&"Response"in self)return self.Response;debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")}}exports.aI=FetchProvider;const SERVER_ERROR_MAP={CREDENTIAL_MISMATCH:"custom-token-mismatch",MISSING_CUSTOM_TOKEN:"internal-error",INVALID_IDENTIFIER:"invalid-email",MISSING_CONTINUE_URI:"internal-error",INVALID_PASSWORD:"wrong-password",MISSING_PASSWORD:"internal-error",EMAIL_EXISTS:"email-already-in-use",
PASSWORD_LOGIN_DISABLED:"operation-not-allowed",INVALID_IDP_RESPONSE:"invalid-credential",INVALID_PENDING_TOKEN:"invalid-credential",FEDERATED_USER_ID_ALREADY_LINKED:"credential-already-in-use",MISSING_REQ_TYPE:"internal-error",EMAIL_NOT_FOUND:"user-not-found",RESET_PASSWORD_EXCEED_LIMIT:"too-many-requests",EXPIRED_OOB_CODE:"expired-action-code",INVALID_OOB_CODE:"invalid-action-code",MISSING_OOB_CODE:"internal-error",CREDENTIAL_TOO_OLD_LOGIN_AGAIN:"requires-recent-login",INVALID_ID_TOKEN:"invalid-user-token",
TOKEN_EXPIRED:"user-token-expired",USER_NOT_FOUND:"user-token-expired",TOO_MANY_ATTEMPTS_TRY_LATER:"too-many-requests",INVALID_CODE:"invalid-verification-code",INVALID_SESSION_INFO:"invalid-verification-id",INVALID_TEMPORARY_PROOF:"invalid-credential",MISSING_SESSION_INFO:"missing-verification-id",SESSION_EXPIRED:"code-expired",MISSING_ANDROID_PACKAGE_NAME:"missing-android-pkg-name",UNAUTHORIZED_DOMAIN:"unauthorized-continue-uri",INVALID_OAUTH_CLIENT_ID:"invalid-oauth-client-id",ADMIN_ONLY_OPERATION:"admin-restricted-operation",
INVALID_MFA_PENDING_CREDENTIAL:"invalid-multi-factor-session",MFA_ENROLLMENT_NOT_FOUND:"multi-factor-info-not-found",MISSING_MFA_ENROLLMENT_ID:"missing-multi-factor-info",MISSING_MFA_PENDING_CREDENTIAL:"missing-multi-factor-session",SECOND_FACTOR_EXISTS:"second-factor-already-in-use",SECOND_FACTOR_LIMIT_EXCEEDED:"maximum-second-factor-count-exceeded",BLOCKING_FUNCTION_ERROR_RESPONSE:"internal-error"},DEFAULT_API_TIMEOUT_MS=new Delay(3E4,6E4);class NetworkTimeout{constructor(auth){this.auth=auth;this.timer=
null;this.promise=new Promise((_,reject)=>{this.timer=setTimeout(()=>reject(_createError(this.auth,"network-request-failed")),DEFAULT_API_TIMEOUT_MS.get())})}clearNetworkTimeout(){clearTimeout(this.timer)}}class ProactiveRefresh{constructor(user){this.user=user;this.isRunning=!1;this.timerId=null;this.errorBackoff=3E4}_start(){this.isRunning||(this.isRunning=!0,this.schedule())}_stop(){this.isRunning&&(this.isRunning=!1,null!==this.timerId&&clearTimeout(this.timerId))}getInterval(wasError){if(wasError){var _a=
this.errorBackoff;this.errorBackoff=Math.min(2*this.errorBackoff,96E4);return _a}this.errorBackoff=3E4;wasError=(null!==(_a=this.user.stsTokenManager.expirationTime)&&void 0!==_a?_a:0)-Date.now()-3E5;return Math.max(0,wasError)}schedule(wasError=!1){this.isRunning&&(wasError=this.getInterval(wasError),this.timerId=setTimeout(()=>{const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this.iteration()})},wasError))}iteration(){const $jscomp$async$this=
this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){try{yield $jscomp$async$this.user.getIdToken(!0)}catch(e){"auth/network-request-failed"===e.code&&$jscomp$async$this.schedule(!0);return}$jscomp$async$this.schedule()})}}class UserMetadata{constructor(createdAt,lastLoginAt){this.createdAt=createdAt;this.lastLoginAt=lastLoginAt;this._initializeTime()}_initializeTime(){this.lastSignInTime=utcTimestampToDateString(this.lastLoginAt);this.creationTime=utcTimestampToDateString(this.createdAt)}_copy(metadata){this.createdAt=
metadata.createdAt;this.lastLoginAt=metadata.lastLoginAt;this._initializeTime()}toJSON(){return{createdAt:this.createdAt,lastLoginAt:this.lastLoginAt}}}class StsTokenManager{constructor(){this.expirationTime=this.accessToken=this.refreshToken=null}get isExpired(){return!this.expirationTime||Date.now()>this.expirationTime-3E4}updateFromServerResponse(response){_assert(response.idToken,"internal-error");_assert("undefined"!==typeof response.idToken,"internal-error");_assert("undefined"!==typeof response.refreshToken,
"internal-error");if("expiresIn"in response&&"undefined"!==typeof response.expiresIn)var JSCompiler_temp=Number(response.expiresIn);else JSCompiler_temp=_parseToken(response.idToken),_assert(JSCompiler_temp,"internal-error"),_assert("undefined"!==typeof JSCompiler_temp.exp,"internal-error"),_assert("undefined"!==typeof JSCompiler_temp.iat,"internal-error"),JSCompiler_temp=Number(JSCompiler_temp.exp)-Number(JSCompiler_temp.iat);this.updateTokensAndExpiration(response.idToken,response.refreshToken,
JSCompiler_temp)}getToken(auth,forceRefresh=!1){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){_assert(!$jscomp$async$this.accessToken||$jscomp$async$this.refreshToken,auth,"user-token-expired");return forceRefresh||!$jscomp$async$this.accessToken||$jscomp$async$this.isExpired?$jscomp$async$this.refreshToken?(yield $jscomp$async$this.refresh(auth,$jscomp$async$this.refreshToken),$jscomp$async$this.accessToken):null:$jscomp$async$this.accessToken})}clearRefreshToken(){this.refreshToken=
null}refresh(auth,oldToken){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {accessToken,refreshToken,expiresIn}=yield requestStsToken(auth,oldToken);$jscomp$async$this.updateTokensAndExpiration(accessToken,refreshToken,Number(expiresIn))})}updateTokensAndExpiration(accessToken,refreshToken,expiresInSec){this.refreshToken=refreshToken||null;this.accessToken=accessToken||null;this.expirationTime=Date.now()+1E3*expiresInSec}static fromJSON(appName,
object){const {refreshToken,accessToken,expirationTime}=object;object=new StsTokenManager;refreshToken&&(_assert("string"===typeof refreshToken,"internal-error",{appName}),object.refreshToken=refreshToken);accessToken&&(_assert("string"===typeof accessToken,"internal-error",{appName}),object.accessToken=accessToken);expirationTime&&(_assert("number"===typeof expirationTime,"internal-error",{appName}),object.expirationTime=expirationTime);return object}toJSON(){return{refreshToken:this.refreshToken,
accessToken:this.accessToken,expirationTime:this.expirationTime}}_assign(stsTokenManager){this.accessToken=stsTokenManager.accessToken;this.refreshToken=stsTokenManager.refreshToken;this.expirationTime=stsTokenManager.expirationTime}_clone(){return Object.assign(new StsTokenManager,this.toJSON())}_performRefresh(){return debugFail("not implemented")}}class UserImpl{constructor(_a){var {uid,auth,stsTokenManager}=_a;_a=(0,_tslib.__rest)(_a,["uid","auth","stsTokenManager"]);this.providerId="firebase";
this.proactiveRefresh=new ProactiveRefresh(this);this.reloadListener=this.reloadUserInfo=null;this.uid=uid;this.auth=auth;this.stsTokenManager=stsTokenManager;this.accessToken=stsTokenManager.accessToken;this.displayName=_a.displayName||null;this.email=_a.email||null;this.emailVerified=_a.emailVerified||!1;this.phoneNumber=_a.phoneNumber||null;this.photoURL=_a.photoURL||null;this.isAnonymous=_a.isAnonymous||!1;this.tenantId=_a.tenantId||null;this.providerData=_a.providerData?[..._a.providerData]:
[];this.metadata=new UserMetadata(_a.createdAt||void 0,_a.lastLoginAt||void 0)}getIdToken(forceRefresh){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const accessToken=yield _logoutIfInvalidated($jscomp$async$this,$jscomp$async$this.stsTokenManager.getToken($jscomp$async$this.auth,forceRefresh));_assert(accessToken,$jscomp$async$this.auth,"internal-error");$jscomp$async$this.accessToken!==accessToken&&($jscomp$async$this.accessToken=accessToken,yield $jscomp$async$this.auth._persistUserIfCurrent($jscomp$async$this),
$jscomp$async$this.auth._notifyListenersIfCurrent($jscomp$async$this));return accessToken})}getIdTokenResult(forceRefresh){return getIdTokenResult(this,forceRefresh)}reload(){return reload(this)}_assign(user){this!==user&&(_assert(this.uid===user.uid,this.auth,"internal-error"),this.displayName=user.displayName,this.photoURL=user.photoURL,this.email=user.email,this.emailVerified=user.emailVerified,this.phoneNumber=user.phoneNumber,this.isAnonymous=user.isAnonymous,this.tenantId=user.tenantId,this.providerData=
user.providerData.map(userInfo=>Object.assign({},userInfo)),this.metadata._copy(user.metadata),this.stsTokenManager._assign(user.stsTokenManager))}_clone(auth){return new UserImpl(Object.assign(Object.assign({},this),{auth,stsTokenManager:this.stsTokenManager._clone()}))}_onReload(callback){_assert(!this.reloadListener,this.auth,"internal-error");this.reloadListener=callback;this.reloadUserInfo&&(this._notifyReloadListener(this.reloadUserInfo),this.reloadUserInfo=null)}_notifyReloadListener(userInfo){this.reloadListener?
this.reloadListener(userInfo):this.reloadUserInfo=userInfo}_startProactiveRefresh(){this.proactiveRefresh._start()}_stopProactiveRefresh(){this.proactiveRefresh._stop()}_updateTokensIfNecessary(response,reload=!1){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){let tokensRefreshed=!1;response.idToken&&response.idToken!==$jscomp$async$this.stsTokenManager.accessToken&&($jscomp$async$this.stsTokenManager.updateFromServerResponse(response),tokensRefreshed=
!0);reload&&(yield _reloadWithoutSaving($jscomp$async$this));yield $jscomp$async$this.auth._persistUserIfCurrent($jscomp$async$this);tokensRefreshed&&$jscomp$async$this.auth._notifyListenersIfCurrent($jscomp$async$this)})}delete(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const idToken=yield $jscomp$async$this.getIdToken();yield _logoutIfInvalidated($jscomp$async$this,deleteAccount($jscomp$async$this.auth,{idToken}));$jscomp$async$this.stsTokenManager.clearRefreshToken();
return $jscomp$async$this.auth.signOut()})}toJSON(){return Object.assign(Object.assign({uid:this.uid,email:this.email||void 0,emailVerified:this.emailVerified,displayName:this.displayName||void 0,isAnonymous:this.isAnonymous,photoURL:this.photoURL||void 0,phoneNumber:this.phoneNumber||void 0,tenantId:this.tenantId||void 0,providerData:this.providerData.map(userInfo=>Object.assign({},userInfo)),stsTokenManager:this.stsTokenManager.toJSON(),_redirectEventId:this._redirectEventId},this.metadata.toJSON()),
{apiKey:this.auth.config.apiKey,appName:this.auth.name})}get refreshToken(){return this.stsTokenManager.refreshToken||""}static _fromJSON(auth,object){var _a,_b,_c,_d,_e,_f,_g,_h;const displayName=null!==(_a=object.displayName)&&void 0!==_a?_a:void 0;_a=null!==(_b=object.email)&&void 0!==_b?_b:void 0;_b=null!==(_c=object.phoneNumber)&&void 0!==_c?_c:void 0;_c=null!==(_d=object.photoURL)&&void 0!==_d?_d:void 0;_d=null!==(_e=object.tenantId)&&void 0!==_e?_e:void 0;_e=null!==(_f=object._redirectEventId)&&
void 0!==_f?_f:void 0;_f=null!==(_g=object.createdAt)&&void 0!==_g?_g:void 0;_g=null!==(_h=object.lastLoginAt)&&void 0!==_h?_h:void 0;const {uid,emailVerified,isAnonymous,providerData,stsTokenManager:plainObjectTokenManager}=object;_assert(uid&&plainObjectTokenManager,auth,"internal-error");object=StsTokenManager.fromJSON(this.name,plainObjectTokenManager);_assert("string"===typeof uid,auth,"internal-error");assertStringOrUndefined(displayName,auth.name);assertStringOrUndefined(_a,auth.name);_assert("boolean"===
typeof emailVerified,auth,"internal-error");_assert("boolean"===typeof isAnonymous,auth,"internal-error");assertStringOrUndefined(_b,auth.name);assertStringOrUndefined(_c,auth.name);assertStringOrUndefined(_d,auth.name);assertStringOrUndefined(_e,auth.name);assertStringOrUndefined(_f,auth.name);assertStringOrUndefined(_g,auth.name);auth=new UserImpl({uid,auth,email:_a,emailVerified,displayName,isAnonymous,photoURL:_c,phoneNumber:_b,tenantId:_d,stsTokenManager:object,createdAt:_f,lastLoginAt:_g});
providerData&&Array.isArray(providerData)&&(auth.providerData=providerData.map(userInfo=>Object.assign({},userInfo)));_e&&(auth._redirectEventId=_e);return auth}static _fromIdTokenResponse(auth,idTokenResponse,isAnonymous=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var stsTokenManager=new StsTokenManager;stsTokenManager.updateFromServerResponse(idTokenResponse);stsTokenManager=new UserImpl({uid:idTokenResponse.localId,auth,stsTokenManager,isAnonymous});yield _reloadWithoutSaving(stsTokenManager);
return stsTokenManager})}}exports.aD=UserImpl;class InMemoryPersistence{constructor(){this.type="NONE";this.storage={}}_isAvailable(){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return!0})}_set(key,value){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.storage[key]=value})}_get(key){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const value=$jscomp$async$this.storage[key];
return void 0===value?null:value})}_remove(key){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){delete $jscomp$async$this.storage[key]})}_addListener(_key,_listener){}_removeListener(_key,_listener){}}InMemoryPersistence.type="NONE";const inMemoryPersistence=InMemoryPersistence;exports.K=inMemoryPersistence;class PersistenceUserManager{constructor(persistence,auth,userKey){this.persistence=persistence;this.auth=auth;this.userKey=userKey;const {config,
name}=this.auth;this.fullUserKey=_persistenceKeyName(this.userKey,config.apiKey,name);this.fullPersistenceKey=_persistenceKeyName("persistence",config.apiKey,name);this.boundEventHandler=auth._onStorageEvent.bind(auth);this.persistence._addListener(this.fullUserKey,this.boundEventHandler)}setCurrentUser(user){return this.persistence._set(this.fullUserKey,user.toJSON())}getCurrentUser(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const blob=yield $jscomp$async$this.persistence._get($jscomp$async$this.fullUserKey);
return blob?UserImpl._fromJSON($jscomp$async$this.auth,blob):null})}removeCurrentUser(){return this.persistence._remove(this.fullUserKey)}savePersistenceForRedirect(){return this.persistence._set(this.fullPersistenceKey,this.persistence.type)}setPersistence(newPersistence){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if($jscomp$async$this.persistence!==newPersistence){var currentUser=yield $jscomp$async$this.getCurrentUser();yield $jscomp$async$this.removeCurrentUser();
$jscomp$async$this.persistence=newPersistence;if(currentUser)return $jscomp$async$this.setCurrentUser(currentUser)}})}delete(){this.persistence._removeListener(this.fullUserKey,this.boundEventHandler)}static create(auth,persistenceHierarchy,userKey="authUser"){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(!persistenceHierarchy.length)return new PersistenceUserManager(_getInstance(inMemoryPersistence),auth,userKey);var availablePersistences=(yield Promise.all(persistenceHierarchy.map(persistence=>
$jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(yield persistence._isAvailable())return persistence})))).filter(persistence=>persistence);let selectedPersistence=availablePersistences[0]||_getInstance(inMemoryPersistence);const key=_persistenceKeyName(userKey,auth.config.apiKey,auth.name);let userToMigrate=null;for(const persistence of persistenceHierarchy)try{const blob=yield persistence._get(key);if(blob){const user=UserImpl._fromJSON(auth,blob);persistence!==selectedPersistence&&(userToMigrate=
user);selectedPersistence=persistence;break}}catch(_a){}availablePersistences=availablePersistences.filter(p=>p._shouldAllowMigration);if(!selectedPersistence._shouldAllowMigration||!availablePersistences.length)return new PersistenceUserManager(selectedPersistence,auth,userKey);selectedPersistence=availablePersistences[0];userToMigrate&&(yield selectedPersistence._set(key,userToMigrate.toJSON()));yield Promise.all(persistenceHierarchy.map(persistence=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(persistence!==
selectedPersistence)try{yield persistence._remove(key)}catch(_a){}})));return new PersistenceUserManager(selectedPersistence,auth,userKey)})}}class AuthImpl{constructor(app,heartbeatServiceProvider,config){this.app=app;this.heartbeatServiceProvider=heartbeatServiceProvider;this.config=config;this.emulatorConfig=this.currentUser=null;this.operations=Promise.resolve();this.authStateSubscription=new Subscription(this);this.idTokenSubscription=new Subscription(this);this.redirectUser=null;this.isProactiveRefreshEnabled=
!1;this._canInitEmulator=!0;this._deleted=this._isInitialized=!1;this._popupRedirectResolver=this._initializationPromise=null;this._errorFactory=_DEFAULT_AUTH_ERROR_FACTORY;this.lastNotifiedUid=void 0;this.tenantId=this.languageCode=null;this.settings={appVerificationDisabledForTesting:!1};this.frameworks=[];this.name=app.name;this.clientVersion=config.sdkClientVersion}_initializeWithPersistence(persistenceHierarchy,popupRedirectResolver){popupRedirectResolver&&(this._popupRedirectResolver=_getInstance(popupRedirectResolver));
return this._initializationPromise=this.queue(()=>{const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a,_b;if(!$jscomp$async$this._deleted&&($jscomp$async$this.persistenceManager=yield PersistenceUserManager.create($jscomp$async$this,persistenceHierarchy),!$jscomp$async$this._deleted)){if(null===(_a=$jscomp$async$this._popupRedirectResolver)||void 0===_a?0:_a._shouldInitProactively)try{yield $jscomp$async$this._popupRedirectResolver._initialize($jscomp$async$this)}catch(e){}yield $jscomp$async$this.initializeCurrentUser(popupRedirectResolver);
$jscomp$async$this.lastNotifiedUid=(null===(_b=$jscomp$async$this.currentUser)||void 0===_b?void 0:_b.uid)||null;$jscomp$async$this._deleted||($jscomp$async$this._isInitialized=!0)}})})}_onStorageEvent(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(!$jscomp$async$this._deleted){var user=yield $jscomp$async$this.assertedPersistence.getCurrentUser();if($jscomp$async$this.currentUser||user)$jscomp$async$this.currentUser&&user&&$jscomp$async$this.currentUser.uid===
user.uid?($jscomp$async$this._currentUser._assign(user),yield $jscomp$async$this.currentUser.getIdToken()):yield $jscomp$async$this._updateCurrentUser(user)}})}initializeCurrentUser(popupRedirectResolver){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;let storedUser=yield $jscomp$async$this.assertedPersistence.getCurrentUser();if(popupRedirectResolver&&$jscomp$async$this.config.authDomain){yield $jscomp$async$this.getOrInitRedirectPersistenceManager();
const redirectUserEventId=null===(_a=$jscomp$async$this.redirectUser)||void 0===_a?void 0:_a._redirectEventId;_a=null===storedUser||void 0===storedUser?void 0:storedUser._redirectEventId;const result=yield $jscomp$async$this.tryRedirectSignIn(popupRedirectResolver);redirectUserEventId&&redirectUserEventId!==_a||null===result||void 0===result||!result.user||(storedUser=result.user)}if(!storedUser)return $jscomp$async$this.directlySetCurrentUser(null);if(!storedUser._redirectEventId)return $jscomp$async$this.reloadAndSetCurrentUserOrClear(storedUser);
_assert($jscomp$async$this._popupRedirectResolver,$jscomp$async$this,"argument-error");yield $jscomp$async$this.getOrInitRedirectPersistenceManager();return $jscomp$async$this.redirectUser&&$jscomp$async$this.redirectUser._redirectEventId===storedUser._redirectEventId?$jscomp$async$this.directlySetCurrentUser(storedUser):$jscomp$async$this.reloadAndSetCurrentUserOrClear(storedUser)})}tryRedirectSignIn(redirectResolver){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){let result=
null;try{result=yield $jscomp$async$this._popupRedirectResolver._completeRedirectFn($jscomp$async$this,redirectResolver,!0)}catch(e){yield $jscomp$async$this._setRedirectUser(null)}return result})}reloadAndSetCurrentUserOrClear(user){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){try{yield _reloadWithoutSaving(user)}catch(e){if("auth/network-request-failed"!==e.code)return $jscomp$async$this.directlySetCurrentUser(null)}return $jscomp$async$this.directlySetCurrentUser(user)})}useDeviceLanguage(){if("undefined"===
typeof navigator)var JSCompiler_inline_result=null;else JSCompiler_inline_result=navigator,JSCompiler_inline_result=JSCompiler_inline_result.languages&&JSCompiler_inline_result.languages[0]||JSCompiler_inline_result.language||null;this.languageCode=JSCompiler_inline_result}_delete(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this._deleted=!0})}updateCurrentUser(userExtern){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const user=
userExtern?(0,_util.getModularInstance)(userExtern):null;user&&_assert(user.auth.config.apiKey===$jscomp$async$this.config.apiKey,$jscomp$async$this,"invalid-user-token");return $jscomp$async$this._updateCurrentUser(user&&user._clone($jscomp$async$this))})}_updateCurrentUser(user){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(!$jscomp$async$this._deleted)return user&&_assert($jscomp$async$this.tenantId===user.tenantId,$jscomp$async$this,"tenant-id-mismatch"),
$jscomp$async$this.queue(()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this.directlySetCurrentUser(user);$jscomp$async$this.notifyAuthListeners()}))})}signOut(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if($jscomp$async$this.redirectPersistenceManager||$jscomp$async$this._popupRedirectResolver)yield $jscomp$async$this._setRedirectUser(null);return $jscomp$async$this._updateCurrentUser(null)})}setPersistence(persistence){return this.queue(()=>
{const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this.assertedPersistence.setPersistence(_getInstance(persistence))})})}_getPersistence(){return this.assertedPersistence.persistence.type}_updateErrorMap(errorMap){this._errorFactory=new _util.ErrorFactory("auth","Firebase",errorMap())}onAuthStateChanged(nextOrObserver,error,completed){return this.registerStateListener(this.authStateSubscription,nextOrObserver,error,completed)}onIdTokenChanged(nextOrObserver,
error,completed){return this.registerStateListener(this.idTokenSubscription,nextOrObserver,error,completed)}toJSON(){var _a;return{apiKey:this.config.apiKey,authDomain:this.config.authDomain,appName:this.name,currentUser:null===(_a=this._currentUser)||void 0===_a?void 0:_a.toJSON()}}_setRedirectUser(user,popupRedirectResolver){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const redirectManager=yield $jscomp$async$this.getOrInitRedirectPersistenceManager(popupRedirectResolver);
return null===user?redirectManager.removeCurrentUser():redirectManager.setCurrentUser(user)})}getOrInitRedirectPersistenceManager(popupRedirectResolver){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(!$jscomp$async$this.redirectPersistenceManager){const resolver=popupRedirectResolver&&_getInstance(popupRedirectResolver)||$jscomp$async$this._popupRedirectResolver;_assert(resolver,$jscomp$async$this,"argument-error");$jscomp$async$this.redirectPersistenceManager=
yield PersistenceUserManager.create($jscomp$async$this,[_getInstance(resolver._redirectPersistence)],"redirectUser");$jscomp$async$this.redirectUser=yield $jscomp$async$this.redirectPersistenceManager.getCurrentUser()}return $jscomp$async$this.redirectPersistenceManager})}_redirectUserForId(id){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a,_b;$jscomp$async$this._isInitialized&&(yield $jscomp$async$this.queue(()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){})));
return(null===(_a=$jscomp$async$this._currentUser)||void 0===_a?void 0:_a._redirectEventId)===id?$jscomp$async$this._currentUser:(null===(_b=$jscomp$async$this.redirectUser)||void 0===_b?void 0:_b._redirectEventId)===id?$jscomp$async$this.redirectUser:null})}_persistUserIfCurrent(user){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if(user===$jscomp$async$this.currentUser)return $jscomp$async$this.queue(()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){return $jscomp$async$this.directlySetCurrentUser(user)}))})}_notifyListenersIfCurrent(user){user===
this.currentUser&&this.notifyAuthListeners()}_key(){return`${this.config.authDomain}:${this.config.apiKey}:${this.name}`}_startProactiveRefresh(){this.isProactiveRefreshEnabled=!0;this.currentUser&&this._currentUser._startProactiveRefresh()}_stopProactiveRefresh(){this.isProactiveRefreshEnabled=!1;this.currentUser&&this._currentUser._stopProactiveRefresh()}get _currentUser(){return this.currentUser}notifyAuthListeners(){var _a,_b;if(this._isInitialized){this.idTokenSubscription.next(this.currentUser);
var currentUid=null!==(_b=null===(_a=this.currentUser)||void 0===_a?void 0:_a.uid)&&void 0!==_b?_b:null;this.lastNotifiedUid!==currentUid&&(this.lastNotifiedUid=currentUid,this.authStateSubscription.next(this.currentUser))}}registerStateListener(subscription,nextOrObserver,error,completed){if(this._deleted)return()=>{};const cb="function"===typeof nextOrObserver?nextOrObserver:nextOrObserver.next.bind(nextOrObserver),promise=this._isInitialized?Promise.resolve():this._initializationPromise;_assert(promise,
this,"internal-error");promise.then(()=>cb(this.currentUser));return"function"===typeof nextOrObserver?subscription.addObserver(nextOrObserver,error,completed):subscription.addObserver(nextOrObserver)}directlySetCurrentUser(user){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.currentUser&&$jscomp$async$this.currentUser!==user&&($jscomp$async$this._currentUser._stopProactiveRefresh(),user&&$jscomp$async$this.isProactiveRefreshEnabled&&
user._startProactiveRefresh());($jscomp$async$this.currentUser=user)?yield $jscomp$async$this.assertedPersistence.setCurrentUser(user):yield $jscomp$async$this.assertedPersistence.removeCurrentUser()})}queue(action){return this.operations=this.operations.then(action,action)}get assertedPersistence(){_assert(this.persistenceManager,this,"internal-error");return this.persistenceManager}_logFramework(framework){framework&&!this.frameworks.includes(framework)&&(this.frameworks.push(framework),this.frameworks.sort(),
this.clientVersion=_getClientVersion(this.config.clientPlatform,this._getFrameworks()))}_getFrameworks(){return this.frameworks}_getAdditionalHeaders(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;const headers={["X-Client-Version"]:$jscomp$async$this.clientVersion};$jscomp$async$this.app.options.appId&&(headers["X-Firebase-gmpid"]=$jscomp$async$this.app.options.appId);const heartbeatsHeader=yield null===(_a=$jscomp$async$this.heartbeatServiceProvider.getImmediate({optional:!0}))||
void 0===_a?void 0:_a.getHeartbeatsHeader();heartbeatsHeader&&(headers["X-Firebase-Client"]=heartbeatsHeader);return headers})}}exports.aE=AuthImpl;class Subscription{constructor(auth){this.auth=auth;this.observer=null;this.addObserver=(0,_util.createSubscribe)(observer=>this.observer=observer)}get next(){_assert(this.observer,this.auth,"internal-error");return this.observer.next.bind(this.observer)}}class AuthCredential{constructor(providerId,signInMethod){this.providerId=providerId;this.signInMethod=
signInMethod}toJSON(){return debugFail("not implemented")}_getIdTokenResponse(_auth){return debugFail("not implemented")}_linkToIdToken(_auth,_idToken){return debugFail("not implemented")}_getReauthenticationResolver(_auth){return debugFail("not implemented")}}exports.G=AuthCredential;class EmailAuthCredential extends AuthCredential{constructor(_email,_password,signInMethod,_tenantId=null){super("password",signInMethod);this._email=_email;this._password=_password;this._tenantId=_tenantId}static _fromEmailAndPassword(email,
password){return new EmailAuthCredential(email,password,"password")}static _fromEmailAndCode(email,oobCode,tenantId=null){return new EmailAuthCredential(email,oobCode,"emailLink",tenantId)}toJSON(){return{email:this._email,password:this._password,signInMethod:this.signInMethod,tenantId:this._tenantId}}static fromJSON(json){json="string"===typeof json?JSON.parse(json):json;if((null===json||void 0===json?0:json.email)&&(null===json||void 0===json?0:json.password)){if("password"===json.signInMethod)return this._fromEmailAndPassword(json.email,
json.password);if("emailLink"===json.signInMethod)return this._fromEmailAndCode(json.email,json.password,json.tenantId)}return null}_getIdTokenResponse(auth){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){switch($jscomp$async$this.signInMethod){case "password":return signInWithPassword(auth,{returnSecureToken:!0,email:$jscomp$async$this._email,password:$jscomp$async$this._password});case "emailLink":return signInWithEmailLink$1(auth,{email:$jscomp$async$this._email,
oobCode:$jscomp$async$this._password});default:_fail(auth,"internal-error")}})}_linkToIdToken(auth,idToken){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){switch($jscomp$async$this.signInMethod){case "password":return updateEmailPassword(auth,{idToken,returnSecureToken:!0,email:$jscomp$async$this._email,password:$jscomp$async$this._password});case "emailLink":return signInWithEmailLinkForLinking(auth,{idToken,email:$jscomp$async$this._email,oobCode:$jscomp$async$this._password});
default:_fail(auth,"internal-error")}})}_getReauthenticationResolver(auth){return this._getIdTokenResponse(auth)}}exports.H=EmailAuthCredential;class OAuthCredential extends AuthCredential{constructor(){super(...arguments);this.pendingToken=null}static _fromParams(params){const cred=new OAuthCredential(params.providerId,params.signInMethod);params.idToken||params.accessToken?(params.idToken&&(cred.idToken=params.idToken),params.accessToken&&(cred.accessToken=params.accessToken),params.nonce&&!params.pendingToken&&
(cred.nonce=params.nonce),params.pendingToken&&(cred.pendingToken=params.pendingToken)):params.oauthToken&&params.oauthTokenSecret?(cred.accessToken=params.oauthToken,cred.secret=params.oauthTokenSecret):_fail("argument-error");return cred}toJSON(){return{idToken:this.idToken,accessToken:this.accessToken,secret:this.secret,nonce:this.nonce,pendingToken:this.pendingToken,providerId:this.providerId,signInMethod:this.signInMethod}}static fromJSON(json){json="string"===typeof json?JSON.parse(json):json;
const {providerId,signInMethod}=json;json=(0,_tslib.__rest)(json,["providerId","signInMethod"]);if(!providerId||!signInMethod)return null;const cred=new OAuthCredential(providerId,signInMethod);cred.idToken=json.idToken||void 0;cred.accessToken=json.accessToken||void 0;cred.secret=json.secret;cred.nonce=json.nonce;cred.pendingToken=json.pendingToken||null;return cred}_getIdTokenResponse(auth){const request=this.buildRequest();return signInWithIdp(auth,request)}_linkToIdToken(auth,idToken){const request=
this.buildRequest();request.idToken=idToken;return signInWithIdp(auth,request)}_getReauthenticationResolver(auth){const request=this.buildRequest();request.autoCreate=!1;return signInWithIdp(auth,request)}buildRequest(){const request={requestUri:"http://localhost",returnSecureToken:!0};if(this.pendingToken)request.pendingToken=this.pendingToken;else{const postBody={};this.idToken&&(postBody.id_token=this.idToken);this.accessToken&&(postBody.access_token=this.accessToken);this.secret&&(postBody.oauth_token_secret=
this.secret);postBody.providerId=this.providerId;this.nonce&&!this.pendingToken&&(postBody.nonce=this.nonce);request.postBody=(0,_util.querystring)(postBody)}return request}}exports.I=OAuthCredential;const VERIFY_PHONE_NUMBER_FOR_EXISTING_ERROR_MAP_={USER_NOT_FOUND:"user-not-found"};class PhoneAuthCredential extends AuthCredential{constructor(params){super("phone","phone");this.params=params}static _fromVerification(verificationId,verificationCode){return new PhoneAuthCredential({verificationId,verificationCode})}static _fromTokenResponse(phoneNumber,
temporaryProof){return new PhoneAuthCredential({phoneNumber,temporaryProof})}_getIdTokenResponse(auth){return signInWithPhoneNumber$1(auth,this._makeVerificationRequest())}_linkToIdToken(auth,idToken){return linkWithPhoneNumber$1(auth,Object.assign({idToken},this._makeVerificationRequest()))}_getReauthenticationResolver(auth){return verifyPhoneNumberForExisting(auth,this._makeVerificationRequest())}_makeVerificationRequest(){const {temporaryProof,phoneNumber,verificationId,verificationCode}=this.params;
return temporaryProof&&phoneNumber?{temporaryProof,phoneNumber}:{sessionInfo:verificationId,code:verificationCode}}toJSON(){const obj={providerId:this.providerId};this.params.phoneNumber&&(obj.phoneNumber=this.params.phoneNumber);this.params.temporaryProof&&(obj.temporaryProof=this.params.temporaryProof);this.params.verificationCode&&(obj.verificationCode=this.params.verificationCode);this.params.verificationId&&(obj.verificationId=this.params.verificationId);return obj}static fromJSON(json){"string"===
typeof json&&(json=JSON.parse(json));const {verificationId,verificationCode,phoneNumber,temporaryProof}=json;return verificationCode||verificationId||phoneNumber||temporaryProof?new PhoneAuthCredential({verificationId,verificationCode,phoneNumber,temporaryProof}):null}}exports.J=PhoneAuthCredential;class ActionCodeURL{constructor(actionLink){var _a,_b,_c,_d,_e,_f;actionLink=(0,_util.querystringDecode)((0,_util.extractQuerystring)(actionLink));const apiKey=null!==(_a=actionLink.apiKey)&&void 0!==_a?
_a:null;_a=null!==(_b=actionLink.oobCode)&&void 0!==_b?_b:null;_b=parseMode(null!==(_c=actionLink.mode)&&void 0!==_c?_c:null);_assert(apiKey&&_a&&_b,"argument-error");this.apiKey=apiKey;this.operation=_b;this.code=_a;this.continueUrl=null!==(_d=actionLink.continueUrl)&&void 0!==_d?_d:null;this.languageCode=null!==(_e=actionLink.languageCode)&&void 0!==_e?_e:null;this.tenantId=null!==(_f=actionLink.tenantId)&&void 0!==_f?_f:null}static parseLink(link$jscomp$0){const link=(0,_util.querystringDecode)((0,_util.extractQuerystring)(link$jscomp$0)).link,
doubleDeepLink=link?(0,_util.querystringDecode)((0,_util.extractQuerystring)(link)).deep_link_id:null,iOSDeepLink=(0,_util.querystringDecode)((0,_util.extractQuerystring)(link$jscomp$0)).deep_link_id;link$jscomp$0=(iOSDeepLink?(0,_util.querystringDecode)((0,_util.extractQuerystring)(iOSDeepLink)).link:null)||iOSDeepLink||doubleDeepLink||link||link$jscomp$0;try{return new ActionCodeURL(link$jscomp$0)}catch(_a){return null}}}exports.ac=ActionCodeURL;class EmailAuthProvider{constructor(){this.providerId=
EmailAuthProvider.PROVIDER_ID}static credential(email,password){return EmailAuthCredential._fromEmailAndPassword(email,password)}static credentialWithLink(email,emailLink){emailLink=ActionCodeURL.parseLink(emailLink);_assert(emailLink,"argument-error");return EmailAuthCredential._fromEmailAndCode(email,emailLink.code,emailLink.tenantId)}}exports.L=EmailAuthProvider;EmailAuthProvider.PROVIDER_ID="password";EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD="password";EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD=
"emailLink";class FederatedAuthProvider{constructor(providerId){this.providerId=providerId;this.defaultLanguageCode=null;this.customParameters={}}setDefaultLanguage(languageCode){this.defaultLanguageCode=languageCode}setCustomParameters(customOAuthParameters){this.customParameters=customOAuthParameters;return this}getCustomParameters(){return this.customParameters}}class BaseOAuthProvider extends FederatedAuthProvider{constructor(){super(...arguments);this.scopes=[]}addScope(scope){this.scopes.includes(scope)||
this.scopes.push(scope);return this}getScopes(){return[...this.scopes]}}class OAuthProvider extends BaseOAuthProvider{static credentialFromJSON(json){json="string"===typeof json?JSON.parse(json):json;_assert("providerId"in json&&"signInMethod"in json,"argument-error");return OAuthCredential._fromParams(json)}credential(params){return this._credential(Object.assign(Object.assign({},params),{nonce:params.rawNonce}))}_credential(params){_assert(params.idToken||params.accessToken,"argument-error");return OAuthCredential._fromParams(Object.assign(Object.assign({},
params),{providerId:this.providerId,signInMethod:this.providerId}))}static credentialFromResult(userCredential){return OAuthProvider.oauthCredentialFromTaggedObject(userCredential)}static credentialFromError(error){return OAuthProvider.oauthCredentialFromTaggedObject(error.customData||{})}static oauthCredentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse)return null;const {oauthIdToken,oauthAccessToken,oauthTokenSecret,pendingToken,nonce,providerId}=tokenResponse;if(!(oauthAccessToken||
oauthTokenSecret||oauthIdToken||pendingToken)||!providerId)return null;try{return(new OAuthProvider(providerId))._credential({idToken:oauthIdToken,accessToken:oauthAccessToken,nonce,pendingToken})}catch(e){return null}}}exports.T=OAuthProvider;class FacebookAuthProvider extends BaseOAuthProvider{constructor(){super("facebook.com")}static credential(accessToken){return OAuthCredential._fromParams({providerId:FacebookAuthProvider.PROVIDER_ID,signInMethod:FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
accessToken})}static credentialFromResult(userCredential){return FacebookAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return FacebookAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!(tokenResponse&&"oauthAccessToken"in tokenResponse&&tokenResponse.oauthAccessToken))return null;try{return FacebookAuthProvider.credential(tokenResponse.oauthAccessToken)}catch(_a){return null}}}
exports.M=FacebookAuthProvider;FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD="facebook.com";FacebookAuthProvider.PROVIDER_ID="facebook.com";class GoogleAuthProvider extends BaseOAuthProvider{constructor(){super("google.com");this.addScope("profile")}static credential(idToken,accessToken){return OAuthCredential._fromParams({providerId:GoogleAuthProvider.PROVIDER_ID,signInMethod:GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,idToken,accessToken})}static credentialFromResult(userCredential){return GoogleAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return GoogleAuthProvider.credentialFromTaggedObject(error.customData||
{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse)return null;const {oauthIdToken,oauthAccessToken}=tokenResponse;if(!oauthIdToken&&!oauthAccessToken)return null;try{return GoogleAuthProvider.credential(oauthIdToken,oauthAccessToken)}catch(_a){return null}}}exports.N=GoogleAuthProvider;GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD="google.com";GoogleAuthProvider.PROVIDER_ID="google.com";class GithubAuthProvider extends BaseOAuthProvider{constructor(){super("github.com")}static credential(accessToken){return OAuthCredential._fromParams({providerId:GithubAuthProvider.PROVIDER_ID,
signInMethod:GithubAuthProvider.GITHUB_SIGN_IN_METHOD,accessToken})}static credentialFromResult(userCredential){return GithubAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return GithubAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!(tokenResponse&&"oauthAccessToken"in tokenResponse&&tokenResponse.oauthAccessToken))return null;try{return GithubAuthProvider.credential(tokenResponse.oauthAccessToken)}catch(_a){return null}}}
exports.Q=GithubAuthProvider;GithubAuthProvider.GITHUB_SIGN_IN_METHOD="github.com";GithubAuthProvider.PROVIDER_ID="github.com";class SAMLAuthCredential extends AuthCredential{constructor(providerId,pendingToken){super(providerId,providerId);this.pendingToken=pendingToken}_getIdTokenResponse(auth){const request=this.buildRequest();return signInWithIdp(auth,request)}_linkToIdToken(auth,idToken){const request=this.buildRequest();request.idToken=idToken;return signInWithIdp(auth,request)}_getReauthenticationResolver(auth){const request=
this.buildRequest();request.autoCreate=!1;return signInWithIdp(auth,request)}toJSON(){return{signInMethod:this.signInMethod,providerId:this.providerId,pendingToken:this.pendingToken}}static fromJSON(json){json="string"===typeof json?JSON.parse(json):json;const {providerId,signInMethod,pendingToken}=json;return providerId&&signInMethod&&pendingToken&&providerId===signInMethod?new SAMLAuthCredential(providerId,pendingToken):null}static _create(providerId,pendingToken){return new SAMLAuthCredential(providerId,
pendingToken)}buildRequest(){return{requestUri:"http://localhost",returnSecureToken:!0,pendingToken:this.pendingToken}}}exports.aJ=SAMLAuthCredential;class SAMLAuthProvider extends FederatedAuthProvider{constructor(providerId){_assert(providerId.startsWith("saml."),"argument-error");super(providerId)}static credentialFromResult(userCredential){return SAMLAuthProvider.samlCredentialFromTaggedObject(userCredential)}static credentialFromError(error){return SAMLAuthProvider.samlCredentialFromTaggedObject(error.customData||
{})}static credentialFromJSON(json){json=SAMLAuthCredential.fromJSON(json);_assert(json,"argument-error");return json}static samlCredentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse)return null;const {pendingToken,providerId}=tokenResponse;if(!pendingToken||!providerId)return null;try{return SAMLAuthCredential._create(providerId,pendingToken)}catch(e){return null}}}exports.U=SAMLAuthProvider;class TwitterAuthProvider extends BaseOAuthProvider{constructor(){super("twitter.com")}static credential(token,
secret){return OAuthCredential._fromParams({providerId:TwitterAuthProvider.PROVIDER_ID,signInMethod:TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,oauthToken:token,oauthTokenSecret:secret})}static credentialFromResult(userCredential){return TwitterAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return TwitterAuthProvider.credentialFromTaggedObject(error.customData||{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse)return null;
const {oauthAccessToken,oauthTokenSecret}=tokenResponse;if(!oauthAccessToken||!oauthTokenSecret)return null;try{return TwitterAuthProvider.credential(oauthAccessToken,oauthTokenSecret)}catch(_a){return null}}}exports.V=TwitterAuthProvider;TwitterAuthProvider.TWITTER_SIGN_IN_METHOD="twitter.com";TwitterAuthProvider.PROVIDER_ID="twitter.com";class UserCredentialImpl{constructor(params){this.user=params.user;this.providerId=params.providerId;this._tokenResponse=params._tokenResponse;this.operationType=
params.operationType}static _fromIdTokenResponse(auth,operationType,idTokenResponse,isAnonymous=!1){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const user=yield UserImpl._fromIdTokenResponse(auth,idTokenResponse,isAnonymous),providerId=providerIdForResponse(idTokenResponse);return new UserCredentialImpl({user,providerId,_tokenResponse:idTokenResponse,operationType})})}static _forOperation(user,operationType,response){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield user._updateTokensIfNecessary(response,
!0);const providerId=providerIdForResponse(response);return new UserCredentialImpl({user,providerId,_tokenResponse:response,operationType})})}}class MultiFactorError extends _util.FirebaseError{constructor(auth,error,operationType,user){var _a;super(error.code,error.message);this.operationType=operationType;this.user=user;Object.setPrototypeOf(this,MultiFactorError.prototype);this.customData={appName:auth.name,tenantId:null!==(_a=auth.tenantId)&&void 0!==_a?_a:void 0,_serverResponse:error.customData._serverResponse,
operationType}}static _fromErrorAndOperation(auth,error,operationType,user){return new MultiFactorError(auth,error,operationType,user)}}class MultiFactorInfoImpl{constructor(factorId,response){this.factorId=factorId;this.uid=response.mfaEnrollmentId;this.enrollmentTime=(new Date(response.enrolledAt)).toUTCString();this.displayName=response.displayName}static _fromServerResponse(auth,enrollment){return"phoneInfo"in enrollment?PhoneMultiFactorInfoImpl._fromServerResponse(auth,enrollment):_fail(auth,
"internal-error")}}class PhoneMultiFactorInfoImpl extends MultiFactorInfoImpl{constructor(response){super("phone",response);this.phoneNumber=response.phoneInfo}static _fromServerResponse(_auth,enrollment){return new PhoneMultiFactorInfoImpl(enrollment)}}class GenericAdditionalUserInfo{constructor(isNewUser,providerId,profile={}){this.isNewUser=isNewUser;this.providerId=providerId;this.profile=profile}}class FederatedAdditionalUserInfoWithUsername extends GenericAdditionalUserInfo{constructor(isNewUser,
providerId,profile,username){super(isNewUser,providerId,profile);this.username=username}}class FacebookAdditionalUserInfo extends GenericAdditionalUserInfo{constructor(isNewUser,profile){super(isNewUser,"facebook.com",profile)}}class GithubAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername{constructor(isNewUser,profile){super(isNewUser,"github.com",profile,"string"===typeof(null===profile||void 0===profile?void 0:profile.login)?null===profile||void 0===profile?void 0:profile.login:
null)}}class GoogleAdditionalUserInfo extends GenericAdditionalUserInfo{constructor(isNewUser,profile){super(isNewUser,"google.com",profile)}}class TwitterAdditionalUserInfo extends FederatedAdditionalUserInfoWithUsername{constructor(isNewUser,profile,screenName){super(isNewUser,"twitter.com",profile,screenName)}}class MultiFactorSessionImpl{constructor(type,credential){this.type=type;this.credential=credential}static _fromIdtoken(idToken){return new MultiFactorSessionImpl("enroll",idToken)}static _fromMfaPendingCredential(mfaPendingCredential){return new MultiFactorSessionImpl("signin",
mfaPendingCredential)}toJSON(){return{multiFactorSession:{["enroll"===this.type?"idToken":"pendingCredential"]:this.credential}}}static fromJSON(obj){var _a,_b;if(null===obj||void 0===obj?0:obj.multiFactorSession){if(null===(_a=obj.multiFactorSession)||void 0===_a?0:_a.pendingCredential)return MultiFactorSessionImpl._fromMfaPendingCredential(obj.multiFactorSession.pendingCredential);if(null===(_b=obj.multiFactorSession)||void 0===_b?0:_b.idToken)return MultiFactorSessionImpl._fromIdtoken(obj.multiFactorSession.idToken)}return null}}
class MultiFactorResolverImpl{constructor(session,hints,signInResolver){this.session=session;this.hints=hints;this.signInResolver=signInResolver}static _fromError(authExtern,error){const auth=_castAuth(authExtern),serverResponse=error.customData._serverResponse;authExtern=(serverResponse.mfaInfo||[]).map(enrollment=>MultiFactorInfoImpl._fromServerResponse(auth,enrollment));_assert(serverResponse.mfaPendingCredential,auth,"internal-error");const session=MultiFactorSessionImpl._fromMfaPendingCredential(serverResponse.mfaPendingCredential);
return new MultiFactorResolverImpl(session,authExtern,assertion=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){var mfaResponse=yield assertion._process(auth,session);delete serverResponse.mfaInfo;delete serverResponse.mfaPendingCredential;mfaResponse=Object.assign(Object.assign({},serverResponse),{idToken:mfaResponse.idToken,refreshToken:mfaResponse.refreshToken});switch(error.operationType){case "signIn":return mfaResponse=yield UserCredentialImpl._fromIdTokenResponse(auth,error.operationType,
mfaResponse),yield auth._updateCurrentUser(mfaResponse.user),mfaResponse;case "reauthenticate":return _assert(error.user,auth,"internal-error"),UserCredentialImpl._forOperation(error.user,error.operationType,mfaResponse);default:_fail(auth,"internal-error")}}))}resolveSignIn(assertionExtern){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return $jscomp$async$this.signInResolver(assertionExtern)})}}class MultiFactorUserImpl{constructor(user){this.user=
user;this.enrolledFactors=[];user._onReload(userInfo=>{userInfo.mfaInfo&&(this.enrolledFactors=userInfo.mfaInfo.map(enrollment=>MultiFactorInfoImpl._fromServerResponse(user.auth,enrollment)))})}static _fromUser(user){return new MultiFactorUserImpl(user)}getSession(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return MultiFactorSessionImpl._fromIdtoken(yield $jscomp$async$this.user.getIdToken())})}enroll(assertionExtern,displayName){const $jscomp$async$this=
this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var session=yield $jscomp$async$this.getSession();session=yield _logoutIfInvalidated($jscomp$async$this.user,assertionExtern._process($jscomp$async$this.user.auth,session,displayName));yield $jscomp$async$this.user._updateTokensIfNecessary(session);return $jscomp$async$this.user.reload()})}unenroll(infoOrUid){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const mfaEnrollmentId="string"===
typeof infoOrUid?infoOrUid:infoOrUid.uid;var idToken=yield $jscomp$async$this.user.getIdToken();idToken=yield _logoutIfInvalidated($jscomp$async$this.user,withdrawMfa($jscomp$async$this.user.auth,{idToken,mfaEnrollmentId}));$jscomp$async$this.enrolledFactors=$jscomp$async$this.enrolledFactors.filter(({uid})=>uid!==mfaEnrollmentId);yield $jscomp$async$this.user._updateTokensIfNecessary(idToken);try{yield $jscomp$async$this.user.reload()}catch(e){if("auth/user-token-expired"!==e.code)throw e;}})}}const multiFactorUserCache=
new WeakMap;class BrowserPersistenceClass{constructor(storageRetriever,type){this.storageRetriever=storageRetriever;this.type=type}_isAvailable(){try{if(!this.storage)return Promise.resolve(!1);this.storage.setItem("__sak","1");this.storage.removeItem("__sak");return Promise.resolve(!0)}catch(_a){return Promise.resolve(!1)}}_set(key,value){this.storage.setItem(key,JSON.stringify(value));return Promise.resolve()}_get(key){key=this.storage.getItem(key);return Promise.resolve(key?JSON.parse(key):null)}_remove(key){this.storage.removeItem(key);
return Promise.resolve()}get storage(){return this.storageRetriever()}}class BrowserLocalPersistence extends BrowserPersistenceClass{constructor(){super(()=>window.localStorage,"LOCAL");this.boundEventHandler=(event,poll)=>this.onStorageEvent(event,poll);this.listeners={};this.localCache={};this.pollTimer=null;var JSCompiler_temp;if(JSCompiler_temp=_iframeCannotSyncWebStorage())try{JSCompiler_temp=!(!window||window===window.top)}catch(e){JSCompiler_temp=!1}this.safariLocalStorageNotSynced=JSCompiler_temp;
this.fallbackToPolling=_isMobileBrowser();this._shouldAllowMigration=!0}forAllChangedKeys(cb){for(const key of Object.keys(this.listeners)){const newValue=this.storage.getItem(key),oldValue=this.localCache[key];newValue!==oldValue&&cb(key,oldValue,newValue)}}onStorageEvent(event,poll=!1){if(event.key){var key$jscomp$0=event.key;poll?this.detachListener():this.stopPolling();if(this.safariLocalStorageNotSynced){var storedValue$jscomp$0=this.storage.getItem(key$jscomp$0);if(event.newValue!==storedValue$jscomp$0)null!==
event.newValue?this.storage.setItem(key$jscomp$0,event.newValue):this.storage.removeItem(key$jscomp$0);else if(this.localCache[key$jscomp$0]===event.newValue&&!poll)return}storedValue$jscomp$0=()=>{const storedValue=this.storage.getItem(key$jscomp$0);(poll||this.localCache[key$jscomp$0]!==storedValue)&&this.notifyListeners(key$jscomp$0,storedValue)};var storedValue=this.storage.getItem(key$jscomp$0);(0,_util.isIE)()&&10===document.documentMode&&storedValue!==event.newValue&&event.newValue!==event.oldValue?
setTimeout(storedValue$jscomp$0,10):storedValue$jscomp$0()}else this.forAllChangedKeys((key,_oldValue,newValue)=>{this.notifyListeners(key,newValue)})}notifyListeners(key,value){this.localCache[key]=value;if(key=this.listeners[key])for(const listener of Array.from(key))listener(value?JSON.parse(value):value)}startPolling(){this.stopPolling();this.pollTimer=setInterval(()=>{this.forAllChangedKeys((key,oldValue,newValue)=>{this.onStorageEvent(new StorageEvent("storage",{key,oldValue,newValue}),!0)})},
1E3)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}attachListener(){window.addEventListener("storage",this.boundEventHandler)}detachListener(){window.removeEventListener("storage",this.boundEventHandler)}_addListener(key,listener){0===Object.keys(this.listeners).length&&(this.fallbackToPolling?this.startPolling():this.attachListener());this.listeners[key]||(this.listeners[key]=new Set,this.localCache[key]=this.storage.getItem(key));this.listeners[key].add(listener)}_removeListener(key,
listener){this.listeners[key]&&(this.listeners[key].delete(listener),0===this.listeners[key].size&&delete this.listeners[key]);0===Object.keys(this.listeners).length&&(this.detachListener(),this.stopPolling())}_set(key,value){const $jscomp$async$this=this,$jscomp$async$super$get$_set=()=>super._set;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$super$get$_set().call($jscomp$async$this,key,value);$jscomp$async$this.localCache[key]=JSON.stringify(value)})}_get(key){const $jscomp$async$this=
this,$jscomp$async$super$get$_get=()=>super._get;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const value=yield $jscomp$async$super$get$_get().call($jscomp$async$this,key);$jscomp$async$this.localCache[key]=JSON.stringify(value);return value})}_remove(key){const $jscomp$async$this=this,$jscomp$async$super$get$_remove=()=>super._remove;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$super$get$_remove().call($jscomp$async$this,key);delete $jscomp$async$this.localCache[key]})}}
BrowserLocalPersistence.type="LOCAL";const browserLocalPersistence=BrowserLocalPersistence;exports.b=browserLocalPersistence;class BrowserSessionPersistence extends BrowserPersistenceClass{constructor(){super(()=>window.sessionStorage,"SESSION")}_addListener(_key,_listener){}_removeListener(_key,_listener){}}BrowserSessionPersistence.type="SESSION";const browserSessionPersistence=BrowserSessionPersistence;exports.a=browserSessionPersistence;class Receiver{constructor(eventTarget){this.eventTarget=
eventTarget;this.handlersMap={};this.boundEventHandler=this.handleEvent.bind(this)}static _getInstance(eventTarget){var existingInstance=this.receivers.find(receiver=>receiver.isListeningto(eventTarget));if(existingInstance)return existingInstance;existingInstance=new Receiver(eventTarget);this.receivers.push(existingInstance);return existingInstance}isListeningto(eventTarget){return this.eventTarget===eventTarget}handleEvent(event){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {eventId,
eventType,data}=event.data;var handlers=$jscomp$async$this.handlersMap[eventType];null!==handlers&&void 0!==handlers&&handlers.size&&(event.ports[0].postMessage({status:"ack",eventId,eventType}),handlers=Array.from(handlers).map(handler=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){return handler(event.origin,data)})),handlers=yield _allSettled(handlers),event.ports[0].postMessage({status:"done",eventId,eventType,response:handlers}))})}_subscribe(eventType,eventHandler){0===Object.keys(this.handlersMap).length&&
this.eventTarget.addEventListener("message",this.boundEventHandler);this.handlersMap[eventType]||(this.handlersMap[eventType]=new Set);this.handlersMap[eventType].add(eventHandler)}_unsubscribe(eventType,eventHandler){this.handlersMap[eventType]&&eventHandler&&this.handlersMap[eventType].delete(eventHandler);eventHandler&&0!==this.handlersMap[eventType].size||delete this.handlersMap[eventType];0===Object.keys(this.handlersMap).length&&this.eventTarget.removeEventListener("message",this.boundEventHandler)}}
Receiver.receivers=[];class Sender{constructor(target){this.target=target;this.handlers=new Set}removeMessageHandler(handler){handler.messageChannel&&(handler.messageChannel.port1.removeEventListener("message",handler.onMessage),handler.messageChannel.port1.close());this.handlers.delete(handler)}_send(eventType,data,timeout=50){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const messageChannel="undefined"!==typeof MessageChannel?new MessageChannel:null;
if(!messageChannel)throw Error("connection_unavailable");let completionTimer,handler;return(new Promise((resolve,reject)=>{const eventId=_generateEventId("",20);messageChannel.port1.start();const ackTimer=setTimeout(()=>{reject(Error("unsupported_event"))},timeout);handler={messageChannel,onMessage(event){if(event.data.eventId===eventId)switch(event.data.status){case "ack":clearTimeout(ackTimer);completionTimer=setTimeout(()=>{reject(Error("timeout"))},3E3);break;case "done":clearTimeout(completionTimer);
resolve(event.data.response);break;default:clearTimeout(ackTimer),clearTimeout(completionTimer),reject(Error("invalid_response"))}}};$jscomp$async$this.handlers.add(handler);messageChannel.port1.addEventListener("message",handler.onMessage);$jscomp$async$this.target.postMessage({eventType,eventId,data},[messageChannel.port2])})).finally(()=>{handler&&$jscomp$async$this.removeMessageHandler(handler)})})}}class DBPromise{constructor(request){this.request=request}toPromise(){return new Promise((resolve,
reject)=>{this.request.addEventListener("success",()=>{resolve(this.request.result)});this.request.addEventListener("error",()=>{reject(this.request.error)})})}}class IndexedDBLocalPersistence{constructor(){this.type="LOCAL";this._shouldAllowMigration=!0;this.listeners={};this.localCache={};this.pollTimer=null;this.pendingWrites=0;this.sender=this.receiver=null;this.serviceWorkerReceiverAvailable=!1;this.activeServiceWorker=null;this._workerInitializationPromise=this.initializeServiceWorkerMessaging().then(()=>
{},()=>{})}_openDb(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if($jscomp$async$this.db)return $jscomp$async$this.db;$jscomp$async$this.db=yield _openDatabase();return $jscomp$async$this.db})}_withRetries(op){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){let numAttempts=0;for(;;)try{const db=yield $jscomp$async$this._openDb();return yield op(db)}catch(e){if(3<numAttempts++)throw e;$jscomp$async$this.db&&
($jscomp$async$this.db.close(),$jscomp$async$this.db=void 0)}})}initializeServiceWorkerMessaging(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return _isWorker()?$jscomp$async$this.initializeReceiver():$jscomp$async$this.initializeSender()})}initializeReceiver(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.receiver=Receiver._getInstance(_isWorker()?self:null);$jscomp$async$this.receiver._subscribe("keyChanged",
(_origin,data)=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){return{keyProcessed:(yield $jscomp$async$this._poll()).includes(data.key)}}));$jscomp$async$this.receiver._subscribe("ping",(_origin,_data)=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){return["keyChanged"]}))})}initializeSender(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a,_b;$jscomp$async$this.activeServiceWorker=yield _getActiveServiceWorker();if($jscomp$async$this.activeServiceWorker){$jscomp$async$this.sender=
new Sender($jscomp$async$this.activeServiceWorker);var results=yield $jscomp$async$this.sender._send("ping",{},800);results&&(null===(_a=results[0])||void 0===_a?0:_a.fulfilled)&&(null===(_b=results[0])||void 0===_b?0:_b.value.includes("keyChanged"))&&($jscomp$async$this.serviceWorkerReceiverAvailable=!0)}})}notifyServiceWorker(key){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var JSCompiler_temp;if(!(JSCompiler_temp=!$jscomp$async$this.sender||!$jscomp$async$this.activeServiceWorker)){var _a$jscomp$0;
JSCompiler_temp=((null===(_a$jscomp$0=null===navigator||void 0===navigator?void 0:navigator.serviceWorker)||void 0===_a$jscomp$0?void 0:_a$jscomp$0.controller)||null)!==$jscomp$async$this.activeServiceWorker}if(!JSCompiler_temp)try{yield $jscomp$async$this.sender._send("keyChanged",{key},$jscomp$async$this.serviceWorkerReceiverAvailable?800:50)}catch(_a){}})}_isAvailable(){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){try{if(!indexedDB)return!1;const db=yield _openDatabase();yield _putObject(db,
"__sak","1");yield _deleteObject(db,"__sak");return!0}catch(_a){}return!1})}_withPendingWrite(write){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.pendingWrites++;try{yield write()}finally{$jscomp$async$this.pendingWrites--}})}_set(key,value){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return $jscomp$async$this._withPendingWrite(()=>$jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this._withRetries(db=>
_putObject(db,key,value));$jscomp$async$this.localCache[key]=value;return $jscomp$async$this.notifyServiceWorker(key)}))})}_get(key){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const obj=yield $jscomp$async$this._withRetries(db=>getObject(db,key));return $jscomp$async$this.localCache[key]=obj})}_remove(key){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return $jscomp$async$this._withPendingWrite(()=>
$jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this._withRetries(db=>_deleteObject(db,key));delete $jscomp$async$this.localCache[key];return $jscomp$async$this.notifyServiceWorker(key)}))})}_poll(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const result=yield $jscomp$async$this._withRetries(db=>{db=getObjectStore(db,!1).getAll();return(new DBPromise(db)).toPromise()});if(!result||0!==$jscomp$async$this.pendingWrites)return[];
const keys=[],keysInResult=new Set;for(const {fbase_key:key,value}of result)keysInResult.add(key),JSON.stringify($jscomp$async$this.localCache[key])!==JSON.stringify(value)&&($jscomp$async$this.notifyListeners(key,value),keys.push(key));for(const localKey of Object.keys($jscomp$async$this.localCache))$jscomp$async$this.localCache[localKey]&&!keysInResult.has(localKey)&&($jscomp$async$this.notifyListeners(localKey,null),keys.push(localKey));return keys})}notifyListeners(key,newValue){this.localCache[key]=
newValue;if(key=this.listeners[key])for(const listener of Array.from(key))listener(newValue)}startPolling(){this.stopPolling();this.pollTimer=setInterval(()=>{const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return $jscomp$async$this._poll()})},800)}stopPolling(){this.pollTimer&&(clearInterval(this.pollTimer),this.pollTimer=null)}_addListener(key,listener){0===Object.keys(this.listeners).length&&this.startPolling();this.listeners[key]||(this.listeners[key]=
new Set,void this._get(key));this.listeners[key].add(listener)}_removeListener(key,listener){this.listeners[key]&&(this.listeners[key].delete(listener),0===this.listeners[key].size&&delete this.listeners[key]);0===Object.keys(this.listeners).length&&this.stopPolling()}}IndexedDBLocalPersistence.type="LOCAL";const indexedDBLocalPersistence=IndexedDBLocalPersistence;exports.i=indexedDBLocalPersistence;class MockReCaptcha{constructor(auth){this.auth=auth;this.counter=1E12;this._widgets=new Map}render(container,
parameters){const id=this.counter;this._widgets.set(id,new MockWidget(container,this.auth.name,parameters||{}));this.counter++;return id}reset(optWidgetId){var _a;optWidgetId=optWidgetId||1E12;void(null===(_a=this._widgets.get(optWidgetId))||void 0===_a?void 0:_a.delete());this._widgets.delete(optWidgetId)}getResponse(optWidgetId){var _a;return(null===(_a=this._widgets.get(optWidgetId||1E12))||void 0===_a?void 0:_a.getResponse())||""}execute(optWidgetId){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;
void(null===(_a=$jscomp$async$this._widgets.get(optWidgetId||1E12))||void 0===_a?void 0:_a.execute());return""})}}class MockWidget{constructor(containerOrId,appName,params){this.params=params;this.timerId=null;this.deleted=!1;this.responseToken=null;this.clickHandler=()=>{this.execute()};containerOrId="string"===typeof containerOrId?document.getElementById(containerOrId):containerOrId;_assert(containerOrId,"argument-error",{appName});this.container=containerOrId;(this.isVisible="invisible"!==this.params.size)?
this.execute():this.container.addEventListener("click",this.clickHandler)}getResponse(){this.checkIfDeleted();return this.responseToken}delete(){this.checkIfDeleted();this.deleted=!0;this.timerId&&(clearTimeout(this.timerId),this.timerId=null);this.container.removeEventListener("click",this.clickHandler)}execute(){this.checkIfDeleted();this.timerId||(this.timerId=window.setTimeout(()=>{this.responseToken=generateRandomAlphaNumericString(50);const {callback,"expired-callback":expiredCallback}=this.params;
if(callback)try{callback(this.responseToken)}catch(e){}this.timerId=window.setTimeout(()=>{this.responseToken=this.timerId=null;if(expiredCallback)try{expiredCallback()}catch(e){}this.isVisible&&this.execute()},6E4)},500))}checkIfDeleted(){if(this.deleted)throw Error("reCAPTCHA mock was already deleted!");}}const _JSLOAD_CALLBACK=`__${"rcb"}${Math.floor(1E6*Math.random())}`,NETWORK_TIMEOUT_DELAY=new Delay(3E4,6E4);class ReCaptchaLoaderImpl{constructor(){this.hostLanguage="";this.counter=0;this.librarySeparatelyLoaded=
!!window.grecaptcha}load(auth,hl=""){_assert(6>=hl.length&&/^\s*[a-zA-Z0-9\-]*\s*$/.test(hl),auth,"argument-error");return this.shouldResolveImmediately(hl)?Promise.resolve(window.grecaptcha):new Promise((resolve,reject)=>{const networkTimeout=window.setTimeout(()=>{reject(_createError(auth,"network-request-failed"))},NETWORK_TIMEOUT_DELAY.get());window[_JSLOAD_CALLBACK]=()=>{window.clearTimeout(networkTimeout);delete window[_JSLOAD_CALLBACK];const recaptcha=window.grecaptcha;if(recaptcha){var render=
recaptcha.render;recaptcha.render=(container,params)=>{container=render(container,params);this.counter++;return container};this.hostLanguage=hl;resolve(recaptcha)}else reject(_createError(auth,"internal-error"))};const url=`${"https://www.google.com/recaptcha/api.js?"}?${(0,_util.querystring)({onload:_JSLOAD_CALLBACK,render:"explicit",hl})}`;_loadJS(url).catch(()=>{clearTimeout(networkTimeout);reject(_createError(auth,"internal-error"))})})}clearedOneInstance(){this.counter--}shouldResolveImmediately(hl){return!!window.grecaptcha&&
(hl===this.hostLanguage||0<this.counter||this.librarySeparatelyLoaded)}}class MockReCaptchaLoaderImpl{load(auth){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){return new MockReCaptcha(auth)})}clearedOneInstance(){}}const DEFAULT_PARAMS={theme:"light",type:"image"};class RecaptchaVerifier{constructor(containerOrId,parameters=Object.assign({},DEFAULT_PARAMS),authExtern){this.parameters=parameters;this.type="recaptcha";this.destroyed=!1;this.widgetId=null;this.tokenChangeListeners=
new Set;this.recaptcha=this.renderPromise=null;this.auth=_castAuth(authExtern);this.isInvisible="invisible"===this.parameters.size;_assert("undefined"!==typeof document,this.auth,"operation-not-supported-in-this-environment");containerOrId="string"===typeof containerOrId?document.getElementById(containerOrId):containerOrId;_assert(containerOrId,this.auth,"argument-error");this.container=containerOrId;this.parameters.callback=this.makeTokenCallback(this.parameters.callback);this._recaptchaLoader=this.auth.settings.appVerificationDisabledForTesting?
new MockReCaptchaLoaderImpl:new ReCaptchaLoaderImpl;this.validateStartingState()}verify(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.assertNotDestroyed();const id=yield $jscomp$async$this.render(),recaptcha=$jscomp$async$this.getAssertedRecaptcha(),response=recaptcha.getResponse(id);return response?response:new Promise(resolve=>{const tokenChange=token=>{token&&($jscomp$async$this.tokenChangeListeners.delete(tokenChange),resolve(token))};
$jscomp$async$this.tokenChangeListeners.add(tokenChange);$jscomp$async$this.isInvisible&&recaptcha.execute(id)})})}render(){try{this.assertNotDestroyed()}catch(e){return Promise.reject(e)}return this.renderPromise?this.renderPromise:this.renderPromise=this.makeRenderPromise().catch(e=>{this.renderPromise=null;throw e;})}_reset(){this.assertNotDestroyed();null!==this.widgetId&&this.getAssertedRecaptcha().reset(this.widgetId)}clear(){this.assertNotDestroyed();this.destroyed=!0;this._recaptchaLoader.clearedOneInstance();
this.isInvisible||this.container.childNodes.forEach(node=>{this.container.removeChild(node)})}validateStartingState(){_assert(!this.parameters.sitekey,this.auth,"argument-error");_assert(this.isInvisible||!this.container.hasChildNodes(),this.auth,"argument-error");_assert("undefined"!==typeof document,this.auth,"operation-not-supported-in-this-environment")}makeTokenCallback(existing){return token=>{this.tokenChangeListeners.forEach(listener=>listener(token));if("function"===typeof existing)existing(token);
else if("string"===typeof existing){const globalFunc=window[existing];"function"===typeof globalFunc&&globalFunc(token)}}}assertNotDestroyed(){_assert(!this.destroyed,this.auth,"internal-error")}makeRenderPromise(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this.init();if(!$jscomp$async$this.widgetId){let container=$jscomp$async$this.container;if(!$jscomp$async$this.isInvisible){const guaranteedEmpty=document.createElement("div");
container.appendChild(guaranteedEmpty);container=guaranteedEmpty}$jscomp$async$this.widgetId=$jscomp$async$this.getAssertedRecaptcha().render(container,$jscomp$async$this.parameters)}return $jscomp$async$this.widgetId})}init(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){_assert(_isHttpOrHttps()&&!_isWorker(),$jscomp$async$this.auth,"internal-error");yield domReady();$jscomp$async$this.recaptcha=yield $jscomp$async$this._recaptchaLoader.load($jscomp$async$this.auth,
$jscomp$async$this.auth.languageCode||void 0);const siteKey=yield getRecaptchaParams($jscomp$async$this.auth);_assert(siteKey,$jscomp$async$this.auth,"internal-error");$jscomp$async$this.parameters.sitekey=siteKey})}getAssertedRecaptcha(){_assert(this.recaptcha,this.auth,"internal-error");return this.recaptcha}}exports.R=RecaptchaVerifier;class ConfirmationResultImpl{constructor(verificationId,onConfirmation){this.verificationId=verificationId;this.onConfirmation=onConfirmation}confirm(verificationCode){verificationCode=
PhoneAuthCredential._fromVerification(this.verificationId,verificationCode);return this.onConfirmation(verificationCode)}}class PhoneAuthProvider{constructor(auth){this.providerId=PhoneAuthProvider.PROVIDER_ID;this.auth=_castAuth(auth)}verifyPhoneNumber(phoneOptions,applicationVerifier){return _verifyPhoneNumber(this.auth,phoneOptions,(0,_util.getModularInstance)(applicationVerifier))}static credential(verificationId,verificationCode){return PhoneAuthCredential._fromVerification(verificationId,verificationCode)}static credentialFromResult(userCredential){return PhoneAuthProvider.credentialFromTaggedObject(userCredential)}static credentialFromError(error){return PhoneAuthProvider.credentialFromTaggedObject(error.customData||
{})}static credentialFromTaggedObject({_tokenResponse:tokenResponse}){if(!tokenResponse)return null;const {phoneNumber,temporaryProof}=tokenResponse;return phoneNumber&&temporaryProof?PhoneAuthCredential._fromTokenResponse(phoneNumber,temporaryProof):null}}exports.P=PhoneAuthProvider;PhoneAuthProvider.PROVIDER_ID="phone";PhoneAuthProvider.PHONE_SIGN_IN_METHOD="phone";class IdpCredential extends AuthCredential{constructor(params){super("custom","custom");this.params=params}_getIdTokenResponse(auth){return signInWithIdp(auth,
this._buildIdpRequest())}_linkToIdToken(auth,idToken){return signInWithIdp(auth,this._buildIdpRequest(idToken))}_getReauthenticationResolver(auth){return signInWithIdp(auth,this._buildIdpRequest())}_buildIdpRequest(idToken){const request={requestUri:this.params.requestUri,sessionId:this.params.sessionId,postBody:this.params.postBody,tenantId:this.params.tenantId,pendingToken:this.params.pendingToken,returnSecureToken:!0,returnIdpCredential:!0};idToken&&(request.idToken=idToken);return request}}class AbstractPopupRedirectOperation{constructor(auth,
filter,resolver,user,bypassAuthState=!1){this.auth=auth;this.resolver=resolver;this.user=user;this.bypassAuthState=bypassAuthState;this.eventManager=this.pendingPromise=null;this.filter=Array.isArray(filter)?filter:[filter]}execute(){return new Promise((resolve,reject)=>{const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.pendingPromise={resolve,reject};try{$jscomp$async$this.eventManager=yield $jscomp$async$this.resolver._initialize($jscomp$async$this.auth),
yield $jscomp$async$this.onExecution(),$jscomp$async$this.eventManager.registerConsumer($jscomp$async$this)}catch(e){$jscomp$async$this.reject(e)}})})}onAuthEvent(event){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const {urlResponse,sessionId,postBody,tenantId,error,type}=event;if(error)$jscomp$async$this.reject(error);else{var params={auth:$jscomp$async$this.auth,requestUri:urlResponse,sessionId,tenantId:tenantId||void 0,postBody:postBody||void 0,
user:$jscomp$async$this.user,bypassAuthState:$jscomp$async$this.bypassAuthState};try{$jscomp$async$this.resolve(yield $jscomp$async$this.getIdpTask(type)(params))}catch(e){$jscomp$async$this.reject(e)}}})}onError(error){this.reject(error)}getIdpTask(type){switch(type){case "signInViaPopup":case "signInViaRedirect":return _signIn;case "linkViaPopup":case "linkViaRedirect":return _link;case "reauthViaPopup":case "reauthViaRedirect":return _reauth;default:_fail(this.auth,"internal-error")}}resolve(cred){debugAssert(this.pendingPromise,
"Pending promise was never set");this.pendingPromise.resolve(cred);this.unregisterAndCleanUp()}reject(error){debugAssert(this.pendingPromise,"Pending promise was never set");this.pendingPromise.reject(error);this.unregisterAndCleanUp()}unregisterAndCleanUp(){this.eventManager&&this.eventManager.unregisterConsumer(this);this.pendingPromise=null;this.cleanUp()}}const _POLL_WINDOW_CLOSE_TIMEOUT=new Delay(2E3,1E4);class PopupOperation extends AbstractPopupRedirectOperation{constructor(auth,filter,provider,
resolver,user){super(auth,filter,resolver,user);this.provider=provider;this.pollId=this.authWindow=null;PopupOperation.currentPopupAction&&PopupOperation.currentPopupAction.cancel();PopupOperation.currentPopupAction=this}executeNotNull(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const result=yield $jscomp$async$this.execute();_assert(result,$jscomp$async$this.auth,"internal-error");return result})}onExecution(){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){debugAssert(1===
$jscomp$async$this.filter.length,"Popup operations only handle one event");const eventId=_generateEventId();$jscomp$async$this.authWindow=yield $jscomp$async$this.resolver._openPopup($jscomp$async$this.auth,$jscomp$async$this.provider,$jscomp$async$this.filter[0],eventId);$jscomp$async$this.authWindow.associatedEvent=eventId;$jscomp$async$this.resolver._originValidation($jscomp$async$this.auth).catch(e=>{$jscomp$async$this.reject(e)});$jscomp$async$this.resolver._isIframeWebStorageSupported($jscomp$async$this.auth,
isSupported=>{isSupported||$jscomp$async$this.reject(_createError($jscomp$async$this.auth,"web-storage-unsupported"))});$jscomp$async$this.pollUserCancellation()})}get eventId(){var _a;return(null===(_a=this.authWindow)||void 0===_a?void 0:_a.associatedEvent)||null}cancel(){this.reject(_createError(this.auth,"cancelled-popup-request"))}cleanUp(){this.authWindow&&this.authWindow.close();this.pollId&&window.clearTimeout(this.pollId);this.pollId=this.authWindow=null;PopupOperation.currentPopupAction=
null}pollUserCancellation(){const poll=()=>{var _a,_b;(null===(_b=null===(_a=this.authWindow)||void 0===_a?void 0:_a.window)||void 0===_b?0:_b.closed)?this.pollId=window.setTimeout(()=>{this.pollId=null;this.reject(_createError(this.auth,"popup-closed-by-user"))},2E3):this.pollId=window.setTimeout(poll,_POLL_WINDOW_CLOSE_TIMEOUT.get())};poll()}}PopupOperation.currentPopupAction=null;const redirectOutcomeMap=new Map;class RedirectAction extends AbstractPopupRedirectOperation{constructor(auth,resolver,
bypassAuthState=!1){super(auth,["signInViaRedirect","linkViaRedirect","reauthViaRedirect","unknown"],resolver,void 0,bypassAuthState);this.eventId=null}execute(){const $jscomp$async$this=this,$jscomp$async$super$get$execute=()=>super.execute;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){let readyOutcome=redirectOutcomeMap.get($jscomp$async$this.auth._key());if(!readyOutcome){try{const result=(yield _getAndClearPendingRedirectStatus($jscomp$async$this.resolver,$jscomp$async$this.auth))?
yield $jscomp$async$super$get$execute().call($jscomp$async$this):null;readyOutcome=()=>Promise.resolve(result)}catch(e){readyOutcome=()=>Promise.reject(e)}redirectOutcomeMap.set($jscomp$async$this.auth._key(),readyOutcome)}$jscomp$async$this.bypassAuthState||redirectOutcomeMap.set($jscomp$async$this.auth._key(),()=>Promise.resolve(null));return readyOutcome()})}onAuthEvent(event){const $jscomp$async$this=this,$jscomp$async$super$get$onAuthEvent=()=>super.onAuthEvent;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if("signInViaRedirect"===
event.type)return $jscomp$async$super$get$onAuthEvent().call($jscomp$async$this,event);if("unknown"===event.type)$jscomp$async$this.resolve(null);else if(event.eventId){const user=yield $jscomp$async$this.auth._redirectUserForId(event.eventId);if(user)return $jscomp$async$this.user=user,$jscomp$async$super$get$onAuthEvent().call($jscomp$async$this,event);$jscomp$async$this.resolve(null)}})}onExecution(){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){})}cleanUp(){}}class AuthEventManager{constructor(auth){this.auth=
auth;this.cachedEventUids=new Set;this.consumers=new Set;this.queuedRedirectEvent=null;this.hasHandledPotentialRedirect=!1;this.lastProcessedEventTime=Date.now()}registerConsumer(authEventConsumer){this.consumers.add(authEventConsumer);this.queuedRedirectEvent&&this.isEventForConsumer(this.queuedRedirectEvent,authEventConsumer)&&(this.sendToConsumer(this.queuedRedirectEvent,authEventConsumer),this.saveEventToCache(this.queuedRedirectEvent),this.queuedRedirectEvent=null)}unregisterConsumer(authEventConsumer){this.consumers.delete(authEventConsumer)}onEvent(event){if(this.hasEventBeenHandled(event))return!1;
let handled=!1;this.consumers.forEach(consumer=>{this.isEventForConsumer(event,consumer)&&(handled=!0,this.sendToConsumer(event,consumer),this.saveEventToCache(event))});var JSCompiler_temp;if(!(JSCompiler_temp=this.hasHandledPotentialRedirect)){a:switch(event.type){case "signInViaRedirect":case "linkViaRedirect":case "reauthViaRedirect":JSCompiler_temp=!0;break a;case "unknown":JSCompiler_temp=isNullRedirectEvent(event);break a;default:JSCompiler_temp=!1}JSCompiler_temp=!JSCompiler_temp}if(JSCompiler_temp)return handled;
this.hasHandledPotentialRedirect=!0;handled||(this.queuedRedirectEvent=event,handled=!0);return handled}sendToConsumer(event,consumer){var _a;if(event.error&&!isNullRedirectEvent(event))event=(null===(_a=event.error.code)||void 0===_a?void 0:_a.split("auth/")[1])||"internal-error",consumer.onError(_createError(this.auth,event));else consumer.onAuthEvent(event)}isEventForConsumer(event,consumer){const eventIdMatches=null===consumer.eventId||!!event.eventId&&event.eventId===consumer.eventId;return consumer.filter.includes(event.type)&&
eventIdMatches}hasEventBeenHandled(event){6E5<=Date.now()-this.lastProcessedEventTime&&this.cachedEventUids.clear();return this.cachedEventUids.has(eventUid(event))}saveEventToCache(event){this.cachedEventUids.add(eventUid(event));this.lastProcessedEventTime=Date.now()}}exports.az=AuthEventManager;const IP_ADDRESS_REGEX=/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/,HTTP_REGEX=/^https?/,NETWORK_TIMEOUT=new Delay(3E4,6E4);let cachedGApiLoader=null;const PING_TIMEOUT=new Delay(5E3,15E3),IFRAME_ATTRIBUTES={style:{position:"absolute",
top:"-100px",width:"1px",height:"1px"},"aria-hidden":"true",tabindex:"-1"},EID_FROM_APIHOST=new Map([["identitytoolkit.googleapis.com","p"],["staging-identitytoolkit.sandbox.googleapis.com","s"],["test-identitytoolkit.sandbox.googleapis.com","t"]]),BASE_POPUP_OPTIONS={location:"yes",resizable:"yes",statusbar:"yes",toolbar:"no"};class AuthPopup{constructor(window){this.window=window;this.associatedEvent=null}close(){if(this.window)try{this.window.close()}catch(e){}}}exports.aH=AuthPopup;class BrowserPopupRedirectResolver{constructor(){this.eventManagers=
{};this.iframes={};this.originValidationPromises={};this._redirectPersistence=browserSessionPersistence;this._completeRedirectFn=_getRedirectResult}_openPopup(auth,provider,authType,eventId){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var _a;debugAssert(null===(_a=$jscomp$async$this.eventManagers[auth._key()])||void 0===_a?void 0:_a.manager,"_initialize() not called before _openPopup()");_a=_getRedirectUrl(auth,provider,authType,_getCurrentUrl(),eventId);
return _open(auth,_a,_generateEventId())})}_openRedirect(auth,provider,authType,eventId){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){yield $jscomp$async$this._originValidation(auth);window.location.href=_getRedirectUrl(auth,provider,authType,_getCurrentUrl(),eventId);return new Promise(()=>{})})}_initialize(auth){const key=auth._key();if(this.eventManagers[key]){const {manager,promise}=this.eventManagers[key];if(manager)return Promise.resolve(manager);
debugAssert(promise,"If manager is not set, promise should be");return promise}auth=this.initAndGetManager(auth);this.eventManagers[key]={promise:auth};auth.catch(()=>{delete this.eventManagers[key]});return auth}initAndGetManager(auth){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){const iframe=yield _openIframe(auth),manager=new AuthEventManager(auth);iframe.register("authEvent",iframeEvent=>{_assert(null===iframeEvent||void 0===iframeEvent?void 0:
iframeEvent.authEvent,auth,"invalid-auth-event");return{status:manager.onEvent(iframeEvent.authEvent)?"ACK":"ERROR"}},gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER);$jscomp$async$this.eventManagers[auth._key()]={manager};$jscomp$async$this.iframes[auth._key()]=iframe;return manager})}_isIframeWebStorageSupported(auth,cb){this.iframes[auth._key()].send("webStorageSupport",{type:"webStorageSupport"},result=>{var _a;result=null===(_a=null===result||void 0===result?void 0:result[0])||void 0===_a?void 0:_a.webStorageSupport;
void 0!==result&&cb(!!result);_fail(auth,"internal-error")},gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)}_originValidation(auth){const key=auth._key();this.originValidationPromises[key]||(this.originValidationPromises[key]=_validateOrigin(auth));return this.originValidationPromises[key]}get _shouldInitProactively(){return _isMobileBrowser()||_isSafari()||_isIOS()}}const browserPopupRedirectResolver=BrowserPopupRedirectResolver;exports.k=browserPopupRedirectResolver;class MultiFactorAssertionImpl{constructor(factorId){this.factorId=
factorId}_process(auth,session,displayName){switch(session.type){case "enroll":return this._finalizeEnroll(auth,session.credential,displayName);case "signin":return this._finalizeSignIn(auth,session.credential);default:return debugFail("unexpected MultiFactorSessionType")}}}class PhoneMultiFactorAssertionImpl extends MultiFactorAssertionImpl{constructor(credential){super("phone");this.credential=credential}static _fromCredential(credential){return new PhoneMultiFactorAssertionImpl(credential)}_finalizeEnroll(auth,
idToken,displayName){idToken={idToken,displayName,phoneVerificationInfo:this.credential._makeVerificationRequest()};return _performApiRequest(auth,"POST","/v2/accounts/mfaEnrollment:finalize",_addTidIfNecessary(auth,idToken))}_finalizeSignIn(auth,mfaPendingCredential){mfaPendingCredential={mfaPendingCredential,phoneVerificationInfo:this.credential._makeVerificationRequest()};return _performApiRequest(auth,"POST","/v2/accounts/mfaSignIn:finalize",_addTidIfNecessary(auth,mfaPendingCredential))}}class PhoneMultiFactorGenerator{constructor(){}static assertion(credential){return PhoneMultiFactorAssertionImpl._fromCredential(credential)}}
exports.m=PhoneMultiFactorGenerator;PhoneMultiFactorGenerator.FACTOR_ID="phone";class AuthInterop{constructor(auth){this.auth=auth;this.internalListeners=new Map}getUid(){var _a;this.assertAuthConfigured();return(null===(_a=this.auth.currentUser)||void 0===_a?void 0:_a.uid)||null}getToken(forceRefresh){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){$jscomp$async$this.assertAuthConfigured();yield $jscomp$async$this.auth._initializationPromise;return $jscomp$async$this.auth.currentUser?
{accessToken:yield $jscomp$async$this.auth.currentUser.getIdToken(forceRefresh)}:null})}addAuthTokenListener(listener){this.assertAuthConfigured();if(!this.internalListeners.has(listener)){var unsubscribe=this.auth.onIdTokenChanged(user=>{listener((null===user||void 0===user?void 0:user.stsTokenManager.accessToken)||null)});this.internalListeners.set(listener,unsubscribe);this.updateProactiveRefresh()}}removeAuthTokenListener(listener){this.assertAuthConfigured();const unsubscribe=this.internalListeners.get(listener);
unsubscribe&&(this.internalListeners.delete(listener),unsubscribe(),this.updateProactiveRefresh())}assertAuthConfigured(){_assert(this.auth._initializationPromise,"dependent-sdk-initialized-before-auth")}updateProactiveRefresh(){0<this.internalListeners.size?this.auth._startProactiveRefresh():this.auth._stopProactiveRefresh()}}(function(clientPlatform){(0,_app._registerComponent)((new _component.Component("auth",(container,{options:deps})=>{var app=container.getProvider("app").getImmediate();container=
container.getProvider("heartbeat");const {apiKey,authDomain}=app.options;_assert(apiKey&&!apiKey.includes(":"),"invalid-api-key",{appName:app.name});_assert(!(null===authDomain||void 0===authDomain?0:authDomain.includes(":")),"argument-error",{appName:app.name});const config={apiKey,authDomain,clientPlatform,apiHost:"identitytoolkit.googleapis.com",tokenApiHost:"securetoken.googleapis.com",apiScheme:"https",sdkClientVersion:_getClientVersion(clientPlatform)};app=new AuthImpl(app,container,config);
container=(null===deps||void 0===deps?void 0:deps.persistence)||[];container=(Array.isArray(container)?container:[container]).map(_getInstance);(null===deps||void 0===deps?0:deps.errorMap)&&app._updateErrorMap(deps.errorMap);app._initializeWithPersistence(container,null===deps||void 0===deps?void 0:deps.popupRedirectResolver);return app},"PUBLIC")).setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((container,_instanceIdentifier,_instance)=>{container.getProvider("auth-internal").initialize()}));
(0,_app._registerComponent)((new _component.Component("auth-internal",container=>{container=_castAuth(container.getProvider("auth").getImmediate());return new AuthInterop(container)},"PRIVATE")).setInstantiationMode("EXPLICIT"));(0,_app.registerVersion)("@firebase/auth","0.19.12",getVersionForPlatform(clientPlatform));(0,_app.registerVersion)("@firebase/auth","0.19.12","esm2017")})("Browser")}
//# sourceMappingURL=module$node_modules$$firebase$auth$dist$esm2017$index_7078a255.js.map
