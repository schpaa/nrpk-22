{"version":3,"sources":["lambdaisland/ornament.cljc"],"mappings":"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","names":["lambdaisland.ornament/*strip-prefixes*","lambdaisland$ornament$StyledComponent$classname$dyn","x__5390__auto__","m__5391__auto__","lambdaisland.ornament/classname","goog/typeOf","m__5389__auto__","cljs.core/missing-protocol","lambdaisland$ornament$StyledComponent$as_garden$dyn","lambdaisland.ornament/as-garden","lambdaisland$ornament$StyledComponent$css$dyn","lambdaisland.ornament/css","lambdaisland$ornament$StyledComponent$rules$dyn","lambdaisland.ornament/rules","lambdaisland$ornament$StyledComponent$tag$dyn","lambdaisland.ornament/tag","lambdaisland$ornament$StyledComponent$component$dyn","lambdaisland.ornament/component","lambdaisland$ornament$StyledComponent$as_hiccup$dyn","lambdaisland.ornament/as-hiccup","lambdaisland.ornament/StyledComponent","_","args","lambdaisland.ornament/add-class","classes","class","cljs.core._EQ_","cljs.core/meta","cljs.core/sequential?","cljs.core/seq","cljs.core/vec","cljs.core/cons","lambdaisland.ornament/expand-hiccup-tag","tag","css-class","component","attr-map?","cljs.core/map?","cljs.core/first","attrs","children","cljs.core/next","child","cljs.core.apply","G__74478","G__74479","G__74480","G__74481","cljs.core.into","or__5043__auto__","cljs.core/select-keys","cljs.core.update","lambdaisland.ornament/styled","varsym","rules","render-fn","x74527","cljs.core/PROTOCOL_SENTINEL","js/Object.defineProperty"],"sourcesContent":["(ns lambdaisland.ornament\n  \"CSS-in-clj(s)\"\n  (:require [clojure.string :as str]\n            #?@(:clj [[clojure.walk :as walk]\n                      [garden.compiler :as gc]\n                      [garden.core :as garden]\n                      [garden.color :as gcolor]\n                      [garden.types :as gt]\n                      [garden.stylesheet :as gs]\n                      [girouette.tw.core :as girouette]\n                      [girouette.tw.preflight :as girouette-preflight]\n                      [girouette.tw.typography :as girouette-typography]\n                      [girouette.tw.color :as girouette-color]\n                      [girouette.tw.default-api :as girouette-default]\n                      [meta-merge.core :as meta-merge]]))\n  #?(:cljs\n     (:require-macros [lambdaisland.ornament :refer [defstyled]])))\n\n#?(:clj\n   (defonce ^{:doc \"Registry of styles\n\n     Keys are fully qualified symbols (var names), values are maps with the\n     individual `:tag`, `:rules`, `:classname`. We add an `:index` to be able to\n     iterate over the components/styles in source order. This is now the\n     preferred way to iterate over all styles (as in [[defined-styles]]), rather\n     than the old approach of finding all vars with a given metadata attached to\n     them.\n\n     Clojure-only because we only deal with CSS on the backend, the frontend\n     only knows about classnames. `:component` points at a StyledComponent\n     instance that can be used to get the [[css]] for that component.\"}\n     registry\n     (atom {})))\n\n(def ^:dynamic *strip-prefixes*\n  \"Prefixes to be stripped from class names in generated CSS\"\n  nil)\n\n(defprotocol StyledComponent\n  (classname [_]\n    \"The CSS class name for this component, derived from the var and ns name.\")\n  (as-garden [_]\n    \"Return the styles for this component in Garden syntax (i.e. EDN data)\")\n  (css [_]\n    \"Compile this component's styles to CSS\")\n  (rules [_]\n    \"Get the rules passed to this component, without any processing.\")\n  (tag [_]\n    \"HTML tag (keyword) for this component\")\n  (component [_]\n    \"Function which is a Hiccup component, for styled components which have one or more function tails.\")\n  (as-hiccup [_ args]\n    \"Render to hiccup\"))\n\n(declare process-rule)\n\n#?(:clj\n   (do\n     (defonce ^{:doc \"Atom containing the return value\n       of [[girouette/make-api]], making it possible to swap this out for your\n       own Girouette instance. See also [[set-tokens!]] for a convenient API for\n       common use cases.\"}\n       girouette-api\n       (atom nil))\n\n     (def default-tokens\n       {:components girouette-default/default-components\n        :colors     girouette-color/default-color-map\n        :fonts      girouette-typography/default-font-family-map})\n\n     (defn set-tokens!\n       \"Set \\\"design tokens\\\": colors, fonts, and components\n\n        This configures Girouette, so that these tokens become available inside\n        Ornament style declarations.\n\n        - `:colors` : map from keyword to 6-digit hex color, without leading `#`\n        - `:fonts`: map from keyword to font stack (comman separated string)\n        - `:components`: sequence of Girouette components, each a map with\n          `:id` (keyword), `:rules` (string, instaparse, can be omitted), and\n          `:garden` (map, or function taking instaparse results and returning Garden\n          map)\n\n        If `:rules` is omitted we assume this is a static token, and we'll\n        generate a rule of the form `token-id = <'token-id'>`.\n\n        `:garden` can be a function, in which case it receives a map with a\n        `:compoent-data` key containing the instaparse parse tree. Literal maps or\n        vectors are wrapped in a function, in case the returned Garden is fixed. The\n        resulting Garden styles are processed again as in `defstyled`, so you can use\n        other Girouette or other tokens in there as well. Use `[:&]` for returning\n        multiple tokens/maps/stylesUse `[:&]` for returning multiple\n        tokens/maps/styles.\n\n        By default these are added to the Girouette defaults, use meta-merge\n        annotations (e.g. `{:colors ^:replace {...}}`) to change that behaviour.\"\n       [{:keys [components colors fonts]}]\n       (let [{:keys [components colors fonts]}\n             (meta-merge/meta-merge\n              default-tokens\n              {:components\n               (into (empty components)\n                     (map (fn [{:keys [id rules garden] :as c}]\n                            (cond-> c\n                              (not rules)\n                              (assoc :rules (str \"\\n\" (name id) \" = <'\" (name id) \"'>\" \"\\n\"))\n                              (not (fn? garden))\n                              (assoc :garden (constantly garden))\n\n                              :always\n                              (update :garden #(comp process-rule %)))))\n                     components)\n               :colors (into (empty colors)\n                             (map (juxt (comp name key) val))\n                             colors)\n               :fonts (into (empty fonts)\n                            (map (juxt (comp name key) val))\n                            fonts)})]\n         (reset! girouette-api\n                 (girouette/make-api\n                  components\n                  {:color-map colors\n                   :font-family-map fonts}))))\n\n     (defonce set-default-tokens (set-tokens! nil))\n\n     (defn class-name->garden [n]\n       ((:class-name->garden @girouette-api) n))\n\n     (defmethod print-method ::styled [x writer]\n       (.write writer (classname x)))\n\n     (def munge-map\n       {\\@ \"_CIRCA_\"\n        \\! \"_BANG_\"\n        \\# \"_SHARP_\"\n        \\% \"_PERCENT_\"\n        \\& \"_AMPERSAND_\"\n        \\' \"_SINGLEQUOTE_\"\n        \\* \"_STAR_\"\n        \\+ \"_PLUS_\"\n        \\- \"_\"\n        \\/ \"_SLASH_\"\n        \\: \"_COLON_\"\n        \\[ \"_LBRACK_\"\n        \\{ \"_LBRACE_\"\n        \\< \"_LT_\"\n        \\\\ \"_BSLASH_\"\n        \\| \"_BAR_\"\n        \\= \"_EQ_\"\n        \\] \"_RBRACK_\"\n        \\} \"_RBRACE_\"\n        \\> \"_GT_\"\n        \\^ \"_CARET_\"\n        \\~ \"_TILDE_\"\n        \\? \"_QMARK_\"})\n\n     (defn munge-str [s]\n       #?(:clj\n          (let [sb (StringBuilder.)]\n            (doseq [ch s]\n              (if-let [repl (get munge-map ch)]\n                (.append sb repl)\n                (.append sb ch)))\n            (str sb))\n          :cljs\n          (apply str (map #(get munge-map % %) s))))\n\n     (defn classname-for\n       \"Convert a fully qualified symbol into a CSS classname\n\n  Munges special characters, and honors `:ornament/prefix` metadata on the\n  namespace.\"\n       [varsym]\n       (let [prefix (or (:ornament/prefix (meta (the-ns (symbol (namespace varsym)))))\n                        (-> varsym\n                            namespace\n                            (str/replace #\"\\.\" \"_\")))]\n         (str prefix \"__\" (munge-str (name varsym)))))\n\n     (defn join-vector-by [sep val]\n       (if (vector? val)\n         (str/join sep val)\n         val))\n\n     (defmulti process-tag\n       \"Support some of our Garden extensions\n\n  Convert tagged vectors in the component rules into plain Garden, e.g.\n  `[:at-media]` or `[:rgb]`. Default implementation handles using styled\n  components as selectors, or otherwise simply preserves the tag.\"\n       (fn [[tag & _]] tag))\n\n     (defmethod process-tag :default [v]\n       (let [tag (first v)]\n         (into (if (set? tag)\n                 (into [] tag)\n                 [(cond\n                    (= ::styled (type tag))\n                    (classname tag)\n                    (sequential? tag)\n                    (process-rule tag)\n                    :else\n                    tag)])\n               (map process-rule (next v)))))\n\n     (defmethod process-tag :at-media [[_ media-queries & rules]]\n       (gs/at-media media-queries (into [:&] (map process-rule) rules)))\n\n     (defmethod process-tag :cssfn [[_ fn-name & args]]\n       (gt/->CSSFunction fn-name args))\n\n     (defmethod process-tag :at-supports [[_ feature-queries & rules]]\n       (gt/->CSSAtRule\n        :feature\n        {:feature-queries feature-queries\n         :rules           (list (into [:&] (map (comp process-rule)) rules))}))\n\n     (defmethod process-tag :rgb [[_ r g b]]\n       (gcolor/rgb [r g b]))\n\n     (defmethod process-tag :hsl [[_ h s l]]\n       (gcolor/hsl [h s l]))\n\n     (defmethod process-tag :rgba [[_ r g b a]]\n       (gcolor/rgba [r g b a]))\n\n     (defmethod process-tag :hsla [[_ h s l a]]\n       (gcolor/hsla [h s l a]))\n\n     (defmethod process-tag :str [[_ & xs]]\n       [(map #(if (string? %) (pr-str %) (process-rule %)) xs)])\n\n     (defmulti process-property\n       \"Special handling of certain CSS properties. E.g. setting `:grid-template-areas`\n  using a vector.\"\n       (fn [prop val] prop))\n\n     (defmethod process-property :default [_ val]\n       (if (vector? val)\n         (process-tag val)\n         val))\n\n     (defmethod process-property :grid-template-areas [_ val]\n       (if (vector? val)\n         (str/join \" \"\n                   (map (fn [row]\n                          (pr-str (str/join \" \" (map name row))))\n                        val))\n         val))\n\n     (defmethod process-property :grid-area [_ val] (join-vector-by \" / \" val))\n     (defmethod process-property :border [_ val] (join-vector-by \" \" val))\n     (defmethod process-property :margin [_ val] (join-vector-by \" \" val))\n     (defmethod process-property :padding [_ val] (join-vector-by \" \" val))\n\n     (defn process-rule\n       \"Process a single \\\"rule\\\" into plain Garden\n\n  Components receive a list of rules. These can be Garden-style maps,\n  Girouette-style keywords, or Garden-style vectors of selectors+rules. This\n  function together with [[process-tag]] and [[process-property]] defines the\n  recursive logic to turn this into something we can pass to the Garden\n  compiler.\"\n       [rule]\n       (cond\n         (record? rule) ; Prevent some defrecords in garden.types to be fudged\n         rule\n\n         (simple-keyword? rule)\n         (let [girouette-garden (class-name->garden (name rule))]\n           (cond\n             (nil? girouette-garden)\n             #_(throw (ex-info \"Girouette style expansion failed\" {:rule rule}))\n             rule\n\n             (and (record? girouette-garden)\n                  (= (:identifier girouette-garden) :media))\n             (-> girouette-garden\n                 (update-in [:value :rules] (fn [rules]\n                                              (map #(into [:&] (rest %)) rules))))\n             :else\n             (second girouette-garden)))\n\n         (map? rule)\n         (into {} (map (fn [[k v]] [k (process-property k v)])) rule)\n\n         (vector? rule)\n         (process-tag rule)\n\n         :else\n         rule))\n\n     (defn process-rules\n       \"Process the complete set of rules for a component, see [[process-rule]]\n\n  If multiple consecutive rules result in Garden property maps, then they get\n  merged, to prevent unnecessary bloat of the compiled CSS.\"\n       [rules]\n       (seq (reduce (fn [acc rule]\n                      (let [r (process-rule rule)]\n                        (if (and (map? r)\n                                 (map? (last acc))\n                                 (not (record? r))\n                                 (not (record? (last acc))))\n                          (conj (vec (butlast acc))\n                                (merge (last acc) r))\n                          (conj acc r))))\n                    [] rules)))))\n\n(defn add-class\n  \"Hiccup helper, add a CSS classname to an existing `:class` property\n\n  We allow components to define `:class` as a string, a vector, or to use a\n  styled component directly as a class. (This last behavior is to support some\n  legacy code, we recommend using a wrapping vector in that case).\n\n  This function handles these cases, and will always return a vector of class\n  names.\"\n  [classes class]\n  (cond\n    (string? classes)\n    [class classes]\n\n    (= ::styled (:type (meta classes)))\n    [class (str classes)]\n\n    (and (sequential? classes) (seq classes))\n    (vec (cons class classes))\n\n    :else\n    [(str class)]))\n\n(defn expand-hiccup-tag\n  \"Handle expanding/rendering the component to Hiccup\n\n  For plain [[defstyled]] components this simply adds the CSS class name. For\n  components with a function tail this handles calling it, and handles setting\n  attributes on the resulting element via metadata on the result.\"\n  [tag css-class args component]\n  (let [attr-map? (map? (first args))\n        attrs (when attr-map? (first args))\n        children (if attr-map? (next args) args)]\n    (if component\n      (let [child (apply component args)]\n        (expand-hiccup-tag tag\n                           css-class\n                           [(into (or (meta child) {})\n                                  (select-keys attrs [:id :class :style]))\n                            child]\n                           nil))\n      (into [tag (update attrs :class add-class css-class)] children))))\n\n(defn styled\n  ([varsym css-class tag rules component]\n   #?(:clj\n      ^{:type ::styled}\n      (reify\n        StyledComponent\n        (classname [_]\n          (reduce\n           (fn [c p]\n             (if (str/starts-with? (str c) p)\n               (reduced (subs (str c) (count p)))\n               c))\n           css-class\n           *strip-prefixes*))\n        (as-garden [this]\n          (into [(str \".\" (classname this))]\n                (process-rules rules)))\n        (css [this] (gc/compile-css\n                     {:pretty-print? false}\n                     (as-garden this)))\n        (rules [_] rules)\n        (tag [_] tag)\n        (component [_] component)\n        (as-hiccup [this children]\n          (expand-hiccup-tag tag (classname this) children component))\n\n        clojure.lang.IFn\n        (invoke [this]\n          (as-hiccup this nil))\n        (invoke [this a]\n          (as-hiccup this [a]))\n        (invoke [this a b]\n          (as-hiccup this [a b]))\n        (invoke [this a b c]\n          (as-hiccup this [a b c]))\n        (invoke [this a b c d]\n          (as-hiccup this [a b c d]))\n        (invoke [this a b c d e]\n          (as-hiccup this [a b c d e]))\n        (invoke [this a b c d e f]\n          (as-hiccup this [a b c d e f]))\n        (invoke [this a b c d e f g]\n          (as-hiccup this [a b c d e f g]))\n        (invoke [this a b c d e f g h]\n          (as-hiccup this [a b c d e f g h]))\n        (invoke [this a b c d e f g h i]\n          (as-hiccup this [a b c d e f g h i]))\n        (invoke [this a b c d e f g h i j]\n          (as-hiccup this [a b c d e f g h i j]))\n        (invoke [this a b c d e f g h i j k]\n          (as-hiccup this [a b c d e f g h i j k]))\n        (invoke [this a b c d e f g h i j k l]\n          (as-hiccup this [a b c d e f g h i j k l]))\n        (invoke [this a b c d e f g h i j k l m]\n          (as-hiccup this [a b c d e f g h i j k l m]))\n        (invoke [this a b c d e f g h i j k l m n]\n          (as-hiccup this [a b c d e f g h i j k l m n]))\n        (invoke [this a b c d e f g h i j k l m n o]\n          (as-hiccup this [a b c d e f g h i j k l m n o]))\n        (invoke [this a b c d e f g h i j k l m n o p]\n          (as-hiccup this [a b c d e f g h i j k l m n o p]))\n        (invoke [this a b c d e f g h i j k l m n o p q]\n          (as-hiccup this [a b c d e f g h i j k l m n o p q]))\n        (invoke [this a b c d e f g h i j k l m n o p q r]\n          (as-hiccup this [a b c d e f g h i j k l m n o p q r]))\n        (invoke [this a b c d e f g h i j k l m n o p q r s]\n          (as-hiccup this [a b c d e f g h i j k l m n o p q r s]))\n        (applyTo [this args]\n          (as-hiccup this args))\n\n        Object\n        (toString [this] (classname this))\n\n        gc/IExpandable\n        (expand [this]\n          (mapcat\n           (fn [rule]\n             (gc/expand\n              (if (map? rule)\n                [:& rule]\n                rule)))\n           rules)))\n\n      :cljs\n      (let [render-fn\n            ^{:type ::styled}\n            (fn [& children]\n              (expand-hiccup-tag tag\n                                 css-class\n                                 children\n                                 component))\n            component (specify! render-fn\n                        StyledComponent\n                        (classname [_] css-class)\n                        (as-garden [_] )\n                        (css [_] )\n                        (rules [_] )\n                        (tag [_] tag)\n                        (component [_] component)\n                        (as-hiccup [_ children]\n                          (expand-hiccup-tag tag css-class children component))\n\n                        Object\n                        (toString [_] css-class))]\n        (js/Object.defineProperty component \"name\" #js {:value (str varsym)})\n        component))))\n\n#?(:clj\n   (defn qualify-sym [env s]\n     (when (symbol? s)\n       (if (:ns env)\n         ;; cljs\n         (if (simple-symbol? s)\n           (or (some-> env :ns :uses s name (symbol (name s)))\n               (symbol (name (-> env :ns :name)) (name s)))\n           (symbol (or (some-> env :ns :requires (get (symbol (namespace s))) name)\n                       (namespace s))\n                   (name s)))\n\n         ;; clj\n         (if (simple-symbol? s)\n           (or (some-> (ns-refers *ns*) (get s) symbol)\n               (symbol (str *ns*) (str s)))\n           (let [ns (namespace s)\n                 n (name s)\n                 aliases (ns-aliases *ns*)]\n             (symbol (or (some-> aliases (get (symbol ns)) ns-name str) ns) n)))))))\n\n#?(:clj (defn fn-tail? [o]\n          (and (list? o)\n               (vector? (first o)))))\n\n#?(:clj\n   (defmacro defstyled [sym tagname & styles]\n     (let [varsym (symbol (name (ns-name *ns*)) (name sym))\n           css-class (classname-for varsym)\n           [styles fn-tails] (split-with (complement fn-tail?) styles)\n           tag (if (keyword? tagname)\n                 tagname\n                 (get-in @registry [(qualify-sym &env tagname) :tag]))\n           rules (cond\n                   (keyword? tagname)\n                   (vec styles)\n                   (symbol? tagname)\n                   (into (or (:rules (get @registry (qualify-sym &env tagname))) [])\n                         styles))\n\n           ;; For ClojureScript support (but also used in Clojure-only), add the\n           ;; Clojure-version of the styled component to the registry directly\n           ;; during macroexpansion, so that even in a ClojureScript-only world\n           ;; we can access it later to compile the styles, even though the\n           ;; styles themselves are never part of a ClojureScript build.\n           ;;\n           ;; To allow using previously defined styled components as selectors\n           ;; we do our own resolution of these symbols, if we recognize them.\n           ;; This is necessary since in ClojureScript rules are fully handled\n           ;; on the Clojure side (we don't want any of the CSS overhead in the\n           ;; build output), and when defined defstyled in cljs files there are\n           ;; no Clojure vars that we can resolve, so we need to resolve this\n           ;; ourselves via the registry.\n           rules (eval `(do\n                          (in-ns '~(ns-name *ns*))\n                          ~(walk/postwalk\n                            (fn [o]\n                              (if (vector? o)\n                                (into [(if (and (symbol? (first o))\n                                                (contains? @registry (qualify-sym &env (first o))))\n                                         `(str \".\" (get-in @registry ['~(qualify-sym &env (first o)) :classname]))\n                                         (first o))]\n                                      (mapcat (fn [s]\n                                                (if (and (symbol? s)\n                                                         (contains? @registry (qualify-sym &env s)))\n                                                  (get-in @registry [(qualify-sym &env s) :rules])\n                                                  [s])))\n                                      (next o))\n                                o))\n                            rules)))]\n       (swap! registry\n              (fn [reg]\n                (-> reg\n                    (update varsym merge {:var varsym\n                                          :tag tag\n                                          :rules rules\n                                          :classname css-class\n                                          :component (styled varsym\n                                                             css-class\n                                                             tag\n                                                             rules\n                                                             nil)})\n                    ;; We give each style an incrementing index so they get a\n                    ;; predictable order (i.e. source order). If a style is\n                    ;; evaluated again (e.g. REPL use) then it keeps its\n                    ;; original index/position.\n                    (update-in [varsym :index] (fnil identity (count reg))))))\n\n       ;; Actual output of the macro, this creates a styled component as a var,\n       ;; so that it can be used in Hiccup. This `styled` invocation in turn is\n       ;; platform-specific, the ClojureScript version only knows how to render\n       ;; the component with the appropriate classes, it has no knowledge of the\n       ;; actual styles, which are expected to be rendered on the backend or\n       ;; during compilation.\n       `(def ~(with-meta sym {::css true :ornament (dissoc (get @registry varsym) :component)})\n          (styled '~varsym\n                  ~css-class\n                  ~tag\n                  ~(when-not (:ns &env) rules)\n                  ~(when (seq fn-tails)\n                     `(fn ~@fn-tails)))))))\n\n#?(:clj\n   (defn defined-garden []\n     (for [{:keys [css-class rules]} (->> @registry\n                                          vals\n                                          (sort-by :index))]\n       (into [(str \".\" css-class)] (process-rules rules)))))\n\n#?(:clj\n   (defn defined-styles [& [{:keys [preflight?]\n                             :or {preflight? false}}]]\n     ;; Use registry, instead of inspecting metadata, for better cljs-only\n     ;; support\n     (let [registry-css (->> @registry\n                             vals\n                             (sort-by :index)\n                             (map (fn [{:keys [var tag rules classname]}]\n                                    (css (styled var classname tag rules nil)))))]\n       (cond->> registry-css\n         preflight? (into [(gc/compile-css girouette-preflight/preflight)])\n         :always (str/join \"\\n\")))))\n\n#?(:clj\n   (defn cljs-restore-registry\n     \"Restore the Ornament registry based on a ClojureScript compiler env\n\n  Due to caching some defstyled macros may not get recompiled, causing gaps in\n  the CSS. To work around this we add Ornament data to the cljs analyzer var\n  metadata, so it gets cached and restored with the rest of the analyzer state.\"\n     [compiler-env]\n     (when (empty? @registry)\n       (reset! registry\n               (into {}\n                     (for [[_ {:keys [defs]}] (:cljs.analyzer/namespaces compiler-env)\n                           [_ {{:keys [ornament]} :meta}] defs\n                           :when ornament]\n                       [(:var ornament) ornament]))))))\n\n(comment\n (spit \"/tmp/ornament.css\" (defined-styles))\n )\n"]}